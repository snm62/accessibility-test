// CRITICAL: Immediate seizure-safe check - runs before any animations can start
(function() {
    function isDesignerModeStandalone() {
        try {
            return (
                (window.location.hostname.includes('webflow.com') && 
                 (window.location.pathname.includes('/design/') || 
                  window.location.pathname.includes('/designer'))) ||
                document.querySelector('[data-webflow-design-mode]') ||
                (typeof window.webflow !== 'undefined' && 
                 typeof window.webflow.getSiteInfo === 'function' && 
                 window.location.hostname.includes('webflow.com'))
            );
        } catch (e) {
            return false;
        }
    }
    
    try {
        if (isDesignerModeStandalone()) {
            return;
        }
        
        function isReaderModeStandalone() {
            try {
                return (
                    document.documentElement.classList.contains('reader-mode') || 
                    (document.body && document.body.classList.contains('reader-mode')) ||
                    window.location.search.includes('reader-mode') ||
                    document.querySelector('[data-reader-mode]')
                );
            } catch (e) {
                return false;
            }
        }
        
        if (isReaderModeStandalone()) {
            return;
        }
        
        // Check localStorage immediately for reduce-motion mode
        const reduceMotionFromStorage = localStorage.getItem('accessbit-widget-reduce-motion');
        if (reduceMotionFromStorage === 'true') {
            // SECURITY: All DOM operations protected by Designer mode check at line 20
            try {
                if (document.body) document.body.classList.add('reduce-motion');
                if (document.documentElement) document.documentElement.classList.add('reduce-motion');
            } catch (_) {}
            
            // Apply immediate CSS to stop all animations
            const immediateReduceMotionStyle = document.createElement('style');
            immediateReduceMotionStyle.id = 'accessbit-reduce-motion-immediate-early';
            immediateReduceMotionStyle.textContent = `
                /* Per Webflow Security recommendations: Global CSS kill switch for Reduce Motion */
                html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]),
                html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::before,
                html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::after,
                body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]),
                body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::before,
                body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::after {
                    animation: none !important;
                    transition: none !important;
                    scroll-behavior: auto !important;
                }
                
                /* Remove common flash triggers (blinking caret effects, shimmer skeletons, pulsing outlines, etc.) */
                body.reduce-motion *[class*="blink"], body.reduce-motion *[class*="shimmer"], 
                body.reduce-motion *[class*="pulse"], body.reduce-motion *[class*="caret"], 
                body.reduce-motion *[class*="cursor-blink"], body.reduce-motion *[class*="skeleton"],
                body.reduce-motion *[class*="pulsing"], body.reduce-motion *[class*="flashing"],
                html.reduce-motion *[class*="blink"], html.reduce-motion *[class*="shimmer"], 
                html.reduce-motion *[class*="pulse"], html.reduce-motion *[class*="caret"], 
                html.reduce-motion *[class*="cursor-blink"], html.reduce-motion *[class*="skeleton"],
                html.reduce-motion *[class*="pulsing"], html.reduce-motion *[class*="flashing"] {
                    animation: none !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                }
                
                /* Remove blinking caret effects */
                body.reduce-motion input[type="text"], body.reduce-motion input[type="email"], 
                body.reduce-motion input[type="search"], body.reduce-motion input[type="tel"], 
                body.reduce-motion input[type="url"], body.reduce-motion input[type="password"], 
                body.reduce-motion textarea, body.reduce-motion [contenteditable="true"],
                html.reduce-motion input[type="text"], html.reduce-motion input[type="email"], 
                html.reduce-motion input[type="search"], html.reduce-motion input[type="tel"], 
                html.reduce-motion input[type="url"], html.reduce-motion input[type="password"], 
                html.reduce-motion textarea, html.reduce-motion [contenteditable="true"] {
                    caret-color: transparent !important;
                }
            `;
            // SECURITY: Protected by Designer mode check at line 20 - all DOM operations in this IIFE are safe
            try {
                if (document.head) document.head.appendChild(immediateReduceMotionStyle);
            } catch (_) {}
            
            // Use WAAPI to pause/cancel running animations immediately
            try {
                const all = (document.getAnimations && document.getAnimations({ subtree: true })) || [];
                all.forEach(anim => {
                    try {
                        if (typeof anim.pause === 'function') anim.pause();
                        if (typeof anim.playbackRate !== 'undefined') anim.playbackRate = 0;
                    } catch (_) {}
                });
            } catch (_) {}
        }
        
        // Check localStorage immediately for seizure-safe mode
        const seizureSafeFromStorage = localStorage.getItem('accessbit-widget-seizure-safe');
        if (seizureSafeFromStorage === 'true') {
            // SECURITY: Protected by Designer mode check at line 20
            try {
                if (document.body) document.body.classList.add('seizure-safe');
            } catch (_) {}
            
            // Apply immediate CSS to stop all animations
            const immediateStyle = document.createElement('style');
            immediateStyle.id = 'accessbit-seizure-immediate-early';
            immediateStyle.textContent = `
                /* APPLY GREYISH COLOR FILTER IMMEDIATELY - Reduce color intensity to prevent seizures */
                /* CRITICAL: Apply filters to content containers, NOT to body/html, to preserve sticky nav */
                /* Filters create stacking contexts that break sticky positioning - so we avoid them on body/html */
                /* Apply to main content areas and their children to get the grey muted color effect throughout the page */
                body.seizure-safe main,
                body.seizure-safe main *,
                body.seizure-safe section,
                body.seizure-safe section *,
                body.seizure-safe article,
                body.seizure-safe article *,
                body.seizure-safe div:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]):not([class*="navbar"]),
                body.seizure-safe p:not(nav p):not(header p),
                body.seizure-safe span:not(nav span):not(header span),
                html.seizure-safe main,
                html.seizure-safe main *,
                html.seizure-safe section,
                html.seizure-safe section *,
                html.seizure-safe article,
                html.seizure-safe article *,
                html.seizure-safe div:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]):not([class*="navbar"]),
                html.seizure-safe p:not(nav p):not(header p),
                html.seizure-safe span:not(nav span):not(header span) {
                    filter: grayscale(15%) contrast(0.95) brightness(0.98) !important;
                    -webkit-filter: grayscale(15%) contrast(0.95) brightness(0.98) !important;
                }
                
                /* Per Webflow Security recommendations: Global CSS kill switch for seizure-safe mode */
                /* This provides stricter controls than prefers-reduced-motion for photosensitive seizure safety */
                body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]):not(accessbit-widget),
                html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]):not(accessbit-widget) {
                    animation: none !important;
                    transition: none !important;
                    scroll-behavior: auto !important;
                }
                
                /* Remove common flash triggers (blinking caret effects, shimmer skeletons, pulsing outlines, etc.) */
                body.seizure-safe *[class*="blink"], body.seizure-safe *[class*="shimmer"], 
                body.seizure-safe *[class*="pulse"], body.seizure-safe *[class*="caret"], 
                body.seizure-safe *[class*="cursor-blink"], body.seizure-safe *[class*="skeleton"],
                body.seizure-safe *[class*="pulsing"], body.seizure-safe *[class*="flashing"],
                html.seizure-safe *[class*="blink"], html.seizure-safe *[class*="shimmer"], 
                html.seizure-safe *[class*="pulse"], html.seizure-safe *[class*="caret"], 
                html.seizure-safe *[class*="cursor-blink"], html.seizure-safe *[class*="skeleton"],
                html.seizure-safe *[class*="pulsing"], html.seizure-safe *[class*="flashing"] {
                    animation: none !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                }
                
                /* CRITICAL: Exclude navigation elements from filter to preserve sticky/fixed positioning */
                body.seizure-safe nav,
                body.seizure-safe header,
                body.seizure-safe .navbar,
                body.seizure-safe [role="navigation"],
                body.seizure-safe [class*="nav"],
                body.seizure-safe [class*="header"],
                body.seizure-safe [class*="navbar"],
                body.seizure-safe [data-sticky],
                body.seizure-safe [data-fixed],
                body.seizure-safe [style*="position: sticky"],
                body.seizure-safe [style*="position:fixed"],
                body.seizure-safe [style*="position: fixed"] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Exclude widget container and all its contents from color filter */
                body.seizure-safe #accessbit-widget-container,
                body.seizure-safe [id*="accessbit-widget"],
                body.seizure-safe [class*="accessbit-widget"],
                body.seizure-safe [data-ck-widget] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Also exclude any shadow DOM content by targeting the host element */
                body.seizure-safe accessbit-widget {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* NOTE: Global animation-kill rules removed per configuration change to allow more motion */
                /* Ensure interactive elements still show pointer cursor in seizure-safe mode */
                body.seizure-safe a[href], body.seizure-safe button, body.seizure-safe [role="button"], body.seizure-safe [onclick], body.seizure-safe input[type="button"], body.seizure-safe input[type="submit"], body.seizure-safe input[type="reset"], body.seizure-safe .btn, body.seizure-safe .button, body.seizure-safe [class*="btn"], body.seizure-safe [class*="button"], body.seizure-safe [tabindex]:not([tabindex="-1"]) {
                    cursor: pointer !important;
                }
                /* Keep text cursor for text-editable fields */
                body.seizure-safe input[type="text"], body.seizure-safe input[type="email"], body.seizure-safe input[type="search"], body.seizure-safe input[type="tel"], body.seizure-safe input[type="url"], body.seizure-safe input[type="password"], body.seizure-safe textarea, body.seizure-safe [contenteditable="true"] {
                    cursor: text !important;
                }
                /* Stop animations for media elements without changing their layout */
                body.seizure-safe img, body.seizure-safe video, body.seizure-safe audio, body.seizure-safe iframe, body.seizure-safe embed, body.seizure-safe object {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                    /* REMOVED: opacity: 1 and visibility: visible - these were causing extra white space by revealing hidden elements */
                }
                /* Stop animations for text elements without forcing hidden animation clones to become visible */
                body.seizure-safe h1, body.seizure-safe h2, body.seizure-safe h3, body.seizure-safe h4, body.seizure-safe h5, body.seizure-safe h6,
                body.seizure-safe p, body.seizure-safe span, body.seizure-safe div, body.seizure-safe a,
                body.seizure-safe li, body.seizure-safe td, body.seizure-safe th, body.seizure-safe label {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                    /* Do NOT override opacity/visibility here: many animation libraries keep
                       duplicate text elements hidden with opacity:0; forcing them visible
                       causes overlapping/ghost text behind the main heading. */
                }
                /* Force GSAP and other library fade/slide utilities to final, static state */
                body.seizure-safe .fade-up,
                body.seizure-safe .fade-left,
                body.seizure-safe .fade-right,
                body.seizure-safe .fade-in,
                body.seizure-safe .slide-in,
                body.seizure-safe .scale-in,
                body.seizure-safe .zoom-in {
                    /* REMOVED: opacity: 1 and visibility: visible - these were causing extra white space by revealing hidden elements */
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                }
                /* AUTOPLAY MEDIA: Stop all autoplay videos and media */
                /* REMOVED: opacity: 1 and visibility: visible - these were causing extra white space by revealing hidden elements */
                body.seizure-safe video, body.seizure-safe audio, body.seizure-safe iframe, body.seizure-safe embed, body.seizure-safe object, body.seizure-safe [autoplay], body.seizure-safe [data-autoplay], body.seizure-safe [class*="autoplay"], body.seizure-safe [class*="video"], body.seizure-safe [class*="media"] {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                }
                /* CRITICAL: Exclude dropdown menus from visibility forcing - they should remain hidden until explicitly opened */
                /* This rule must come after the hover rule above to override it for dropdowns */
                /* Handle both normal and hover states to prevent auto-opening */
                body.seizure-safe [class*="dropdown"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe [class*="dropdown"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                body.seizure-safe [id*="dropdown"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe [id*="dropdown"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                body.seizure-safe [class*="menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):not(nav):not(header),
                body.seizure-safe [class*="menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):not(nav):not(header):hover,
                body.seizure-safe [id*="menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):not(nav):not(header),
                body.seizure-safe [id*="menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):not(nav):not(header):hover,
                body.seizure-safe [role="menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe [role="menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                body.seizure-safe [role="menubar"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe [role="menubar"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                /* Also handle common dropdown patterns like ul/ol inside nav items */
                body.seizure-safe nav ul:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe nav ul:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                body.seizure-safe header ul:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe header ul:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                body.seizure-safe [class*="nav"] ul:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe [class*="nav"] ul:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                body.seizure-safe [class*="submenu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe [class*="submenu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover,
                body.seizure-safe [class*="sub-menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]),
                body.seizure-safe [class*="sub-menu"]:not([class*="open"]):not([class*="active"]):not([class*="show"]):not([aria-expanded="true"]):hover {
                    /* Allow dropdowns to maintain their original visibility state - override the hover rule */
                    opacity: inherit !important;
                    visibility: inherit !important;
                    display: inherit !important;
                }
                /* LETTER-BY-LETTER ANIMATIONS: Force all text animations to final state */
                /* Hide per-character/word spans ONLY after JS has consolidated text on the container.
                   This prevents overlap on processed elements, without breaking sites where JS fails. */
                body.seizure-safe [data-splitting][data-seizure-text-processed] .char, 
                body.seizure-safe [data-splitting][data-seizure-text-processed] .word,
                body.seizure-safe .split[data-seizure-text-processed] .char, 
                body.seizure-safe .split[data-seizure-text-processed] .word,
                body.seizure-safe [class*="split"][data-seizure-text-processed] [class*="char"]:not([class*="character"]):not([class*="chart"]), 
                body.seizure-safe [class*="split"][data-seizure-text-processed] [class*="word"]:not([class*="wording"]),
                body.seizure-safe [class*="text-animation"][data-seizure-text-processed] .char,
                body.seizure-safe [class*="text-animation"][data-seizure-text-processed] .word,
                body.seizure-safe [class*="text-animation"][data-seizure-text-processed] [class*="char"]:not([class*="character"]):not([class*="chart"]),
                body.seizure-safe [class*="text-animation"][data-seizure-text-processed] [class*="word"]:not([class*="wording"]),
                body.seizure-safe [class*="typing"][data-seizure-text-processed] .char,
                body.seizure-safe [class*="typing"][data-seizure-text-processed] .word,
                body.seizure-safe [class*="typewriter"][data-seizure-text-processed] .char,
                body.seizure-safe [class*="typewriter"][data-seizure-text-processed] .word,
                body.seizure-safe [class*="reveal"][data-seizure-text-processed] .char,
                body.seizure-safe [class*="reveal"][data-seizure-text-processed] .word,
                body.seizure-safe [class*="unveil"][data-seizure-text-processed] .char,
                body.seizure-safe [class*="unveil"][data-seizure-text-processed] .word,
                body.seizure-safe [class*="show-text"][data-seizure-text-processed] .char,
                body.seizure-safe [class*="show-text"][data-seizure-text-processed] .word,
                body.seizure-safe [class*="text-effect"][data-seizure-text-processed] .char,
                body.seizure-safe [class*="text-effect"][data-seizure-text-processed] .word {
                    animation: none !important;
                    transition: none !important;
                    opacity: 0 !important;
                    visibility: hidden !important;
                    position: absolute !important;
                    transform: none !important;
                    clip-path: none !important;
                    -webkit-clip-path: none !important;
                    display: none !important;
                    pointer-events: none !important;
                }
                /* Show parent containers after JS processes them - these will have the consolidated text */
                body.seizure-safe [data-splitting][data-seizure-text-processed], 
                body.seizure-safe .split[data-seizure-text-processed], 
                body.seizure-safe [class*="split"][data-seizure-text-processed], 
                body.seizure-safe [class*="text-animation"][data-seizure-text-processed], 
                body.seizure-safe [class*="typing"][data-seizure-text-processed], 
                body.seizure-safe [class*="typewriter"][data-seizure-text-processed], 
                body.seizure-safe [class*="reveal"][data-seizure-text-processed], 
                body.seizure-safe [class*="unveil"][data-seizure-text-processed], 
                body.seizure-safe [class*="show-text"][data-seizure-text-processed], 
                body.seizure-safe [class*="text-effect"][data-seizure-text-processed] {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                    animation-play-state: paused !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    /* Force all text to be fully visible - remove any clipping restrictions */
                    clip-path: none !important;
                    -webkit-clip-path: none !important;
                    /* REMOVED: width: auto, height: auto, max-width: none, max-height: none - these were causing extra white space at the bottom */
                }
                /* For text animation containers not yet processed, ensure they're visible but hide overlapping children */
                body.seizure-safe [data-splitting]:not([data-seizure-text-processed]), 
                body.seizure-safe .split:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="split"]:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="text-animation"]:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="typing"]:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="typewriter"]:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="reveal"]:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="unveil"]:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="show-text"]:not([data-seizure-text-processed]), 
                body.seizure-safe [class*="text-effect"]:not([data-seizure-text-processed]) {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                    animation-play-state: paused !important;
                    /* Don't force opacity/visibility here - let JS handle consolidation first */
                }
                /* Hide duplicate text elements detected by JS (like Webflow's h1 + animated h2) */
                body.seizure-safe [data-seizure-duplicate-hidden] {
                    display: none !important;
                    visibility: hidden !important;
                    opacity: 0 !important;
                    position: absolute !important;
                    pointer-events: none !important;
                }
                /* Hide per-letter spans in Webflow-style elements that have been consolidated.
                   Only hide spans in elements that have many child spans (likely per-letter animation) */
                body.seizure-safe [data-seizure-text-processed][class*="fade-up"] > span,
                body.seizure-safe [data-seizure-text-processed][class*="fade-in"] > span,
                body.seizure-safe [data-seizure-text-processed][class*="multi-text"] > span,
                body.seizure-safe [data-seizure-text-processed].hero-heading > span {
                    display: none !important;
                    visibility: hidden !important;
                    opacity: 0 !important;
                    position: absolute !important;
                    pointer-events: none !important;
                }
                /* SCROLL-TRIGGERED ANIMATIONS: Stop all scroll-based animations IMMEDIATELY */
                body.seizure-safe *[class*="scroll"], 
                body.seizure-safe *[class*="progress"], 
                body.seizure-safe *[class*="bar"], 
                body.seizure-safe *[class*="line"], 
                body.seizure-safe *[class*="timeline"], 
                body.seizure-safe *[class*="track"], 
                body.seizure-safe *[class*="path"], 
                body.seizure-safe *[class*="stroke"], 
                body.seizure-safe *[class*="fill"], 
                body.seizure-safe *[class*="gradient"], 
                body.seizure-safe *[class*="wave"], 
                body.seizure-safe *[class*="flow"], 
                body.seizure-safe *[class*="stream"], 
                body.seizure-safe *[class*="runner"], 
                body.seizure-safe *[class*="mover"], 
                body.seizure-safe *[class*="indicator"], 
                body.seizure-safe *[class*="stopper"], 
                body.seizure-safe *[class*="marker"], 
                body.seizure-safe *[class*="pointer"], 
                body.seizure-safe *[class*="cursor"], 
                body.seizure-safe *[class*="dot"], 
                body.seizure-safe *[class*="circle"], 
                body.seizure-safe *[class*="ring"], 
                body.seizure-safe *[class*="orbit"],
                body.seizure-safe [data-scroll],
                body.seizure-safe [data-aos],
                body.seizure-safe [data-animate],
                body.seizure-safe [data-wf-page],
                body.seizure-safe [data-w-id] {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                    /* REMOVED: opacity: 1 and visibility: visible - these were causing extra white space by revealing hidden elements */
                    /* Preserve transforms for slider manual navigation */
                    transform: none !important;
                    will-change: auto !important;
                }
                
                /* SLIDERS: Block auto-play animations but allow manual navigation - preserve transforms */
                body.seizure-safe .swiper-slide,
                body.seizure-safe .slick-slide,
                body.seizure-safe .carousel-item,
                body.seizure-safe [class*="swiper"] *,
                body.seizure-safe [class*="slick"] *,
                body.seizure-safe [class*="carousel"] *,
                body.seizure-safe [data-slider] *,
                body.seizure-safe [data-carousel] * {
                    /* Allow transforms for manual slide navigation */
                    transform: unset !important;
                }
                
                /* SLIDERS: Block auto-play animations but allow manual navigation */
                body.seizure-safe .swiper,
                body.seizure-safe .swiper-container,
                body.seizure-safe .slick-slider,
                body.seizure-safe .carousel,
                body.seizure-safe [class*="slider"]:not([class*="toggle"]):not(.toggle-switch .slider),
                body.seizure-safe [class*="carousel"],
                body.seizure-safe [data-slider],
                body.seizure-safe [data-carousel] {
                    /* Block auto-play animations */
                    animation: none !important;
                    /* Allow pointer events for manual navigation */
                    pointer-events: auto !important;
                    cursor: default !important;
                    /* Allow slide transitions for manual navigation */
                    transition: transform 0.3s ease !important;
                }
                
                /* Slider slides: block auto-animations but allow manual slide changes */
                body.seizure-safe .swiper-slide,
                body.seizure-safe .slick-slide,
                body.seizure-safe .carousel-item {
                    animation: none !important;
                    /* Allow transform for manual slide navigation */
                    transition: transform 0.3s ease !important;
                    pointer-events: auto !important;
                }
                /* REMOVED: Duplicate rule - already covered by scroll-triggered animations section */
                /* REMOVED: Duplicate data-splitting rules - already covered by letter-by-letter animations section */
                    `;
                    // SECURITY: Protected by Designer mode check at line 20
                    try {
                        if (document.head) document.head.appendChild(immediateStyle);
                    } catch (_) {}
            
            // Reinforce at root: cover both html.seizure-safe and body.seizure-safe
            try {
                if (!document.getElementById('accessbit-seizure-reinforce')) {
                    const reinforce = document.createElement('style');
                    reinforce.id = 'accessbit-seizure-reinforce';
                    reinforce.textContent = `
                        /* Exclude nav/header to preserve sticky positioning */
                        html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after,
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after {
                            /* Complete animations to final state instead of stopping mid-way */
                            animation-play-state: paused !important;
                            animation-fill-mode: forwards !important;
                            animation: none !important;
                            animation-name: none !important;
                            transition: none !important;
                            transition-property: none !important;
                        }
                        /* Keep cursors intact */
                        html.seizure-safe a[href], html.seizure-safe button, html.seizure-safe [role="button"], html.seizure-safe [onclick],
                        html.seizure-safe input[type="button"], html.seizure-safe input[type="submit"], html.seizure-safe input[type="reset"],
                        html.seizure-safe .btn, html.seizure-safe .button, html.seizure-safe [class*="btn"], html.seizure-safe [class*="button"],
                        html.seizure-safe [tabindex]:not([tabindex="-1"]) { cursor: pointer !important; }
                        html.seizure-safe input[type="text"], html.seizure-safe input[type="email"], html.seizure-safe input[type="search"],
                        html.seizure-safe input[type="tel"], html.seizure-safe input[type="url"], html.seizure-safe input[type="password"],
                        html.seizure-safe textarea, html.seizure-safe [contenteditable="true"] { cursor: text !important; }
                    `;
                    document.head.appendChild(reinforce);
                }
            } catch (_) {}
            
            // Master layer: globally disable CSS animations/transitions without altering layout
            try {
                if (!document.getElementById('accessbit-seizure-master')) {
                    const master = document.createElement('style');
                    master.id = 'accessbit-seizure-master';
                    master.textContent = `
                        /* Hard stop for CSS animations and transitions */
                        /* Force animations to final state immediately - either prevent from starting or jump to final state */
                        /* Exclude nav/header to preserve sticky positioning and layout */
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), 
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, 
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after {
                            /* Set duration to 0s so animations complete instantly (jump to final state) */
                            animation-duration: 0s !important;
                            animation-delay: 0s !important;
                            animation-fill-mode: forwards !important;
                            animation-iteration-count: 1 !important;
                            /* Prevent new animations from starting */
                            animation-play-state: paused !important;
                            transition: none !important;
                            transition-property: none !important;
                            transition-duration: 0s !important;
                            transition-delay: 0s !important;
                            /* REMOVED: scroll-behavior: auto !important; - This was blocking Lenis smooth scrolling */
                        }
                        /* Do not affect cursor appearance */
                        body.seizure-safe * { cursor: inherit; }
                    `;
                    document.head.appendChild(master);
                }
                
                // Correction layer: preserve site layout styles while keeping animations disabled
                if (!document.getElementById('accessbit-seizure-correction')) {
                    const correction = document.createElement('style');
                    correction.id = 'accessbit-seizure-correction';
                    correction.textContent = `
                        /* Keep animations disabled - exclude nav/header to preserve sticky positioning */
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]) {
                            animation: none !important;
                            transition: none !important;
                        }
                        /* Restore layout-affecting properties to stylesheet values - exclude nav/header */
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), 
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, 
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after {
                            transform: unset !important;
                            translate: unset !important;
                            scale: unset !important;
                            rotate: unset !important;
                            opacity: unset !important;
                            visibility: unset !important;
                            /* CRITICAL: Do NOT unset position - this breaks sticky/fixed navigation */
                            /* REMOVED: position: unset !important; */
                            top: unset !important;
                            left: unset !important;
                            right: unset !important;
                            bottom: unset !important;
                            width: unset !important;
                            height: unset !important;
                        }
                        
                        /* CRITICAL: Preserve positioning for nav elements and ensure their positioning is not affected */
                        body.seizure-safe nav,
                        body.seizure-safe header,
                        body.seizure-safe .navbar,
                        body.seizure-safe [role="navigation"],
                        body.seizure-safe [class*="nav"],
                        body.seizure-safe [class*="header"],
                        body.seizure-safe [class*="navbar"],
                        body.seizure-safe [data-sticky],
                        body.seizure-safe [data-fixed],
                        body.seizure-safe [style*="position: sticky"],
                        body.seizure-safe [style*="position:fixed"],
                        body.seizure-safe [style*="position: fixed"] {
                            position: inherit !important;
                            transform: inherit !important;
                            /* Preserve opacity and visibility for nav elements to maintain their appearance */
                            opacity: inherit !important;
                            visibility: inherit !important;
                        }
                        /* Preserve only genuine navigation/header and explicit opt-outs */
                        body.seizure-safe nav, body.seizure-safe header, body.seizure-safe .navbar,
                        body.seizure-safe [role="navigation"], body.seizure-safe [data-allow-transform] {
                            /* Do not touch nav/header positioning to preserve sticky/fixed behavior */
                            /* REMOVED: transform: unset !important; - This was conflicting with transform: inherit above and breaking sticky navigation */
                            opacity: inherit !important;
                            visibility: inherit !important;
                        }
                    `;
                    document.head.appendChild(correction);
                }
            } catch (_) {}
            
            // Enforce no-scroll-animations for known libraries/selectors with high specificity
            try {
                if (!document.getElementById('accessbit-seizure-animation-enforcer')) {
                    const enforce = document.createElement('style');
                    enforce.id = 'accessbit-seizure-animation-enforcer';
                    enforce.textContent = `
                        /* Target common scroll animation libs without affecting layout of others */
                        body.seizure-safe [data-aos], body.seizure-safe .aos-init, body.seizure-safe .aos-animate,
                        body.seizure-safe [data-scroll], body.seizure-safe [data-animate], body.seizure-safe .wow,
                        body.seizure-safe .animate__animated, body.seizure-safe .fade-up, body.seizure-safe .fade-in,
                        body.seizure-safe .slide-in, body.seizure-safe .reveal, body.seizure-safe [class*="fade-"],
                        body.seizure-safe [class*="slide-"], body.seizure-safe [class*="reveal"], body.seizure-safe [class*="animate"] {
                            animation: none !important;
                            transition: none !important;
                            opacity: 1 !important;
                            /* transform: none !important; - REMOVED: This was breaking website layout */
                            will-change: auto !important;
                        }
                    `;
                    document.head.appendChild(enforce);
                }
            } catch (_) {}
            
            try { document.documentElement.classList.add('seizure-safe'); } catch (_) {}
            try { document.documentElement.setAttribute('data-seizure-safe', 'true'); } catch (_) {}
            
            const seizureState = {
                guardsApplied: false,
                animationBlockerInstalled: false,
                styleObserver: null,
                classWatcher: null,
                seizureObserver: null,
                savedAnimations: new Map(),
                waapiListenersInstalled: false,
                onAnimationStart: null,
                onTransitionRun: null,
                universalMotionObserver: null,
                originalLottieLoadAnimation: null,
                styleSanitizerObserver: null
            };
            
            let applySeizureSafeDOMFreeze, seizureConsolidateSplitText, applyWAAPIStopMotion, installStyleSanitizer, stopStyleSanitizer;
            
            try {
                
                if (!seizureState.guardsApplied) {
                    seizureState.guardsApplied = true;
                    
                    const applySeizureSafeDOMFreeze = function() {
                        try {
                            // Check Designer mode first
                            // Use standalone Designer mode check
                            if (isDesignerModeStandalone()) return; // Exit early in Designer
                            
                            // Reveal typewriter/typing effects by consolidating text
                            const typeSelectors = [
                                '[class*="typewriter"]', '[class*="typing"]', '[data-typing]', '[data-typewriter]'
                            ];
                            // Use scoped query that excludes Designer elements
                            const widget = window.AccessibilityWidgetInstance;
                            const queryFn = widget && typeof widget.scopedQuerySelectorAll === 'function' 
                                ? (sel) => widget.scopedQuerySelectorAll(sel)
                                : (sel) => document.querySelectorAll(sel);
                            
                            queryFn(typeSelectors.join(',')).forEach(el => {
                                try {
                                    // Skip if already processed to prevent duplication
                                    if (el.hasAttribute('data-seizure-processed')) return;
                                    el.setAttribute('data-seizure-processed', 'true');
                                    
                                    const datasetText = el.getAttribute('data-full-text') || el.getAttribute('data-text') || '';
                                    if (datasetText) { 
                                        el.textContent = datasetText; 
                                        return; 
                                    }
                                    // If split into character spans, join them (but preserve original structure)
                                    const charSpans = el.querySelectorAll('.char, [class*="char"], .letter, [class*="letter"]');
                                    if (charSpans && charSpans.length > 0) {
                                        // Only consolidate if the element doesn't already have complete text
                                        const currentText = el.textContent.trim();
                                        if (!currentText || currentText.length < charSpans.length) {
                                            let joined = '';
                                            charSpans.forEach(n => { joined += n.textContent || ''; });
                                            if (joined && joined.trim()) {
                                                el.textContent = joined;
                                            }
                                        }
                                    }
                                } catch (_) { /* ignore per-element errors */ }
                            });
                            
                            // Freeze progress bars and indicators (keep current visual state)
                            const progressSelectors = [
                                'progress', '[role="progressbar"]', '[class*="progress"]', '[class*="indicator"]', '[class*="bar"]'
                            ];
                            queryFn(progressSelectors.join(',')).forEach(el => {
                                try {
                                    // Skip if already processed or in Designer
                                    if (el.hasAttribute('data-webflow-design') || 
                                        el.closest('[data-webflow-design-mode]')) {
                                        return;
                                    }
                                    
                                    // Mark as widget-managed
                                    el.setAttribute('data-accessbit-widget-managed', 'true');
                                    
                                    const cs = window.getComputedStyle(el);
                                    // Lock width/transform/transition to current (prefer CSS class, fallback to inline)
                                    el.style.transition = 'none';
                                    el.style.animation = 'none';
                                    if (cs.width && cs.width !== 'auto') el.style.width = cs.width;
                                    if (cs.transform && cs.transform !== 'none') el.style.transform = 'none';
                                    // For ARIA progressbar, keep the current value and stop changing
                                    if (el.getAttribute && el.getAttribute('role') === 'progressbar') {
                                        const now = el.getAttribute('aria-valuenow');
                                        if (now) el.setAttribute('aria-valuenow', now);
                                    }
                                } catch (_) { /* ignore per-element errors */ }
                            });
                            
                            // Preserve manual slider navigation controls: arrows and dots must remain functional
                            const sliderControlSelectors = [
                                '.swiper-button-next', '.swiper-button-prev', '.swiper-pagination-bullet', '.swiper-pagination-clickable',
                                '.slick-next', '.slick-prev', '.slick-dots li', '.slick-dots button',
                                '.glide__arrow', '.glide__bullet', '.splide__arrow', '.splide__pagination__page',
                                '.carousel-control-next', '.carousel-control-prev', '.carousel-indicators li', '.carousel-indicators button',
                                '[data-slide]', '[data-bs-slide]', '[data-glide-dir]'
                            ];
                            queryFn(sliderControlSelectors.join(',')).forEach(ctrl => {
                                try {
                                    ctrl.style.pointerEvents = 'auto';
                                    ctrl.style.cursor = 'pointer';
                                    // Ensure visibility and opacity aren't suppressed
                                    ctrl.style.visibility = '';
                                    ctrl.style.opacity = '';
                                } catch (_) {}
                            });
                            
                            // Pause autoplay for common slider libraries while keeping navigation enabled
                            try {
                                // Swiper
                                const swipers = queryFn('.swiper, .swiper-container');
                                swipers.forEach(el => {
                                    const inst = el.swiper || el.__swiper || (el._swiper || null);
                                    if (inst && inst.autoplay && typeof inst.autoplay.stop === 'function') {
                                        inst.autoplay.stop();
                                    }
                                });
                            } catch (_) {}
                            try {
                                // Slick (requires jQuery)
                                const jq = window.jQuery || window.$;
                                if (jq) {
                                    jq('.slick-slider').each(function() {
                                        try { jq(this).slick && jq(this).slick('slickPause'); } catch (e) {}
                                    });
                                }
                            } catch (_) {}
                            try {
                                // Splide
                                queryFn('.splide').forEach(el => {
                                    const inst = el.splide || el._splide || null;
                                    if (inst && typeof inst.options === 'object') {
                                        try { inst.options = Object.assign({}, inst.options, { autoplay: false }); } catch (e) {}
                                        if (inst.Components && inst.Components.Autoplay && typeof inst.Components.Autoplay.pause === 'function') {
                                            inst.Components.Autoplay.pause();
                                        }
                                    }
                                });
                            } catch (_) {}
                            try {
                                // Glide.js
                                document.querySelectorAll('.glide').forEach(el => {
                                    const inst = el._glide || null;
                                    if (inst && typeof inst.pause === 'function') {
                                        inst.pause();
                                    }
                                });
                            } catch (_) {}
                            
                            // Do NOT alter nav/header elements so sticky/navbars continue working normally
                            // This function intentionally skips any changes to nav/header; CSS exceptions added below
                        } catch (err) {
                            
                        }
                    };
                    
                    const seizureConsolidateSplitText = function() {
                        try {
                            // First pass: Handle standard split-text containers
                            const containers = document.querySelectorAll(
                                '[data-splitting], .split, [class*="split-text"], [class*="text-split"], ' +
                                '[class*="text-animation"], [class*="typing"], [class*="typewriter"], ' +
                                '[class*="reveal"], [class*="unveil"], [class*="show-text"], [class*="text-effect"]'
                            );
                            
                            containers.forEach(container => {
                                try {
                                    if (!container || container.hasAttribute('data-seizure-text-processed')) return;
                                    
                                    const charElements = container.querySelectorAll(
                                        '.char, [class*="char"], .letter, [class*="letter"], .word, [class*="word"]'
                                    );
                                    
                                    if (!charElements || charElements.length === 0) return;
                                    
                                    let fullText = '';
                                    charElements.forEach(char => {
                                        fullText += char.textContent || '';
                                    });
                                    
                                    if (fullText && fullText.trim()) {
                                        container.textContent = fullText.trim();
                                        container.setAttribute('data-seizure-text-processed', 'true');
                                        container.style.opacity = '1';
                                        container.style.visibility = 'visible';
                                        container.style.animation = 'none';
                                        container.style.transition = 'none';
                                        container.style.transform = 'none';
                                    }
                                } catch (_) { /* ignore per-container errors */ }
                            });
                            
                            // Second pass: Handle Webflow-style per-letter spans (plain <span> elements, not .char/.word)
                            // Look for elements with many child spans that likely contain per-letter text
                            const webflowContainers = document.querySelectorAll(
                                '[class*="fade-up"], [class*="fade-in"], [class*="multi-text"], h1, h2, h3, h4, h5, h6'
                            );
                            
                            webflowContainers.forEach(container => {
                                try {
                                    if (!container || container.hasAttribute('data-seizure-text-processed')) return;
                                    
                                    // Check if this element has many child spans (likely per-letter animation)
                                    const childSpans = container.querySelectorAll(':scope > span');
                                    if (childSpans.length < 5) return; // Not enough to be per-letter
                                    
                                    // Check if spans contain single characters or very short text
                                    let isPerLetter = true;
                                    let fullText = '';
                                    childSpans.forEach(span => {
                                        const text = (span.textContent || '').trim();
                                        fullText += text;
                                        // If any span has more than 2 characters, it's probably not per-letter
                                        if (text.length > 2) {
                                            isPerLetter = false;
                                        }
                                    });
                                    
                                    if (isPerLetter && fullText && fullText.trim()) {
                                        container.textContent = fullText.trim();
                                        container.setAttribute('data-seizure-text-processed', 'true');
                                        container.style.opacity = '1';
                                        container.style.visibility = 'visible';
                                        container.style.animation = 'none';
                                        container.style.transition = 'none';
                                        container.style.transform = 'none';
                                    }
                                } catch (_) { /* ignore per-container errors */ }
                            });
                            
                            // Third pass: Detect and hide duplicate text elements (like Webflow's h1 + animated h2)
                            // If we find multiple headings/blocks with similar text content, hide the animated ones
                            const textElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, [class*="heading"]');
                            const textMap = new Map();
                            
                            textElements.forEach(el => {
                                try {
                                    const text = (el.textContent || '').trim().toLowerCase().replace(/\s+/g, ' ');
                                    if (!text || text.length < 10) return; // Skip very short text
                                    
                                    if (!textMap.has(text)) {
                                        textMap.set(text, []);
                                    }
                                    textMap.get(text).push(el);
                                } catch (_) {}
                            });
                            
                            // For each duplicate text, keep the cleanest version and hide the animated ones
                            textMap.forEach((elements, text) => {
                                if (elements.length < 2) return; // No duplicates
                                
                                // Find the cleanest version (no per-letter spans, no animation classes)
                                let cleanest = null;
                                let cleanestScore = -1;
                                
                                elements.forEach(el => {
                                    const hasSpans = el.querySelectorAll(':scope > span').length > 0;
                                    const hasAnimClass = el.className.includes('fade') || 
                                                         el.className.includes('animate') ||
                                                         el.className.includes('multi-text');
                                    const score = (hasSpans ? 0 : 10) + (hasAnimClass ? 0 : 5);
                                    
                                    if (score > cleanestScore) {
                                        cleanestScore = score;
                                        cleanest = el;
                                    }
                                });
                                
                                // Hide all duplicates except the cleanest one
                                elements.forEach(el => {
                                    if (el !== cleanest && !el.hasAttribute('data-seizure-duplicate-hidden')) {
                                        el.style.display = 'none';
                                        el.style.visibility = 'hidden';
                                        el.style.opacity = '0';
                                        el.setAttribute('data-seizure-duplicate-hidden', 'true');
                                    }
                                });
                            });
                        } catch (_) { /* ignore top-level errors */ }
                    };
                    
                    seizureState.applySeizureSafeDOMFreeze = applySeizureSafeDOMFreeze;
                    seizureState.seizureConsolidateSplitText = seizureConsolidateSplitText;
                    seizureState.applyWAAPIStopMotion = applyWAAPIStopMotion;
                    
                    applySeizureSafeDOMFreeze();
                    
                    try {
                        if (!seizureState.animationBlockerInstalled) {
                            seizureState.animationBlockerInstalled = true;
                            const EXEMPT_SELECTOR = 'nav, header, .navbar, [role="navigation"], [data-allow-transform]';
                            // Do not neutralize transforms on icons/arrows; many sites rotate these via CSS
                            const ICON_SELECTOR = '.icon, [class*="icon"], [class*="arrow"], [class*="chevron"], [class*="caret"], svg, i, [data-icon]';
                            // Also respect common accordion/FAQ toggle contexts that rotate arrows
                            const ROTATION_CONTEXT_SELECTOR = '[aria-expanded], [data-accordion], .accordion, [data-toggle], [data-collapse]';
                            
                            const isExempt = (el) => {
                                try {
                                    if (el.matches && el.matches(ICON_SELECTOR)) return true;
                                    return !!el.closest(EXEMPT_SELECTOR);
                                } catch (_) { return false; }
                            };
                            
                            const neutralizeElement = (el) => {
                                if (!el || isExempt(el)) return;
                                try {
                                    el.style.animation = 'none';
                                    el.style.transition = 'none';
                                    el.style.willChange = 'auto';
                                    el.style.filter = 'none';
                                    // Only neutralize transform if the element is not an icon/arrow
                                    // and not inside a rotation context such as accordion/FAQ toggles
                                    const inRotationContext = (() => {
                                        try { return !!el.closest(ROTATION_CONTEXT_SELECTOR); } catch (_) { return false; }
                                    })();
                                    if (!(el.matches && el.matches(ICON_SELECTOR)) && !inRotationContext) {
                                        el.style.transform = 'none';
                                    }
                                    el.style.opacity = '1';
                                } catch (_) {}
                            };
                            
                            // Initial sweep - limit to first 5000 elements for safety
                            try {
                                const all = document.querySelectorAll('*');
                                let count = 0;
                                for (const el of all) {
                                    neutralizeElement(el);
                                    count++;
                                    if (count > 5000) break;
                                }
                            } catch (_) {}
                            
                            // Observe future changes to styles/classes and neutralize
                            try {
                                const styleObserver = new MutationObserver((mutations) => {
                                    if (!(document.body && document.body.classList.contains('seizure-safe'))) return;
                                    for (const m of mutations) {
                                        const target = m.target;
                                        if (!(target instanceof Element)) continue;
                                        if (isExempt(target)) continue;
                                        try {
                                            const inline = (target.getAttribute && target.getAttribute('style')) || '';
                                            if (/animation|transition|transform|opacity|filter/i.test(inline)) {
                                                neutralizeElement(target);
                                            }
                                            // Common animation class keywords
                                            const cls = target.className ? String(target.className) : '';
                                            if (/(animate|fade|slide|zoom|parallax|reveal|scroll|marquee)/i.test(cls)) {
                                                neutralizeElement(target);
                                            }
                                        } catch (_) {}
                                    }
                                });
                                styleObserver.observe(document.documentElement, {
                                    subtree: true, childList: true, attributes: true, attributeFilter: ['style', 'class']
                                });
                                seizureState.styleObserver = styleObserver;
                            } catch (_) {}
                            
                            // Ensure native scroll behavior on the main document only (avoid breaking custom scrollers)
                            try {
                                document.documentElement.style.scrollBehavior = 'auto';
                                document.body && (document.body.style.scrollBehavior = 'auto');
                                // Do not touch scrollSnapType on arbitrary containers to avoid locking scroll
                            } catch (_) {}
                        }
                    } catch (_) {}
                    
                    document.addEventListener('DOMContentLoaded', function() {
                        const isActive = document.body && (document.body.classList.contains('seizure-safe') || document.body.classList.contains('stop-animation'));
                        if (isActive) {
                            applySeizureSafeDOMFreeze();
                            // Disable scroll-trigger libraries when seizure-safe or stop-animation is active
                            try {
                                // AOS
                                if (window.AOS && typeof window.AOS.refreshHard === 'function') {
                                    try { window.AOS.refreshHard(); } catch (_) {}
                                    try { window.AOS.init && window.AOS.init({ disable: true }); } catch (_) {}
                                }
                            } catch (_) {}
                        }
                    }, { once: true });
                    
                    // Watch for seizure-safe class being toggled later and (re)install hard blockers
                    try {
                        if (!seizureState.classWatcher) {
                            const classWatcher = new MutationObserver(() => {
                                const active = document.body.classList.contains('seizure-safe') || document.body.classList.contains('stop-animation');
                                if (active) {
                                    try { applySeizureSafeDOMFreeze(); } catch (_) {}
                                    try { seizureState.installStyleSanitizer && seizureState.installStyleSanitizer(); } catch (_) {}
                                    try { applyUniversalStopMotion(true); } catch (_) {}
                                } else {
                                    try { applyUniversalStopMotion(false); } catch (_) {}
                                }
                            });
                            classWatcher.observe(document.body, { attributes: true, attributeFilter: ['class'] });
                            seizureState.classWatcher = classWatcher;
                            
                            seizureState.installStyleSanitizer = function() {
                                    try {
                                        const isActive = () => document.body && (document.body.classList.contains('seizure-safe') || document.body.classList.contains('stop-animation') || document.body.classList.contains('reduced-motion'));
                                        const sanitizeStyleString = (s) => String(s || '')
                                            .replace(/(?:^|;\s*)(animation-[^:]+|animation)\s*:[^;]*;?/gi, '')
                                            .replace(/(?:^|;\s*)(transition-[^:]+|transition)\s*:[^;]*;?/gi, '')
                                            .replace(/(?:^|;\s*)animation-play-state\s*:[^;]*;?/gi, '')
                                            .replace(/(?:^|;\s*)scroll-behavior\s*:[^;]*;?/gi, '')
                                            .replace(/(?:^|;\s*)filter\s*:[^;]*;?/gi, '')
                                            .replace(/(?:^|;\s*)opacity\s*:[^;]*;?/gi, '');

                                        if (!seizureState.styleSanitizerObserver) {
                                            const obs = new MutationObserver(mutations => {
                                                if (!isActive()) return;
                                                for (const m of mutations) {
                                                    try {
                                                        if (m.type === 'attributes' && m.attributeName === 'style' && m.target instanceof Element) {
                                                            const el = m.target;
                                                            const original = el.getAttribute('style') || '';
                                                            const cleaned = sanitizeStyleString(original);
                                                            if (cleaned !== original) try { el.setAttribute('style', cleaned); } catch (_) {}
                                                        }
                                                        if (m.type === 'childList' && m.addedNodes) {
                                                            m.addedNodes.forEach(node => {
                                                                if (!(node instanceof Element)) return;
                                                                try {
                                                                    const s = node.getAttribute('style') || '';
                                                                    const cleaned = sanitizeStyleString(s);
                                                                    if (cleaned !== s) try { node.setAttribute('style', cleaned); } catch (_) {}
                                                                } catch (_) {}
                                                                try {
                                                                    node.querySelectorAll && node.querySelectorAll('[style]').forEach(desc => {
                                                                        try {
                                                                            const ds = desc.getAttribute('style') || '';
                                                                            const dclean = sanitizeStyleString(ds);
                                                                            if (dclean !== ds) try { desc.setAttribute('style', dclean); } catch (_) {}
                                                                        } catch (_) {}
                                                                    });
                                                                } catch (_) {}
                                                            });
                                                        }
                                                    } catch (_) {}
                                                }
                                            });
                                            obs.observe(document.documentElement, { subtree: true, childList: true, attributes: true, attributeFilter: ['style'] });
                                            seizureState.styleSanitizerObserver = obs;
                                        }
                                    } catch (_) {}
                                };
                            seizureState.stopStyleSanitizer = function() {
                                    try { if (seizureState.styleSanitizerObserver) { try { seizureState.styleSanitizerObserver.disconnect(); } catch (_) {} seizureState.styleSanitizerObserver = null; } } catch (_) {}
                                };
                        }
                    } catch (_) {}
                    
                    seizureState.installStyleSanitizer && seizureState.installStyleSanitizer();
                    
                    try {
                        const observer = new MutationObserver(() => {
                            if (document.body && document.body.classList.contains('seizure-safe')) {
                                applySeizureSafeDOMFreeze();
                            }
                        });
                        observer.observe(document.documentElement, { childList: true, subtree: true, attributes: true });
                        seizureState.seizureObserver = observer;
                    } catch (obsErr) {
                      
                    }
                }
            } catch (guardErr) {
                
            }
        }
        
        // Install reduced-motion @media default and an in-product Seizure Safe toggle (non-designer only)
        try {
            if (!isDesignerModeStandalone()) {
                // Default to system preference using @media (prefers-reduced-motion: reduce)
                if (!document.getElementById('accessbit-reduced-motion-default')) {
                    const rm = document.createElement('style');
                    rm.id = 'accessbit-reduced-motion-default';
                    rm.textContent = `
@media (prefers-reduced-motion: reduce) {
  /* Reduce nonessential motion for users who request it at OS level */
  /* Per Webflow Security recommendations: use animation: none instead of duration reduction */
  :root, html, body, :root *:not(nav):not(header):not(.navbar):not([class*="nav"]) {
    animation: none !important;
    transition: none !important;
    scroll-behavior: auto !important;
  }
  /* Remove common flash triggers for prefers-reduced-motion users */
  *[class*="blink"], *[class*="shimmer"], *[class*="pulse"], 
  *[class*="caret"], *[class*="cursor-blink"], *[class*="skeleton"] {
    animation: none !important;
    visibility: visible !important;
    opacity: 1 !important;
  }
}`;
                    document.head.appendChild(rm);
                }

               

                // Create accessible floating toggle for strict Seizure Safe mode
                if (!document.getElementById('a11y-seizure-toggle')) {
                    const btn = document.createElement('button');
                    btn.id = 'a11y-seizure-toggle';
                    btn.setAttribute('role','switch');
                    btn.setAttribute('aria-checked', seizureSafeFromStorage === 'true' ? 'true' : 'false');
                    btn.setAttribute('aria-label','Toggle Seizure Safe mode (stop flashing/animated content)');
                    btn.title = 'Seizure Safe: stop flashing/animated content';
                    btn.style.position = 'fixed';
                    btn.style.left = '120px';
                    btn.style.bottom = '12px';
                    btn.style.zIndex = '2147483647';
                    btn.style.background = '#000';
                    btn.style.color = '#fff';
                    btn.style.border = '1px solid rgba(255,255,255,0.15)';
                    btn.style.padding = '8px 10px';
                    btn.style.borderRadius = '6px';
                    btn.style.fontSize = '12px';
                    btn.style.cursor = 'pointer';
                    btn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
                    btn.textContent = 'Seizure Safe';

                    const toggleHandler = function() {
                        const currently = document.body.classList.contains('seizure-safe');
                        const next = !currently;
                        if (next) {
                            localStorage.setItem('accessbit-widget-seizure-safe','true');
                            try { document.documentElement.classList.add('seizure-safe'); } catch (_) {}
                            try { document.body.classList.add('seizure-safe'); } catch (_) {}
                            try { seizureState.installStyleSanitizer && seizureState.installStyleSanitizer(); } catch (_) {}
                            try { seizureState.applyWAAPIStopMotion && seizureState.applyWAAPIStopMotion(true); } catch (_) {}
                            try { btn.setAttribute('aria-checked','true'); } catch (_) {}
                        } else {
                            try { seizureState.stopStyleSanitizer && seizureState.stopStyleSanitizer(); } catch (_) {}
                            try { seizureState.applyWAAPIStopMotion && seizureState.applyWAAPIStopMotion(false); } catch (_) {}
                            try { btn.setAttribute('aria-checked','false'); } catch (_) {}
                        }
                    };

                    btn.addEventListener('click', toggleHandler, true);
                    btn.addEventListener('keydown', function(e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleHandler(); } }, true);
                    // SECURITY: Protected by Designer mode check at line 20
                    try {
                        if (document.body) document.body.appendChild(btn);
                    } catch (_) {}
                }
            }
        } catch(_) {}

        // CRITICAL: Stop JavaScript animations immediately ONLY for seizure-safe mode
        if (seizureSafeFromStorage === 'true') {
            try {
                // SECURITY FIX: Removed global requestAnimationFrame override per Webflow Marketplace security requirements
                // Animation blocking is now handled via CSS classes only
                
                // WAAPI: pause/cancel running WAAPI animations when seizure-safe is active
                try { seizureState.applyWAAPIStopMotion && seizureState.applyWAAPIStopMotion(true); } catch (_) {}
                
                // Stop Lottie animations immediately
                if (typeof window.lottie !== 'undefined' && window.lottie.getRegisteredAnimations) {
                    const lottieAnimations = window.lottie.getRegisteredAnimations();
                    lottieAnimations.forEach(animation => {
                        try {
                            if (animation && typeof animation.stop === 'function') {
                                animation.stop();
                            }
                            if (animation && typeof animation.pause === 'function') {
                                animation.pause();
                            }
                        } catch (error) {
                            
                        }
                    });
                }
                
                // Stop jQuery animations immediately
                if (typeof window.jQuery !== 'undefined' || typeof window.$ !== 'undefined') {
                    try {
                        const $ = window.jQuery || window.$;
                        if ($ && $.fx) {
                            $.fx.off = true;
                        }
                    } catch (error) {
                       
                    }
                }
                
                
                
            } catch (jsError) {
               
            }
        }
        
    } catch (e) {
        
    }
})();

// Standalone helper function to check Designer mode (for use outside class)
function isDesignerModeStandalone() {
    try {
        return (
            (window.location.hostname.includes('webflow.com') && 
             (window.location.pathname.includes('/design/') || 
              window.location.pathname.includes('/designer'))) ||
            document.querySelector('[data-webflow-design-mode]') ||
            (typeof window.webflow !== 'undefined' && 
             typeof window.webflow.getSiteInfo === 'function' && 
             window.location.hostname.includes('webflow.com'))
        );
    } catch (e) {
        return false;
    }
}

// Standalone helper function to check Reader mode (for use outside class)
function isReaderModeStandalone() {
    try {
        return (
            document.documentElement.classList.contains('reader-mode') || 
            (document.body && document.body.classList.contains('reader-mode')) ||
            window.location.search.includes('reader-mode') ||
            document.querySelector('[data-reader-mode]') ||
            document.querySelector('.reader-mode') ||
            document.querySelector('#reader-mode') ||
            window.location.hash.includes('reader') ||
            document.title.toLowerCase().includes('reader') ||
            document.querySelector('meta[name="reader-mode"]') ||
            document.querySelector('meta[name="reading-mode"]') ||
            window.navigator.userAgent.includes('Reader') ||
            window.navigator.userAgent.includes('Readability') ||
            window.location.search.includes('read') ||
            window.location.search.includes('print') ||
            document.documentElement.getAttribute('data-reader-mode') ||
            (document.body && document.body.getAttribute('data-reader-mode'))
        );
    } catch (e) {
        return false;
    }
}
const seizureState = {
    savedAnimations: new Map(),
    waapiListenersInstalled: false,
    onAnimationStart: null,
    onTransitionRun: null,
    originalLottieLoadAnimation: null,
    lottieEventInterceptorActive: false,
    lottieAnimObserver: null,
    lottieDOMFreezeObserver: null,
    gsapMethodsOverridden: false,
    originalGsapTo: null,
    originalGsapFrom: null,
    originalGsapFromTo: null,
    originalGsapTimeline: null
};
// Universal Stop Motion helper: CSS + Lottie + GSAP + GIF/APNG handling

                    const applyWAAPIStopMotion = function(enabled) {
                        if (isDesignerModeStandalone()) return;
                        try {
                            if (enabled) {
                                const all = (document.getAnimations && document.getAnimations({ subtree: true })) || [];
                                all.forEach(anim => {
                                    try {
                                        if (!seizureState.savedAnimations.has(anim)) {
                                            seizureState.savedAnimations.set(anim, {
                                                playbackRate: anim.playbackRate || 1,
                                                playState: anim.playState || null,
                                                currentTime: anim.currentTime || 0
                                            });
                                        }
                                        // Finish animation to final state (not pause)
                                        if (typeof anim.finish === 'function') { 
                                            try { anim.finish(); } catch(_) {}
                                        } else if (anim.effect && anim.effect.getComputedTiming) {
                                            try {
                                                const timing = anim.effect.getComputedTiming();
                                                const end = timing.endTime != null ? timing.endTime : 
                                                           (timing.duration != null && timing.duration !== 'auto' ? timing.duration : null);
                                                if (end != null) {
                                                    anim.currentTime = end;
                                                }
                                            } catch(_) {}
                                        }
                                        // Pause after finishing to prevent restart
                                        if (typeof anim.pause === 'function') try { anim.pause(); } catch(_) {}
                                        try { anim.playbackRate = 0; } catch(_) {}
                                    } catch(_) {}
                                });

                                if (!seizureState.waapiListenersInstalled) {
                                    // Function to stop any animation
                                    const stopAnimation = function(anim) {
                                        try {
                                            if (!seizureState.savedAnimations.has(anim)) {
                                                seizureState.savedAnimations.set(anim, { 
                                                    playbackRate: anim.playbackRate || 1, 
                                                    playState: anim.playState || null, 
                                                    currentTime: anim.currentTime || 0 
                                                });
                                            }
                                            // Finish animation to final state (not pause)
                                            if (typeof anim.finish === 'function') { 
                                                try { anim.finish(); } catch(_) {}
                                            } else if (anim.effect && anim.effect.getComputedTiming) {
                                                try {
                                                    const timing = anim.effect.getComputedTiming();
                                                    const end = timing.endTime != null ? timing.endTime : 
                                                               (timing.duration != null && timing.duration !== 'auto' ? timing.duration : null);
                                                    if (end != null) {
                                                        anim.currentTime = end;
                                                    }
                                                } catch(_) {}
                                            }
                                            // Pause after finishing to prevent restart
                                            if (typeof anim.pause === 'function') { try { anim.pause(); } catch(_) {} }
                                            try { anim.playbackRate = 0; } catch(_) {}
                                        } catch(_) {}
                                    };
                                    
                                    // Function to stop all animations on an element
                                    const stopElementAnimations = function(target) {
                                        try {
                                            const anims = target.getAnimations ? target.getAnimations() : [];
                                            anims.forEach(stopAnimation);
                                        } catch(_) {}
                                    };
                                    
                                    // animationstart - catch new animations as they start
                                    seizureState.onAnimationStart = function(e) {
                                        stopElementAnimations(e.target);
                                    };
                                    document.addEventListener('animationstart', seizureState.onAnimationStart, true);
                                    
                                    // animationiteration - catch animations that continue
                                    seizureState.onAnimationIteration = function(e) {
                                        stopElementAnimations(e.target);
                                    };
                                    document.addEventListener('animationiteration', seizureState.onAnimationIteration, true);
                                    
                                    // transitionrun - catch transitions
                                    seizureState.onTransitionRun = function(e) {
                                        try {
                                            const t = e.target;
                                            if (t && t.style) {
                                                t.style.transition = 'none';
                                                t.style.animation = 'none';
                                            }
                                            stopElementAnimations(t);
                                        } catch(_) {}
                                    };
                                    document.addEventListener('transitionrun', seizureState.onTransitionRun, true);
                                    
                                    // transitionstart - catch transitions early
                                    seizureState.onTransitionStart = function(e) {
                                        try {
                                            const t = e.target;
                                            if (t && t.style) {
                                                t.style.transition = 'none';
                                                t.style.animation = 'none';
                                            }
                                            stopElementAnimations(t);
                                        } catch(_) {}
                                    };
                                    document.addEventListener('transitionstart', seizureState.onTransitionStart, true);
                                    
                                    // Continuous polling to catch animations that start without events
                                    // More frequent polling for better coverage
                                    if (!seizureState.waapiPollInterval) {
                                        seizureState.waapiPollInterval = setInterval(function() {
                                            try {
                                                // Stop all WAAPI animations
                                                const all = (document.getAnimations && document.getAnimations({ subtree: true })) || [];
                                                all.forEach(stopAnimation);
                                                
                                                // Also directly stop CSS animations on all elements
                                                const allElements = document.querySelectorAll('*');
                                                allElements.forEach(el => {
                                                    try {
                                                        // Skip widget elements
                                                        if (el.id && el.id.includes('accessbit')) return;
                                                        if (el.classList && (el.classList.contains('accessbit-widget') || el.closest('.accessbit-widget'))) return;
                                                        
                                                        const computedStyle = window.getComputedStyle(el);
                                                        if (computedStyle.animationName !== 'none' || computedStyle.transitionProperty !== 'none') {
                                                            el.style.setProperty('animation', 'none', 'important');
                                                            el.style.setProperty('transition', 'none', 'important');
                                                            el.style.setProperty('animation-play-state', 'paused', 'important');
                                                        }
                                                    } catch (_) {}
                                                });
                                            } catch(_) {}
                                        }, 30); // Check every 30ms for very aggressive stopping
                                    }
                                    
                                    // MutationObserver to catch dynamically added elements with animations
                                    if (!seizureState.waapiMutationObserver) {
                                        seizureState.waapiMutationObserver = new MutationObserver(function(mutations) {
                                            mutations.forEach(function(mutation) {
                                                mutation.addedNodes.forEach(function(node) {
                                                    if (node.nodeType === 1) { // Element node
                                                        try {
                                                            stopElementAnimations(node);
                                                            
                                                            // Also stop Lottie animations on new elements
                                                            if (node.tagName === 'LOTTIE-PLAYER' || node.classList.contains('lottie') || node.classList.contains('lottie-animation') || node.hasAttribute('data-lottie') || node.hasAttribute('data-animation')) {
                                                                try {
                                                                    if (node.stop) node.stop();
                                                                    if (node.pause) node.pause();
                                                                    if (node.setSpeed) node.setSpeed(0);
                                                                } catch(_) {}
                                                                try {
                                                                    if (node._lottie) {
                                                                        if (node._lottie.stop) node._lottie.stop();
                                                                        if (node._lottie.pause) node._lottie.pause();
                                                                        if (node._lottie.setSpeed) node._lottie.setSpeed(0);
                                                                    }
                                                                    if (node.lottie) {
                                                                        if (node.lottie.stop) node.lottie.stop();
                                                                        if (node.lottie.pause) node.lottie.pause();
                                                                        if (node.lottie.setSpeed) node.lottie.setSpeed(0);
                                                                    }
                                                                } catch(_) {}
                                                            }
                                                            
                                                            // Also stop GSAP animations on new elements
                                                            if (typeof window.gsap !== 'undefined' && window.gsap.killTweensOf) {
                                                                try {
                                                                    window.gsap.killTweensOf(node);
                                                                    // Also check children for GSAP animations
                                                                    const children = node.querySelectorAll ? node.querySelectorAll('*') : [];
                                                                    children.forEach(function(child) {
                                                                        try {
                                                                            window.gsap.killTweensOf(child);
                                                                        } catch(_) {}
                                                                    });
                                                                } catch(_) {}
                                                            }
                                                            
                                                            // Also check children
                                                            const children = node.querySelectorAll ? node.querySelectorAll('*') : [];
                                                            children.forEach(function(child) {
                                                                stopElementAnimations(child);
                                                                
                                                                // Stop Lottie on children
                                                                if (child.tagName === 'LOTTIE-PLAYER' || child.classList.contains('lottie') || child.classList.contains('lottie-animation') || child.hasAttribute('data-lottie') || child.hasAttribute('data-animation')) {
                                                                    try {
                                                                        if (child.stop) child.stop();
                                                                        if (child.pause) child.pause();
                                                                        if (child.setSpeed) child.setSpeed(0);
                                                                    } catch(_) {}
                                                                    try {
                                                                        if (child._lottie) {
                                                                            if (child._lottie.stop) child._lottie.stop();
                                                                            if (child._lottie.pause) child._lottie.pause();
                                                                            if (child._lottie.setSpeed) child._lottie.setSpeed(0);
                                                                        }
                                                                        if (child.lottie) {
                                                                            if (child.lottie.stop) child.lottie.stop();
                                                                            if (child.lottie.pause) child.lottie.pause();
                                                                            if (child.lottie.setSpeed) child.lottie.setSpeed(0);
                                                                        }
                                                                    } catch(_) {}
                                                                }
                                                                
                                                                // Stop GSAP on children
                                                                if (typeof window.gsap !== 'undefined' && window.gsap.killTweensOf) {
                                                                    try {
                                                                        window.gsap.killTweensOf(child);
                                                                    } catch(_) {}
                                                                }
                                                            });
                                                        } catch(_) {}
                                                    }
                                                });
                                            });
                                        });
                                        seizureState.waapiMutationObserver.observe(document.body, {
                                            childList: true,
                                            subtree: true
                                        });
                                    }
                                    
                                    seizureState.waapiListenersInstalled = true;
                                }
                            } else {
                                if (seizureState.savedAnimations) {
                                    for (const [a, meta] of seizureState.savedAnimations.entries()) {
                                        try {
                                            if (typeof a.play === 'function') {
                                                try { a.playbackRate = (meta.playbackRate != null ? meta.playbackRate : 1); } catch(_) {}
                                                if (meta.playState === 'running') try { a.play(); } catch(_) {}
                                            }
                                        } catch(_) {}
                                    }
                                    seizureState.savedAnimations.clear();
                                }
                                if (seizureState.waapiListenersInstalled) {
                                    try { document.removeEventListener('animationstart', seizureState.onAnimationStart, true); } catch(_) {}
                                    try { document.removeEventListener('animationiteration', seizureState.onAnimationIteration, true); } catch(_) {}
                                    try { document.removeEventListener('transitionrun', seizureState.onTransitionRun, true); } catch(_) {}
                                    try { document.removeEventListener('transitionstart', seizureState.onTransitionStart, true); } catch(_) {}
                                    seizureState.onAnimationStart = null;
                                    seizureState.onAnimationIteration = null;
                                    seizureState.onTransitionRun = null;
                                    seizureState.onTransitionStart = null;
                                    
                                    // Clear polling interval
                                    if (seizureState.waapiPollInterval) {
                                        clearInterval(seizureState.waapiPollInterval);
                                        seizureState.waapiPollInterval = null;
                                    }
                                    
                                    // Disconnect MutationObserver
                                    if (seizureState.waapiMutationObserver) {
                                        seizureState.waapiMutationObserver.disconnect();
                                        seizureState.waapiMutationObserver = null;
                                    }
                                    
                                    seizureState.waapiListenersInstalled = false;
                                }
                            }
                        } catch(_) {}
                    };
                    
                    seizureState.applyWAAPIStopMotion = applyWAAPIStopMotion;

function applyUniversalStopMotion(enabled) {
    // CRITICAL: Don't manipulate Designer DOM
    if (isDesignerModeStandalone()) {
        return;
    }
    
    try {
        // CSS injection to force-stop CSS animations/transitions and smooth scroll
        let css = document.getElementById('a11y-universal-motion-block');
        if (enabled) {
            if (!css) {
                css = document.createElement('style');
                css.id = 'a11y-universal-motion-block';
                document.head.appendChild(css);
            }
            css.textContent = `
                /* Exclude nav/header to preserve sticky positioning and layout */
                html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), 
                html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, 
                html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after,
                body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), 
                body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, 
                body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after,
                html.stop-animation *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), 
                html.stop-animation *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, 
                html.stop-animation *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after,
                body.stop-animation *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]), 
                body.stop-animation *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::before, 
                body.stop-animation *:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"])::after {
                    /* Force animations to final state immediately - either prevent from starting or jump to final state */
                    animation-duration: 0s !important;
                    animation-delay: 0s !important;
                    animation-fill-mode: forwards !important;
                    animation-iteration-count: 1 !important;
                    animation-play-state: paused !important;
                    transition-duration: 0s !important;
                    transition-delay: 0s !important;
                    /* REMOVED: scroll-behavior: auto !important; - This was blocking website scroll animations */
                }
            `;
        } else if (css) {
            css.remove();
        }

        // WAAPI: pause/cancel running WAAPI animations where possible
        try { applyWAAPIStopMotion && applyWAAPIStopMotion(enabled); } catch (_) {}

        // Lottie: stop all registered animations
        try {
            if (enabled && typeof window.lottie !== 'undefined' && window.lottie.getRegisteredAnimations) {
                const all = window.lottie.getRegisteredAnimations();
                all && all.forEach(anim => { try { anim.stop && anim.stop(); } catch (_) {} });
                try { window.lottie.freeze && window.lottie.freeze(); } catch (_) {}
            }
        } catch (_) {}


        // GIF/APNG replacement (one-frame transparent pixel by default) - Designer-safe
        const STATIC_FALLBACK = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';
        // Check Designer mode first
        // Use standalone Designer mode check
        if (!isDesignerModeStandalone()) {
            if (enabled) {
                // Use scoped query if widget instance is available
                const widget = window.AccessibilityWidgetInstance;
                const queryFn = widget && typeof widget.scopedQuerySelectorAll === 'function' 
                    ? (sel) => widget.scopedQuerySelectorAll(sel)
                    : (sel) => {
                        const all = document.querySelectorAll(sel);
                        return Array.from(all).filter(el => 
                            !el.closest('[data-webflow-design-mode]') && 
                            !el.closest('[data-wf-design]')
                        );
                    };
                
                queryFn('img[src$=".gif"], img[src$=".apng"]').forEach(img => {
                    try {
                        // Skip Designer elements
                        if (img.closest('[data-webflow-design-mode]') || img.hasAttribute('data-wf-design')) {
                            return;
                        }
                        if (!img.dataset.originalSrc) img.dataset.originalSrc = img.src;
                        img.src = STATIC_FALLBACK;
                    } catch (_) {}
                });
            } else {
                document.querySelectorAll('img[data-original-src]').forEach(img => {
                    try { 
                        // Skip Designer elements
                        if (img.closest('[data-webflow-design-mode]') || img.hasAttribute('data-wf-design')) {
                            return;
                        }
                        img.src = img.dataset.originalSrc; 
                        delete img.dataset.originalSrc; 
                    } catch (_) {}
                });
            }
        }

        // Observe for future Lottie/GIF inserts while active
        if (enabled) {
            if (!seizureState.universalMotionObserver) {
                const obs = new MutationObserver(mutations => {
                    const active = document.body.classList.contains('seizure-safe') || document.body.classList.contains('stop-animation');
                    if (!active) return;
                    try {
                        if (typeof window.lottie !== 'undefined' && window.lottie.getRegisteredAnimations) {
                            const all = window.lottie.getRegisteredAnimations();
                            all && all.forEach(anim => { try { anim.stop && anim.stop(); } catch (_) {} });
                        }
                    } catch (_) {}
                    try {
                        mutations.forEach(m => m.addedNodes && m.addedNodes.forEach(node => {
                            if (node && node.tagName === 'IMG') {
                                if (!node.dataset.originalSrc) node.dataset.originalSrc = node.src;
                                node.src = STATIC_FALLBACK;
                            }
                        }));
                    } catch (_) {}
                });
                obs.observe(document.documentElement, { subtree: true, childList: true });
                seizureState.universalMotionObserver = obs;
            }
        } else if (seizureState.universalMotionObserver) {
            try { seizureState.universalMotionObserver.disconnect(); } catch (_) {}
            seizureState.universalMotionObserver = null;
        }
    } catch (_) {}
}

// Vision Impaired helper: apply simple zoom and brightness
function applyVisionImpaired(on) {
    // CRITICAL: Don't manipulate Designer DOM
    if (isDesignerModeStandalone()) {
        return;
    }
    
    try {
        // Toggle root classes
        document.documentElement.classList.toggle('vision-impaired', !!on);
        document.body.classList.toggle('vision-impaired', !!on);

        // Remove content wrapper if it exists (cleanup from old implementation)
        const wrapper = document.getElementById('accessbit-content-wrapper');
        if (wrapper && !on) {
            // Move all wrapper children back to body
            while (wrapper.firstChild) {
                document.body.insertBefore(wrapper.firstChild, wrapper);
            }
            wrapper.remove();
        }
        
        let style = document.getElementById('accessbit-vision-impaired-immediate-early');
        if (!style && on) {
            style = document.createElement('style');
            style.id = 'accessbit-vision-impaired-immediate-early';
            document.head.appendChild(style);
        } else if (!on && style) {
            style.remove();
            return;
        }
        
        if (!on) return;
        
        style.textContent = `
            /* VISION IMPAIRED: Brightness only, no layout changes */
            
            html.vision-impaired {
                /* Prevent horizontal scrollbar without affecting page height */
                overflow-x: hidden !important;
            }
            
            body.vision-impaired {
                /* Slightly brighten the page for low-vision users */
                filter: brightness(1.06) !important;
                /* Don't set overflow-x on body to avoid layout recalculation that might increase page height */
            }
            
            /* CRITICAL: Exclude navigation elements from filter to preserve sticky/fixed positioning */
            body.vision-impaired nav,
            body.vision-impaired header,
            body.vision-impaired .navbar,
            body.vision-impaired [role="navigation"],
            body.vision-impaired [class*="nav"],
            body.vision-impaired [class*="header"],
            body.vision-impaired [class*="navbar"],
            body.vision-impaired [data-sticky],
            body.vision-impaired [data-fixed],
            body.vision-impaired [style*="position: sticky"],
            body.vision-impaired [style*="position:fixed"],
            body.vision-impaired [style*="position: fixed"] {
                filter: none !important;
                -webkit-filter: none !important;
            }
            
            /* Exclude widget from brightness adjustments */
            body.vision-impaired .accessbit-widget,
            body.vision-impaired #accessbit-widget,
            body.vision-impaired .accessbit-widget-panel,
            .accessbit-widget-panel {
                filter: none !important;
                z-index: 2147483646 !important;
            }
            
            body.vision-impaired .accessbit-widget-icon,
            body.vision-impaired #accessbit-widget-icon,
            .accessbit-widget-icon,
            #accessbit-widget-icon {
                filter: none !important;
                z-index: 2147483645 !important;
            }
            
            body.vision-impaired .accessbit-widget,
            body.vision-impaired #accessbit-widget,
            .accessbit-widget,
            #accessbit-widget {
                filter: none !important;
                z-index: 2147483647 !important;
            }
            
            /* NOTE: Vision Impaired no longer applies a transform-based zoom to avoid extra scrollbars.
               Zoom and sizing are handled by dedicated font/spacing controls instead. */
        `;
    } catch (_) {}
}

// Ensure the reduce-motion toggle actually applies classes and storage immediately
(function() {
    try {
        function bindReduceMotionToggle() {
            const input = document.getElementById('reduce-motion');
            if (!input) return;
            const enabled = localStorage.getItem('accessbit-widget-reduce-motion') === 'true';
            try { input.checked = enabled; } catch (_) {}
            if (!input.__reduceMotionBound) {
                input.addEventListener('change', function() {
                    const on = !!this.checked;
                    localStorage.setItem('accessbit-widget-reduce-motion', on ? 'true' : 'false');
                    try { document.documentElement.classList.toggle('reduce-motion', on); } catch (_) {}
                    try { document.body.classList.toggle('reduce-motion', on); } catch (_) {}
                    // Apply CSS and WAAPI controls
                    if (on) {
                        const style = document.getElementById('reduce-motion-css') || (() => {
                            const s = document.createElement('style');
                            s.id = 'reduce-motion-css';
                            document.head.appendChild(s);
                            return s;
                        })();
                        if (style && !style.textContent) {
                            style.textContent = `
                                html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]),
                                html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::before,
                                html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::after,
                                body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]),
                                body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::before,
                                body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::after {
                                    animation: none !important;
                                    transition: none !important;
                                    scroll-behavior: auto !important;
                                }
                                body.reduce-motion *[class*="blink"], body.reduce-motion *[class*="shimmer"], 
                                body.reduce-motion *[class*="pulse"], body.reduce-motion *[class*="caret"], 
                                body.reduce-motion *[class*="cursor-blink"], body.reduce-motion *[class*="skeleton"],
                                body.reduce-motion *[class*="pulsing"], body.reduce-motion *[class*="flashing"],
                                html.reduce-motion *[class*="blink"], html.reduce-motion *[class*="shimmer"], 
                                html.reduce-motion *[class*="pulse"], html.reduce-motion *[class*="caret"], 
                                html.reduce-motion *[class*="cursor-blink"], html.reduce-motion *[class*="skeleton"],
                                html.reduce-motion *[class*="pulsing"], html.reduce-motion *[class*="flashing"] {
                                    animation: none !important;
                                    visibility: visible !important;
                                    opacity: 1 !important;
                                }
                                body.reduce-motion input[type="text"], body.reduce-motion input[type="email"], 
                                body.reduce-motion input[type="search"], body.reduce-motion input[type="tel"], 
                                body.reduce-motion input[type="url"], body.reduce-motion input[type="password"], 
                                body.reduce-motion textarea, body.reduce-motion [contenteditable="true"],
                                html.reduce-motion input[type="text"], html.reduce-motion input[type="email"], 
                                html.reduce-motion input[type="search"], html.reduce-motion input[type="tel"], 
                                html.reduce-motion input[type="url"], html.reduce-motion input[type="password"], 
                                html.reduce-motion textarea, html.reduce-motion [contenteditable="true"] {
                                    caret-color: transparent !important;
                                }
                            `;
                        }
                        // Use WAAPI to pause animations
                        try {
                            const all = (document.getAnimations && document.getAnimations({ subtree: true })) || [];
                            all.forEach(anim => {
                                try {
                                    if (typeof anim.pause === 'function') anim.pause();
                                    if (typeof anim.playbackRate !== 'undefined') anim.playbackRate = 0;
                                } catch (_) {}
                            });
                        } catch (_) {}
                    } else {
                        // Remove CSS
                        const style = document.getElementById('reduce-motion-css');
                        if (style) style.remove();
                        // Restore WAAPI animations
                        try {
                            const all = (document.getAnimations && document.getAnimations({ subtree: true })) || [];
                            all.forEach(anim => {
                                try {
                                    if (typeof anim.playbackRate !== 'undefined') anim.playbackRate = 1;
                                    if (typeof anim.play === 'function' && anim.playState === 'paused') anim.play();
                                } catch (_) {}
                            });
                        } catch (_) {}
                    }
                });
                input.__reduceMotionBound = true;
            }
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bindReduceMotionToggle, { once: true });
        } else {
            bindReduceMotionToggle();
        }
        // Also check periodically in case widget loads later
        setInterval(bindReduceMotionToggle, 1000);
    } catch (e) {
       
    }
})();

// Ensure the seizure-safe toggle actually applies classes and storage immediately
(function() {
    try {
        function bindSeizureSafeToggle() {
            const input = document.getElementById('seizure-safe');
            if (!input) return;
            const enabled = localStorage.getItem('accessbit-widget-seizure-safe') === 'true';
            try { input.checked = enabled; } catch (_) {}
            if (!input.__seizureBound) {
                input.addEventListener('change', function() {
                    const on = !!this.checked;
                    localStorage.setItem('accessbit-widget-seizure-safe', on ? 'true' : 'false');
                    try { document.documentElement.classList.toggle('seizure-safe', on); } catch (_) {}
                    try { document.body.classList.toggle('seizure-safe', on); } catch (_) {}
                    if (on) {
                        try { applySeizureSafeDOMFreeze && applySeizureSafeDOMFreeze(); } catch (_) {}
                        try { seizureConsolidateSplitText && seizureConsolidateSplitText(); } catch (_) {}
                    }
                });
                input.__seizureBound = true;
            }
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bindSeizureSafeToggle, { once: true });
        } else {
            bindSeizureSafeToggle();
        }
    } catch (e) {
       
    }
})();

// CRITICAL: Immediate Vision Impaired profile - apply on first paint if previously enabled
(function() {
    try {
        const visionImpairedFromStorage = localStorage.getItem('accessbit-widget-vision-impaired');
        if (visionImpairedFromStorage === 'true') {
            try { document.documentElement.classList.add('vision-impaired'); } catch (_) {}
            try { document.body.classList.add('vision-impaired'); } catch (_) {}
            try { document.documentElement.setAttribute('data-vision-impaired', 'true'); } catch (_) {}

            // Apply comprehensive vision impaired styles immediately
            if (!document.getElementById('accessbit-vision-impaired-immediate-early')) {
                const viStyle = document.createElement('style');
                viStyle.id = 'accessbit-vision-impaired-immediate-early';
                viStyle.textContent = `
                    /* VISION IMPAIRED: Brightness only, no layout changes */
                    
                    html.vision-impaired {
                        /* Prevent horizontal scrollbar without affecting page height */
                        overflow-x: hidden !important;
                    }
                    
                    body.vision-impaired {
                        /* Slight brightness bump only, no extra contrast or font changes */
                        filter: brightness(1.06) !important;
                        /* Don't set overflow-x on body to avoid layout recalculation that might increase page height */
                    }
                    
                    /* CRITICAL: Exclude navigation elements from filter to preserve sticky/fixed positioning */
                    body.vision-impaired nav,
                    body.vision-impaired header,
                    body.vision-impaired .navbar,
                    body.vision-impaired [role="navigation"],
                    body.vision-impaired [class*="nav"],
                    body.vision-impaired [class*="header"],
                    body.vision-impaired [class*="navbar"],
                    body.vision-impaired [data-sticky],
                    body.vision-impaired [data-fixed],
                    body.vision-impaired [style*="position: sticky"],
                    body.vision-impaired [style*="position:fixed"],
                    body.vision-impaired [style*="position: fixed"] {
                        filter: none !important;
                        -webkit-filter: none !important;
                    }
                `;
                document.head.appendChild(viStyle);
            }
        }

        // Wire checkbox if present and sync initial checked state
        function syncVisionImpairedToggle() {
            try {
                const input = document.getElementById('vision-impaired');
                if (!input) return;
                const enabled = localStorage.getItem('accessbit-widget-vision-impaired') === 'true';
                try { input.checked = enabled; } catch (_) {}
                if (!input.__viBound) {
                    input.addEventListener('change', function() {
                        const on = !!this.checked;
                        localStorage.setItem('accessbit-widget-vision-impaired', on ? 'true' : 'false');
                        try { document.documentElement.classList.toggle('vision-impaired', on); } catch (_) {}
                        try { document.body.classList.toggle('vision-impaired', on); } catch (_) {}
                        try {
                            if (on) {
                                document.documentElement.setAttribute('data-vision-impaired', 'true');
                            } else {
                                document.documentElement.removeAttribute('data-vision-impaired');
                            }
                        } catch (_) {}
                    });
                    input.__viBound = true;
                }
            } catch (_) { /* ignore */ }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', syncVisionImpairedToggle, { once: true });
        } else {
            syncVisionImpairedToggle();
        }
    } catch (e) {
        
    }
})();

class AccessibilityWidget {
    constructor() {
    
            // Prevent multiple initializations
            if (this._isInitializing || this._isInitialized) {
                return;
            }
            this._isInitializing = true;
    
            this.settings = {};
    
            this.contentScale = 100; // Start at 100% (normal size)
    
            this.fontSize = 100;
    
            this.lineHeight = 100;
    
            this.letterSpacing = 100;
    
            this.textMagnifierHandlers = new Map(); // Store event handler references
    
            this.originalLineHeight = null; // Legacy single baseline (no longer primary)
            this.originalLineHeights = new Map(); // Store original line-height per element
    
            this.originalFontSizes = new Map(); // Store original font sizes to prevent compounding
    
            this.currentlyFocusedElement = null; // Track currently focused element for highlight focus
            this.isKeyboardNavigation = false; // Track if user is using keyboard navigation
            this.lastInteractionMethod = null; // Track last interaction method (keyboard/mouse)
            
            // Performance optimization: Cache DOM elements
            this._cachedElements = {
                icon: null,
                panel: null,
                closeBtn: null,
                lastCacheTime: 0
            };
            
            // Cache for API calls to prevent duplicate requests
            this._fetchCache = {
                customizationData: null,
                lastFetchTime: 0,
                cacheDuration: 5 * 60 * 1000 // 5 minutes
            };
            
            // Track if this is a staging domain (free, no payment check needed)
            this._isStagingDomain = null; // Will be set on first check
            
            // Track if icon was explicitly shown during initialization
            // This prevents ResizeObserver and other events from hiding it
            this._iconExplicitlyShown = false;
            
            // Debounce/throttle timers
            this._resizeTimer = null;
            this._mutationTimer = null;
            this._rafPending = false;
    
            this.currentLanguage = this.getCurrentLanguage(); // Initialize current language
    
            this.translations = this.getTranslations(); // Initialize translations
    
            this.isOpeningDropdown = false; // Flag to prevent immediate close
    
            // Set the KV API URL for your worker
            this.kvApiUrl = 'https://accessbit-test-worker.web-8fb.workers.dev';
            

            // CRITICAL: Check for seizure-safe mode immediately and apply it before any animations start
            this.checkAndApplyImmediateSeizureSafe();
            
            // Set up aggressive monitoring for any text animations that might start
            this.setupSeizureSafeMonitoring();
            
            // CRITICAL: Force all animations to final state immediately if seizure-safe or stop-animation is enabled
            this.forceAllAnimationsToFinalState();
    
            // Initialize payment validation before anything else
            this.initializePaymentValidation().then(() => {
                // Only initialize if payment validation passes
                if (!this.paymentFailed) {
                   
                    this.init();
                } else {
                    
                }
            }).catch((error) => {
                // Payment validation failed, widget is already disabled
                
            });

        }
        
        // ===== SECURITY & ISOLATION HELPERS =====
        
        /**
         * Check if we're in Webflow Designer mode
         * @returns {boolean} True if in Designer, false otherwise
         */
        isDesignerMode() {
            try {
                return (
                    (window.location.hostname.includes('webflow.com') && 
                     (window.location.pathname.includes('/design/') || 
                      window.location.pathname.includes('/designer'))) ||
                    document.querySelector('[data-webflow-design-mode]') ||
                    (typeof window.webflow !== 'undefined' && 
                     typeof window.webflow.getSiteInfo === 'function' && 
                     window.location.hostname.includes('webflow.com'))
                );
            } catch (e) {
                return false;
            }
        }
        
        /**
         * Safely perform DOM operations with Designer check
         * @param {Function} operation - Function that performs DOM manipulation
         * @param {string} operationName - Name of operation for error logging
         * @returns {boolean} True if operation was performed, false if blocked
         */
        safeDOMOperation(operation, operationName = 'DOM operation') {
            try {
                if (this.isDesignerMode()) {
                    return false;
                }
                operation();
                return true;
            } catch (e) {
                return false;
            }
        }
        
        /**
         * Scoped querySelectorAll that excludes Designer elements and widget's own elements
         * @param {string} selector - CSS selector
         * @param {Element} root - Root element to search from (default: document)
         * @returns {NodeList} Filtered list of elements
         */
        scopedQuerySelectorAll(selector, root = document) {
            try {
                if (this.isDesignerMode()) {
                    return []; // Return empty in Designer mode
                }
                
                const all = root.querySelectorAll(selector);
                const filtered = Array.from(all).filter(el => {
                    // Exclude Designer elements
                    if (el.closest('[data-webflow-design-mode]') || 
                        el.closest('[data-wf-design]') ||
                        el.hasAttribute('data-wf-design')) {
                        return false;
                    }
                    // Exclude widget's own elements (they're managed separately)
                    if (el.closest('#accessbit-widget-container') ||
                        el.closest('accessbit-widget') ||
                        el.id === 'accessbit-widget-container') {
                        return false;
                    }
                    return true;
                });
                return filtered;
            } catch (e) {
                return [];
            }
        }
        
        /**
         * Scoped querySelector that excludes Designer elements
         * @param {string} selector - CSS selector
         * @param {Element} root - Root element to search from (default: document)
         * @returns {Element|null} First matching element or null
         */
        scopedQuerySelector(selector, root = document) {
            try {
                if (this.isDesignerMode()) {
                    return null;
                }
                const all = root.querySelectorAll(selector);
                for (const el of all) {
                    // Exclude Designer elements
                    if (el.closest('[data-webflow-design-mode]') || 
                        el.closest('[data-wf-design]') ||
                        el.hasAttribute('data-wf-design')) {
                        continue;
                    }
                    // Exclude widget's own elements
                    if (el.closest('#accessbit-widget-container') ||
                        el.closest('accessbit-widget') ||
                        el.id === 'accessbit-widget-container') {
                        continue;
                    }
                    return el;
                }
                return null;
            } catch (e) {
                return null;
            }
        }
        
        /**
         * Custom HTML sanitization function (no third-party dependencies)
         * Escapes HTML entities and allows only safe HTML tags/attributes
         * @param {string} html - HTML string to sanitize
         * @param {boolean} allowHTML - If false, only escape (default: true for safe tags)
         * @returns {string} Sanitized HTML string
         */
        sanitizeHTML(html, allowHTML = true) {
            if (!html || typeof html !== 'string') {
                return '';
            }
            
            // If not allowing HTML, just escape everything
            if (!allowHTML) {
                return html
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;')
                    .replace(/\//g, '&#x2F;');
            }
            
            // Allowed safe HTML tags (widget UI only)
            const allowedTags = ['div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 
                                'button', 'input', 'select', 'option', 'label', 'i', 'strong', 
                                'em', 'br', 'ul', 'ol', 'li', 'a'];
            const allowedAttributes = ['class', 'id', 'style', 'type', 'value', 'name', 
                                     'for', 'href', 'tabindex', 'role', 'aria-label', 
                                     'aria-expanded', 'data-color', 'data-value'];
            

            const parser = new DOMParser();
            const doc = parser.parseFromString(String(html || ''), 'text/html');
            const temp = doc.body;
            
            // Recursively sanitize all nodes
            const sanitizeNode = (node) => {
                if (node.nodeType === Node.TEXT_NODE) {
                    // Escape text content
                    return node.textContent
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }
                
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    
                    // Remove disallowed tags
                    if (!allowedTags.includes(tagName)) {
                        return node.textContent || '';
                    }
                    
                    // Sanitize attributes
                    const attrs = Array.from(node.attributes);
                    attrs.forEach(attr => {
                        if (!allowedAttributes.includes(attr.name.toLowerCase())) {
                            node.removeAttribute(attr.name);
                        } else if (attr.name.toLowerCase() === 'href' || attr.name.toLowerCase() === 'src') {
                            // Validate URLs - only allow http, https, or data URIs
                            const url = attr.value;
                            if (!/^(https?:\/\/|data:|#|\/)/i.test(url) && !url.startsWith('javascript:')) {
                                node.removeAttribute(attr.name);
                            }
                        } else if (attr.name.toLowerCase() === 'style') {
                            // Basic style sanitization - remove dangerous properties
                            const style = attr.value.replace(/javascript:/gi, '')
                                                    .replace(/expression\(/gi, '')
                                                    .replace(/on\w+\s*=/gi, '');
                            node.setAttribute('style', style);
                        }
                    });
                    
                    // Recursively sanitize children
                    const children = Array.from(node.childNodes);
                    children.forEach(child => {
                        const sanitized = sanitizeNode(child);
                        if (typeof sanitized === 'string') {
                            const textNode = document.createTextNode(sanitized);
                            node.replaceChild(textNode, child);
                        }
                    });
                }
                
                return node;
            };
            
            // Sanitize all nodes in temp container
            const children = Array.from(temp.childNodes);
            children.forEach(child => sanitizeNode(child));
            
            
            // Serialize child nodes to string safely.
            try {
                const serializer = new XMLSerializer();
                return Array.from(doc.body.childNodes).map(n => serializer.serializeToString(n)).join('');
            } catch (_) {
                return (doc.body.textContent || '');
            }
        }
        
        /**
         * Escape HTML entities in user content (for text-only content)
         * @param {string} text - Text to escape
         * @returns {string} Escaped text
         */
        escapeHTML(text) {
            if (!text || typeof text !== 'string') {
                return '';
            }
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;')
                .replace(/\//g, '&#x2F;');
        }
        
        /**
         * Validate and sanitize CSS class name
         * @param {string} className - Class name to validate
         * @returns {string} Sanitized class name or empty string
         */
        validateClassName(className) {
            if (!className || typeof className !== 'string') {
                return '';
            }
            // Only allow alphanumeric, dash, underscore, and spaces
            return className.replace(/[^a-zA-Z0-9\s\-_]/g, '').trim();
        }
        
        /**
         * Inject CSS style into document head (reusable helper)
         * @param {string} id - Unique ID for the style element
         * @param {string} css - CSS content to inject
         * @param {string} target - Target element ('head' or 'body', default: 'head')
         * @returns {Element|null} Created style element or null if failed/Designer mode
         */
        injectStyle(id, css, target = 'head') {
            // CRITICAL: Don't manipulate Designer DOM
            if (this.isDesignerMode()) {
                return null;
            }
            
            if (!id || !css) {
                return null;
            }
            
            // Check if style already exists
            const existing = document.getElementById(id);
            if (existing) {
                return existing;
            }
            
            try {
                const style = document.createElement('style');
                style.id = id;
                style.textContent = css;
                
                const targetElement = target === 'body' ? document.body : document.head;
                
                if (this.safeDOMOperation(() => {
                    targetElement.appendChild(style);
                }, `inject style ${id}`)) {
                    return style;
                }
                
                return null;
            } catch (e) {
                return null;
            }
        }
        
        /**
         * Remove injected style by ID
         * @param {string} id - ID of the style element to remove
         */
        removeStyle(id) {
            if (!id) return;
            
            try {
                const style = document.getElementById(id);
                if (style) {
                    style.remove();
                }
            } catch (e) {
                // Ignore errors
            }
        }
        
        /**
         * Safely add/remove classes to body/documentElement with Designer check
         * Prefer this over direct classList manipulation
         * @param {string} className - Class name to add/remove
         * @param {boolean} add - True to add, false to remove
         * @param {boolean} useDocumentElement - Use documentElement instead of body
         * @returns {boolean} True if operation succeeded
         */
        safeBodyClassToggle(className, add = true, useDocumentElement = false) {
            try {
                if (this.isDesignerMode()) {
                    return false;
                }
                const target = useDocumentElement ? document.documentElement : document.body;
                if (add) {
                    target.classList.add(className);
                } else {
                    target.classList.remove(className);
                }
                return true;
            } catch (e) {
                return false;
            }
        }
        
        /**
         * Apply styles via CSS class instead of inline styles (Designer-compliant)
         * @param {Element} element - Element to style
         * @param {string} className - CSS class name to add
         * @param {Object} styles - Optional inline styles (fallback if class not available)
         * @returns {boolean} True if applied
         */
        applyStyleViaClass(element, className, styles = null) {
            try {
                if (this.isDesignerMode() || !element) {
                    return false;
                }
                
                // Mark as widget-manipulated for tracking
                element.setAttribute('data-accessbit-widget-managed', 'true');
                
                // Add CSS class (preferred method)
                element.classList.add(className);
                
                // Fallback to inline styles only if class doesn't work
                if (styles && typeof styles === 'object') {
                    // Check if class was actually applied by testing computed style
                    // If not, use inline styles as fallback
                    Object.assign(element.style, styles);
                }
                
                return true;
            } catch (e) {
                return false;
            }
        }
        
        /**

         * @param {Element} container - Target element
         * @param {string} html - HTML content
         * @param {boolean} allowHTML - Whether to allow HTML (false means escape)
         */
        
        /**
         * Create a scoped overlay container that won't interfere with Designer
         * @param {string} id - Unique ID for the overlay
         * @param {string} html - HTML content
         * @returns {Element|null} Created overlay element or null
         */
        createScopedOverlay(id, html) {
            try {
                if (this.isDesignerMode()) {
                    return null;
                }
                
                // Check if overlay already exists
                const existing = document.getElementById(id);
                if (existing) {
                    return existing;
                }
                
                // Create container with widget scope
                const container = document.createElement('div');
                container.id = id;
                container.setAttribute('data-accessbit-widget-overlay', 'true');

                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    // Clear container
                    while (container.firstChild) {
                        container.removeChild(container.firstChild);
                    }
                    // Append parsed content
                    Array.from(doc.body.childNodes).forEach(node => {
                        container.appendChild(node.cloneNode(true));
                    });
                } catch (e) {
                    // Fallback: use textContent if parsing fails
                    container.textContent = html.replace(/<[^>]*>/g, '');
                }
                
                // Try to append to widget container first, fallback to body
                const widgetContainer = document.getElementById('accessbit-widget-container');
                if (widgetContainer) {
                    widgetContainer.appendChild(container);
                } else {
                    if (this.safeDOMOperation(() => {
                        document.body.appendChild(container);
                    }, `create overlay ${id}`)) {
                        return container;
                    }
                    return null;
                }
                
                return container;
            } catch (e) {
                return null;
            }
        }
        
        /**
         * Isolated API fetch with timeout, error handling, and retry logic
         * @param {string} url - API endpoint URL
         * @param {Object} options - Fetch options
         * @param {number} timeout - Timeout in milliseconds (default: 10000)
         * @param {number} maxRetries - Maximum retry attempts (default: 2)
         * @returns {Promise<Response|null>} Response or null on failure
         */
        async isolatedFetch(url, options = {}, timeout = 10000, maxRetries = 2) {
            // Don't make API calls in Designer mode
            if (this.isDesignerMode()) {
                return null;
            }
            
            let lastError = null;
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    // Create abort controller for timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    // Merge abort signal with existing options
                    const fetchOptions = {
                        ...options,
                        signal: controller.signal
                    };
                    
                    const response = await fetch(url, fetchOptions);
                    clearTimeout(timeoutId);
                    
                    // Handle rate limiting with exponential backoff
                    if (response.status === 429 && attempt < maxRetries) {
                        const retryAfter = response.headers.get('Retry-After');
                        const delay = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    return response;
                } catch (error) {
                    lastError = error;
                    
                    // Don't retry on abort (timeout) or if it's the last attempt
                    if (error.name === 'AbortError' || attempt === maxRetries) {
                        break;
                    }
                    
                    // Exponential backoff for retries
                    const delay = Math.pow(2, attempt) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            
            // Log error but don't throw - fail gracefully
            return null;
        }
        
        // ===== PAYMENT VALIDATION METHODS =====
        
        // Initialize payment validation
        async initializePaymentValidation() {
            
            
            try {
                // Check if this is a new user (no existing data)
                const hasExistingData = await this.checkExistingData();
                
                if (!hasExistingData) {
                    // Create trial for new user
                    const trialCreated = await this.createTrial();
                    if (!trialCreated) {
                        
                        this.disableWidget();
                        return;
                    }
                }
                
                // Validate domain access
                const domainValid = await this.validateDomainAccess();
                if (!domainValid) {
                    
                    this.disableWidget();
                    return;
                }
                
                // Check payment status
                const paymentValid = await this.checkPaymentStatus();
                if (!paymentValid) {
                   
                    this.disableWidget();
                    return;
                }
                
                
                
            } catch (error) {
               
                this.disableWidget();
            }
        }
        
        // Check if user has existing data
        async checkExistingData() {
            try {
                const siteId = await this.getSiteId();
                if (!siteId) return false;
                // Endpoint deprecated; consider presence of siteId sufficient
                return true;
            } catch (error) {
                return false;
            }
        }
        
        // Create trial for new users
        async createTrial() {
            
            try {
                const siteId = await this.getSiteId();
                if (!siteId) {
                    
                    return false;
                }
                
                const trialData = {
                    siteId: siteId,
                    email: this.getUserEmail(),
                    domain: window.location.hostname,
                    paymentStatus: 'trial',
                    trialStartDate: new Date().toISOString(),
                    trialEndDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
                };
                
                const response = await this.isolatedFetch(`${this.kvApiUrl}/api/accessibility/create-trial`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(trialData)
                });
                
                return response && response.ok;
            } catch (error) {
                
                return false;
            }
        }
        
        // Check payment status (staging free, custom domains require active paid)
        async checkPaymentStatus() {
            
            
            try {
                // Staging sites are free - check for all staging patterns
                const host = window.location.hostname || '';
                const isStagingDomain = host.endsWith('.webflow.io') || 
                                       host.endsWith('.webflow.com') || 
                                       host.includes('localhost') ||
                                       host.includes('127.0.0.1') ||
                                       host.includes('staging');
                if (isStagingDomain) {
                    return true;
                }
                // OPTIMIZED: Minimal headers, efficient fetch with isolation
                const base1 = (this && this.kvApiUrl ? this.kvApiUrl : 'https://accessbit-test-worker.web-8fb.workers.dev').replace(/\/+$/,'');
                const response = await this.isolatedFetch(`${base1}/api/stripe/customer-data-by-domain?domain=${encodeURIComponent(host)}&_t=${Date.now()}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    },
                    keepalive: false
                }, 10000, 2); // 10s timeout, 2 retries (isolatedFetch handles 429 automatically)
                
                // Handle rate limit errors with retry (fallback if isolatedFetch didn't handle it)
                if (response && response.status === 429) {
                    
                    await new Promise(resolve => setTimeout(resolve, 1500)); // Reduced retry delay
                    
                    const base2 = (this && this.kvApiUrl ? this.kvApiUrl : 'https://accessbit-test-worker.web-8fb.workers.dev').replace(/\/+$/,'');
                    const retryResponse = await this.isolatedFetch(`${base2}/api/stripe/customer-data-by-domain?domain=${encodeURIComponent(host)}&_t=${Date.now()}`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        },
                        keepalive: false
                    });
                    if (!retryResponse.ok) {
                        // API error - return null to indicate check failed (not payment invalid)
                        return null;
                    }
                    
                    const paymentData = await retryResponse.json();
                    return this.processPaymentResponse(paymentData);
                }
                
                if (!response.ok) {
                    // API error - return null to indicate check failed (not payment invalid)
                    // Don't hide widget on temporary API errors
                    return null;
                }
                
                const paymentData = await response.json();
                
                return this.processPaymentResponse(paymentData);
                
            } catch (error) {
                // Network/parsing error - return null to indicate check failed (not payment invalid)
                // Don't hide widget on temporary network errors
                return null;
            }
        }
        
        processPaymentResponse(paymentData) {
            
            
            
            
            // Determine active/cancelled from Stripe-derived fields
            if (!paymentData || typeof paymentData !== 'object') {
                // Invalid response - return null to indicate check failed (not payment invalid)
                return null;
            }
            const cancelled = paymentData.subscriptionStatus === 'cancelled' || paymentData.paymentStatus === 'cancelled' || paymentData.isSubscribed === false;
            if (cancelled) return false; // Payment is definitively invalid
            const active = paymentData.paymentStatus === 'paid' || paymentData.subscriptionStatus === 'complete' || paymentData.subscriptionStatus === 'active' || paymentData.isSubscribed === true;
            return !!active; // true if active, false if not active
        }
        
        // Validate domain access
        async validateDomainAccess() {
            
            
            try {
                const siteId = await this.getSiteId();
                const domain = window.location.hostname;
                
                // Check if this is a staging domain (always allow)
                const isStagingDomain = domain && (
                    domain.endsWith('.webflow.io') || 
                    domain.endsWith('.webflow.com') || 
                    domain.includes('localhost') ||
                    domain.includes('127.0.0.1') ||
                    domain.includes('staging')
                );
                if (isStagingDomain) {
                    return true;
                }
                
                // Security: Validate domain format
                if (!domain || typeof domain !== 'string' || domain.length > 253) {
                    return false;
                }
                // Basic domain validation - alphanumeric, dots, hyphens only
                if (!/^[a-zA-Z0-9.-]+$/.test(domain)) {
                    return false;
                }
                
                // Read siteToken from this script tag
                // SAFETY: Using specific script filename patterns to avoid matching user content
                // Only matches script tags with our widget filenames, not user elements
                let siteTokenParam = null;
                try {
                    const scriptEl = document.currentScript || 
                                   document.querySelector('script[src*="test.js"]') ||
                                   document.querySelector('script[src*="new.js"]') ||
                                   document.querySelector('script[src*="accessbit"]') ||
                                   document.querySelector('script[src*="widget.js"]');
                    if (scriptEl && scriptEl.src) {
                        const u = new URL(scriptEl.src);
                        siteTokenParam = u.searchParams.get('siteToken');
                        // Security: Validate token format if present (alphanumeric and common token chars only)
                        if (siteTokenParam && (!/^[a-zA-Z0-9._-]+$/.test(siteTokenParam) || siteTokenParam.length > 500)) {
                            siteTokenParam = null;
                        }
                    }
                } catch {}
                
                // Security: Validate siteId if present
                if (siteId && (typeof siteId !== 'string' || siteId.length > 100 || !/^[a-zA-Z0-9_-]+$/.test(siteId))) {
                    return false;
                }
                
                const visitorId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2));
                const base3 = (this && this.kvApiUrl ? this.kvApiUrl : 'https://accessbit-test-worker.web-8fb.workers.dev').replace(/\/+$/,'');
                const response = await this.isolatedFetch(`${base3}/api/accessibility/validate-domain`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ domain, siteId, siteToken: siteTokenParam, visitorId })
                });
                
                if (!response || !response.ok) return false;
                
                const { isValid } = await response.json();
                return isValid;
            } catch (error) {
                
                return false;
            }
        }
        
        // Disable widget when payment fails
        disableWidget() {
            
            
            // Set payment failed flag FIRST
            this.paymentFailed = true;
            
            // Hide the widget container
            const widgetContainer = document.getElementById('accessbit-widget-container');
            if (widgetContainer) {
                widgetContainer.style.display = 'none';
                widgetContainer.style.visibility = 'hidden';
                widgetContainer.style.opacity = '0';
            }
            
            // Hide the icon and panel inside shadow DOM
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            
            if (icon) {
                console.log('[ICON HIDE] disableWidget() - Payment failed, hiding icon');
                icon.style.display = 'none';
                icon.style.visibility = 'hidden';
                icon.style.opacity = '0';
            }
            if (panel) {
                panel.style.display = 'none';
                panel.style.visibility = 'hidden';
                panel.style.opacity = '0';
            }
            
            // Show payment required message
            this.showPaymentRequiredMessage();
        }
        
        // Show payment required message - DISABLED
        showPaymentRequiredMessage() {
            // Payment message disabled - no popup will be shown
            
        }
        
        
        
        // ===== END PAYMENT VALIDATION METHODS =====
        
        // Store original element positions and sizes before applying seizure-safe mode
        storeOriginalLayout() {
            try {
                if (!this.originalLayouts) {
                    this.originalLayouts = new Map();
                }
                
                const allElements = document.querySelectorAll('*');
                allElements.forEach((element, index) => {
                    if (index < 1000) { // Limit to prevent memory issues
                        const computedStyle = window.getComputedStyle(element);
                        this.originalLayouts.set(element, {
                            position: computedStyle.position,
                            top: computedStyle.top,
                            left: computedStyle.left,
                            right: computedStyle.right,
                            bottom: computedStyle.bottom,
                            transform: computedStyle.transform,
                            width: computedStyle.width,
                            height: computedStyle.height,
                            display: computedStyle.display,
                            opacity: computedStyle.opacity,
                            visibility: computedStyle.visibility
                        });
                    }
                });
                
                
            } catch (e) {
                
            }
        }
        
        // Restore original element positions and sizes
        restoreOriginalLayout() {
            try {
                if (this.originalLayouts) {
                    this.originalLayouts.forEach((layout, element) => {
                        if (element && element.style) {
                            element.style.position = layout.position;
                            element.style.top = layout.top;
                            element.style.left = layout.left;
                            element.style.right = layout.right;
                            element.style.bottom = layout.bottom;
                            element.style.transform = layout.transform;
                            element.style.width = layout.width;
                            element.style.height = layout.height;
                            element.style.display = layout.display;
                            element.style.opacity = layout.opacity;
                            element.style.visibility = layout.visibility;
                        }
                    });
                    
                }
            } catch (e) {
                
            }
        }
        
        // Force all animations to their final state immediately if seizure-safe is enabled
        forceAllAnimationsToFinalState() {
            try {
                // Check if seizure-safe is enabled
                const isSeizureSafe = document.body.classList.contains('seizure-safe');
                const seizureSafeFromStorage = localStorage.getItem('accessbit-widget-seizure-safe') === 'true';
                
                if (isSeizureSafe || seizureSafeFromStorage) {
                    
                    
                    // Stop seizure-triggering animations only
                    const animatedElements = document.querySelectorAll('*[class*="animate"], *[class*="fade"], *[class*="slide"], *[class*="bounce"], *[class*="pulse"], *[class*="shake"], *[class*="flash"], *[class*="blink"], *[class*="glow"], *[class*="spin"], *[class*="rotate"], *[class*="scale"], *[class*="zoom"], *[class*="wiggle"], *[class*="jiggle"], *[class*="twist"], *[class*="flip"], *[class*="swing"], *[class*="wobble"], *[class*="tilt"]');
                    
                    animatedElements.forEach(element => {
                        element.style.animation = 'none';
                        element.style.transition = 'none';
                        element.style.opacity = '1';
                        element.style.visibility = 'visible';
                        element.style.transform = 'none';
                    });
                    
                    // Stop letter-by-letter text animations
                    const textElements = document.querySelectorAll('[data-splitting], .split, .char, .word');
                    textElements.forEach(element => {
                        element.style.animation = 'none';
                        element.style.transition = 'none';
                        element.style.opacity = '1';
                        element.style.visibility = 'visible';
                        element.style.transform = 'none';
                    });
                    
                    // Stop autoplay media
                    const mediaElements = document.querySelectorAll('video, audio');
                    mediaElements.forEach(element => {
                        if (element.tagName === 'VIDEO' || element.tagName === 'AUDIO') {
                            element.pause();
                            element.autoplay = false;
                        }
                    });
                    
                    // Stop SVG animations
                    const svgElements = document.querySelectorAll('svg, svg path, svg line');
                    svgElements.forEach(element => {
                        element.style.animation = 'none';
                        element.style.transition = 'none';
                        element.style.opacity = '1';
                        element.style.visibility = 'visible';
                        element.style.transform = 'none';
                    });
                    
                    // Stop scroll-triggered animations
                    const scrollElements = document.querySelectorAll('*[class*="scroll"], *[class*="progress"], *[class*="bar"], *[class*="line"], *[class*="timeline"]');
                    scrollElements.forEach(element => {
                        element.style.animation = 'none';
                        element.style.transition = 'none';
                        element.style.opacity = '1';
                        element.style.visibility = 'visible';
                        element.style.transform = 'none';
                    });
                    
                    
                }
            } catch (e) {
                
            }
        }
        
        // Check and apply seizure-safe mode immediately before any animations start
        checkAndApplyImmediateSeizureSafe() {
            try {
                // Check localStorage first for immediate application
                const seizureSafeFromStorage = localStorage.getItem('accessbit-widget-seizure-safe');
                if (seizureSafeFromStorage === 'true') {
                    // Use safe class toggle (Designer-compliant)
                    this.safeBodyClassToggle('seizure-safe', true);
                    this.applyImmediateSeizureCSS();
                    this.forceCompleteTextAnimations();
                }
            } catch (e) {
                
            }
        }
        
        // Set up aggressive monitoring for any text animations that might start
        // REMOVED: Duplicate setupSeizureSafeMonitoring() - using more comprehensive version below
        
        // Set up aggressive monitoring for text animations when seizure-safe mode is active
        setupSeizureSafeMonitoring() {
            try {
                // Only set up monitoring if seizure-safe mode is active
                if (!document.body.classList.contains('seizure-safe')) {
                    return;
                }
                
                
                
                // Use MutationObserver to catch any text animations that start
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList' || mutation.type === 'attributes') {
                            // Check for any new text animation elements
                            const textElements = document.querySelectorAll('[data-splitting], .split, .char, .word');
                            textElements.forEach(element => {
                                if (element.style.animation || element.style.transition || element.style.opacity !== '1') {
                                    // Force complete the animation immediately
                                    element.style.animation = 'none';
                                    element.style.transition = 'none';
                                    element.style.opacity = '1';
                                    element.style.visibility = 'visible';
                                    element.style.display = element.tagName === 'SPAN' ? 'inline' : 'block';
                                    element.style.transform = 'none';
                                }
                            });
                        }
                    });
                });
                
                // Start observing
                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
                
                // Also run a periodic check every 100ms for the first 5 seconds
                let checkCount = 0;
                const interval = setInterval(() => {
                    if (checkCount >= 50 || !document.body.classList.contains('seizure-safe')) {
                        clearInterval(interval);
                        return;
                    }
                    
                    this.forceCompleteTextAnimations();
                    checkCount++;
                }, 100);
                
            } catch (e) {
                
            }
        }
        
        // Minimal early CSS to pause motion before full seizure-safe styles load
        applyImmediateSeizureCSS() {
            try {
                if (document.getElementById('accessbit-seizure-immediate')) return;
                const style = document.createElement('style');
                style.id = 'accessbit-seizure-immediate';
                style.textContent = `
                    /* IMMEDIATE SEIZURE-SAFE CSS - Minimal approach */
                    body.seizure-safe * {
                        animation-play-state: paused !important;
                        transition: none !important;
                    }
                    
                    /* Stop letter-by-letter animations immediately */
                    body.seizure-safe [data-splitting],
                    body.seizure-safe .split,
                    body.seizure-safe .char,
                    body.seizure-safe .word {
                        animation: none !important;
                        transition: none !important;
                        /* REMOVED: opacity: 1, visibility: visible, display: inline - these were causing extra white space by revealing hidden elements */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* Stop SVG animations immediately */
                    /* REMOVED: opacity: 1 and visibility: visible - these were causing extra white space by revealing hidden elements */
                    body.seizure-safe svg,
                    body.seizure-safe svg path,
                    body.seizure-safe svg line {
                        animation: none !important;
                        transition: none !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* Stop scroll-triggered animations immediately */
                    /* REMOVED: opacity: 1 and visibility: visible - these were causing extra white space by revealing hidden elements */
                    body.seizure-safe *[class*="scroll"],
                    body.seizure-safe *[class*="progress"],
                    body.seizure-safe *[class*="bar"],
                    body.seizure-safe *[class*="line"],
                    body.seizure-safe *[class*="timeline"],
                    body.seizure-safe [data-scroll],
                    body.seizure-safe [data-aos],
                    body.seizure-safe [data-animate],
                    body.seizure-safe [data-wf-page],
                    body.seizure-safe [data-w-id] {
                        animation: none !important;
                        transition: none !important;
                        transform: none !important;
                        will-change: auto !important;
                    }
                    
                    /* Allow slider manual navigation - preserve pointer events and allow slide transitions */
                    body.seizure-safe .swiper,
                    body.seizure-safe .swiper-container,
                    body.seizure-safe .slick-slider,
                    body.seizure-safe .carousel,
                    body.seizure-safe [class*="slider"]:not([class*="toggle"]),
                    body.seizure-safe [class*="carousel"],
                    body.seizure-safe [data-slider],
                    body.seizure-safe [data-carousel] {
                        pointer-events: auto !important;
                        cursor: default !important;
                        /* Allow slide transitions for manual navigation */
                        transition: transform 0.3s ease !important;
                    }
                    
                    /* Block auto-slide animations but allow manual slide changes */
                    body.seizure-safe .swiper-slide,
                    body.seizure-safe .slick-slide,
                    body.seizure-safe .carousel-item {
                        animation: none !important;
                        /* Allow transform for manual slide navigation */
                        transition: transform 0.3s ease !important;
                    }
                `;
                document.head.appendChild(style);
            } catch (e) {
                
            }
        }
    
    
    
        async init() {
            // CRITICAL: Don't run widget in Webflow Designer environment
            if (this.isDesignerMode()) {
                return;
            }
            
            // Check if payment failed - if so, don't initialize
            if (this.paymentFailed) {
                
                return;
            }
    
            this.addFontAwesome();
    
            // CSS is loaded in createWidget() via getWidgetCSS() - no need for separate addCSS()
    
            // Check if interface should be hidden
            if (localStorage.getItem('accessbit-widget-hidden') === 'true') {
                console.log('[ICON HIDE] init() - Interface is hidden in localStorage, preventing widget creation');
                return;
            }
    
            console.log('[INIT] Creating widget...');
            this.createWidget();
            console.log('[INIT] Widget created, checking if icon exists...');
            const iconCheck = this.shadowRoot?.getElementById('accessbit-widget-icon');
            console.log('[INIT] Icon check after createWidget():', {
                hasIcon: !!iconCheck,
                iconDisplay: iconCheck ? iconCheck.style.display : 'N/A',
                iconVisibility: iconCheck ? iconCheck.style.visibility : 'N/A'
            });
            
            this.loadSettings();
    
            // If reduce-motion was previously enabled, apply it ASAP so it persists on refresh
            if (this.settings && this.settings['reduce-motion']) {
                try {
                    this.safeBodyClassToggle('reduce-motion', true);
                    this.enableReduceMotion();
                } catch (e) {
                    
                }
            }
            
            // If seizure-safe was previously enabled, apply it ASAP so it persists on refresh
            if (this.settings && this.settings['seizure-safe']) {
                try {
                    // Add class immediately to enable CSS guards before any library re-inits (Designer-safe)
                    this.safeBodyClassToggle('seizure-safe', true);
                    // Apply immediate minimal CSS to halt motion until full styles are added
                    this.applyImmediateSeizureCSS();
                    // Force complete any text animations immediately
                    this.forceCompleteTextAnimations();
                    // Proceed with full enable without delay
                    this.enableSeizureSafe(true /* immediate */);
                } catch (e) {
                    
                }
            }
    
            
            // Load user settings from KV storage
            await this.loadSettingsFromKV();
            // If KV indicates seizure-safe, ensure it is enabled immediately
            if (this.settings && this.settings['seizure-safe']) {
                // Use safe class toggle (Designer-compliant)
                if (!document.body.classList.contains('seizure-safe')) {
                    this.safeBodyClassToggle('seizure-safe', true);
                }
                // Force complete any text animations immediately
                this.forceCompleteTextAnimations();
                this.enableSeizureSafe(true /* immediate */);
            }
    
            
            // Restore saved language FIRST (before showing icon)
            // This ensures language is set before any positioning or customization
            const savedLanguage = localStorage.getItem('accessbit-widget-language');
            if (savedLanguage) {
                this.applyLanguage(savedLanguage);
            } else {
                this.applyLanguage('English');
            }
            
            // Fetch customization data (BLOCKING - load on page load for immediate customization)
            // This ensures icon appears with user's customization immediately, no delays
            console.log('[INIT] Starting customization data fetch...');
            try {
                const customizationData = await this.fetchCustomizationData();
                console.log('[INIT] fetchCustomizationData() returned:', {
                    hasData: !!customizationData,
                    hasCustomization: !!(customizationData && customizationData.customization),
                    customizationKeys: customizationData && customizationData.customization ? Object.keys(customizationData.customization) : [],
                    fullData: customizationData
                });
                
                if (customizationData && customizationData.customization) {
                    console.log('[INIT] Applying customizations...');
                    // Apply customizations BEFORE showing icon
                    this.applyCustomizations(customizationData.customization);
                    // Also apply accessibility profiles if present
                    if (customizationData.accessibilityProfiles && typeof this.applyAccessibilityProfiles === 'function') {
                        this.applyAccessibilityProfiles(customizationData.accessibilityProfiles);
                    }
                    console.log('[INIT] Customizations applied successfully');
                } else {
                    console.warn('[INIT] No customization data to apply');
                }
                
              
                const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
                console.log('[INIT] Checking icon visibility conditions:', {
                    hasIcon: !!icon,
                    hasCustomizationData: !!customizationData,
                    hasCustomization: !!(customizationData && customizationData.customization),
                    iconElement: icon,
                    iconCurrentDisplay: icon ? icon.style.display : 'N/A',
                    iconCurrentVisibility: icon ? icon.style.visibility : 'N/A',
                    iconCurrentOpacity: icon ? icon.style.opacity : 'N/A'
                });
                
                if (icon && customizationData && customizationData.customization) {
                    const hideTrigger = customizationData.customization.hideTriggerButton === 'Yes';
                    const isMobile = window.innerWidth <= 768;
                    const mobileVisibility = customizationData.customization.showOnMobile;
                    
                    console.log('[INIT] Icon visibility settings:', {
                        hideTrigger,
                        isMobile,
                        mobileVisibility,
                        shouldShow: !hideTrigger || (isMobile && mobileVisibility === 'Show')
                    });
                    
                    // Determine if icon should be shown based on settings
                    let shouldShow = false;
                    
                    // Desktop/Tablet: show only if hideTriggerButton is NOT 'Yes'
                    if (!isMobile) {
                        shouldShow = !hideTrigger;
                    } 
                    // Mobile: show only if showOnMobile is 'Show'
                    else {
                        shouldShow = mobileVisibility === 'Show';
                    }
                    
                    if (shouldShow) {
                        console.log('[ICON SHOW] init() - Showing icon after customization loaded', {
                            hideTrigger,
                            isMobile,
                            mobileVisibility,
                            shouldShow
                        });
                        // Remove any conflicting inline styles first
                        icon.style.removeProperty('display');
                        icon.style.removeProperty('visibility');
                        icon.style.removeProperty('opacity');
                        // Use setProperty with !important to override any CSS rules
                        icon.style.setProperty('display', 'flex', 'important');
                        icon.style.setProperty('visibility', 'visible', 'important');
                        icon.style.setProperty('opacity', '1', 'important');
                        icon.style.setProperty('pointer-events', 'auto', 'important');
                        // Mark that icon was explicitly shown during initialization
                        // This prevents showIcon() from hiding it during resize events
                        this._iconExplicitlyShown = true;
                    } else {
                        console.log('[ICON HIDE] init() - Hiding icon based on settings', {
                            hideTrigger,
                            isMobile,
                            mobileVisibility,
                            shouldShow
                        });
                        // Ensure icon is hidden
                        icon.style.setProperty('display', 'none', 'important');
                        icon.style.setProperty('visibility', 'hidden', 'important');
                        icon.style.setProperty('opacity', '0', 'important');
                        this._iconExplicitlyShown = false;
                    }
                } else {
                    console.warn('[ICON HIDE] init() - No customization data available', {
                        hasCustomizationData: !!customizationData,
                        hasCustomization: !!(customizationData && customizationData.customization),
                        hasIcon: !!icon,
                        siteId: this.siteId,
                        reason: !icon ? 'Icon element not found' : 
                                !customizationData ? 'No customization data returned' : 
                                'Customization object missing'
                    });
                }
            } catch (err) {
                // Log error but don't show icon (user wants icon only with customization data)
                console.error('[ICON HIDE] init() - Error fetching customization data:', err);
                console.error('[ICON HIDE] Error stack:', err.stack);
            }
            
            // Set up periodic payment status refresh (every 5 minutes)
            // This ensures widget knows immediately when payment status changes
            this.setupPaymentStatusRefresh();
            
            // Refresh payment status when page becomes visible (user switches back to tab)
            // This catches payment changes that happened while tab was inactive
            // Only for custom domains (staging is always free)
            // Only add listener once (check if already added)
            if (!this._visibilityListenerAdded) {
                document.addEventListener('visibilitychange', async () => {
                    if (!document.hidden && !this.isStagingDomain()) {
                        // Custom domains: Check fresh payment status when tab becomes visible
                        // Staging domains: Skip (always free)
                        try {
                            const isValid = await this.checkPaymentStatusRealTime();
                            // Only hide widget if payment is definitively invalid AND widget was not already hidden
                            // Don't hide on check failures (network errors, etc.)
                            if (isValid === false && this.paymentFailed === false) {
                                this.disableWidget();
                            } else if (isValid === true && this.paymentFailed === true) {
                                // Payment status changed from invalid to valid - re-enable widget
                                this.paymentFailed = false;
                                const widgetContainer = document.getElementById('accessbit-widget-container');
                                if (widgetContainer) {
                                    widgetContainer.style.display = '';
                                    widgetContainer.style.visibility = '';
                                    widgetContainer.style.opacity = '';
                                }
                                const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
                                if (icon) {
                                    this.showIcon();
                                }
                            }
                            // If isValid is null/undefined (check failed), don't change widget state
                        } catch (error) {
                            // Silently handle errors - don't change widget state on check failures
                        }
                    }
                });
                this._visibilityListenerAdded = true;
            }
            
    
            // Delay binding events to ensure elements are created
    
            setTimeout(async () => {
    
                
    
                this.bindEvents();
    
                this.applySettings();
                
                // Set up ResizeObserver AFTER icon visibility is determined
                // This prevents it from firing before _iconExplicitlyShown is set
                if (this._iconExplicitlyShown !== undefined) {
                    // Icon visibility has been determined, safe to set up ResizeObserver
                    // (ResizeObserver setup is already in bindEvents via setupOptimizedResizeHandlers)
                }
    
                
    
                // Customization data is already fetched non-blocking in init()
                // No need to fetch again here
    
                
    
                // Initialize keyboard shortcuts only if keyboard navigation is enabled
    
                if (this.settings['keyboard-nav']) {
    
                    
    
                this.initKeyboardShortcuts();
    
                } else {
    
                    
    
                }
    
                
    
                
    
                
    
            }, 100);
    
        }
    
    
    
        bindEvents() {
    
            
    
            
    
            // Panel toggle functionality - using Shadow DOM
    
            const icon = this.shadowRoot.getElementById('accessbit-widget-icon');
    
            const panel = this.shadowRoot.getElementById('accessbit-widget-panel');
    
            const closeBtn = this.shadowRoot.getElementById('close-panel');
    
            
    
            
    
            
            
    
            
    
            if (icon) {
                console.log('[BIND EVENTS] Attaching click listener to icon', {
                    icon: icon,
                    iconComputedVisibility: window.getComputedStyle(icon).visibility,
                    iconComputedOpacity: window.getComputedStyle(icon).opacity,
                    iconComputedPointerEvents: window.getComputedStyle(icon).pointerEvents
                });
                // Click event
                icon.addEventListener('click', (e) => {
                    console.log('[ICON CLICK] Icon clicked!', {
                        event: e,
                        icon: icon,
                        iconComputedVisibility: window.getComputedStyle(icon).visibility,
                        iconComputedOpacity: window.getComputedStyle(icon).opacity,
                        iconPointerEvents: window.getComputedStyle(icon).pointerEvents,
                        iconDisplay: window.getComputedStyle(icon).display
                    });
                    
                    this.togglePanel();
                    
                    // Debug: Check panel state
                    const panel = this.shadowRoot.getElementById('accessbit-widget-panel');
                    console.log('[ICON CLICK] Panel state after toggle:', {
                        hasPanel: !!panel,
                        panelDisplay: panel ? window.getComputedStyle(panel).display : 'N/A',
                        panelVisibility: panel ? window.getComputedStyle(panel).visibility : 'N/A',
                        panelTransform: panel ? panel.style.transform : 'N/A',
                        isPanelOpen: this.isPanelOpen
                    });
    
                    if (panel) {

    
                    } else {
    
;
    
                    }
    
                });
                // PERFORMANCE OPTIMIZATION: Combined, debounced resize handler
                this.setupOptimizedResizeHandlers();
                
                // Apply mobile responsive styles on load if mobile
                if (window.innerWidth <= 768) {
                    this.applyMobileResponsiveStyles();
                }
                
                // PERFORMANCE OPTIMIZATION: Throttled MutationObserver
                this.setupThrottledMutationObserver();
                
                // PERFORMANCE OPTIMIZATION: Periodic check with throttling
                this.setupPeriodicStyleCheck();
                
    
                // Keyboard event for icon
    
                icon.addEventListener('keydown', (e) => {
    
                    if (e.key === 'Enter' || e.key === ' ') {
    
                        e.preventDefault();
    

    
                        this.togglePanel();
    
                    }
    
                });
    
            }
    
            
    
            if (closeBtn) {
    
                // Click event
    
                closeBtn.addEventListener('click', () => {
    
                    
    
                    this.togglePanel();
    
                });
    
                
    
                // Keyboard event for close button
    
                closeBtn.addEventListener('keydown', (e) => {
    
                    if (e.key === 'Enter' || e.key === ' ') {
    
                        e.preventDefault();
    
                       
    
                        this.togglePanel();
    
                    }
    
                });
    
            }
    
            
    
            // Toggle switches - using Shadow DOM
    
            const toggles = this.shadowRoot.querySelectorAll('.toggle-switch input');
    
            toggles.forEach(toggle => {
    
                // Add proper ARIA attributes for screen readers
    
                this.addToggleAccessibility(toggle);
    
                
    
                toggle.addEventListener('change', (e) => {
    
                    const feature = e.target.id;
    
                    const enabled = e.target.checked;
    

                    this.handleToggle(feature, enabled);
    
                    
    
                    // Special handling for content scaling toggle
    
                    if (feature === 'content-scaling') {
    
                        this.toggleContentScalingControls(enabled);
    
                    }
    
                    
    
                    // Special handling for font sizing toggle
    
                    if (feature === 'font-sizing') {
    
                        this.toggleFontSizingControls(enabled);
    
                    }
    
    
    
                    // Special handling for line height toggle
                    
    
                    if (feature === 'adjust-line-height') {
                        
                        this.toggleLineHeightControls(enabled);
    
                    }
    
                    // Special handling for alignment toggles - ensure mutual exclusion
                    
    
                    if (feature === 'align-left' && enabled) {
                        
                        
                        // Clear all alignment classes first
                        this.clearAllAlignmentClasses();
    
                        // Uncheck other alignment toggles in UI
                        const centerToggle = this.shadowRoot.getElementById('align-center');
                        const rightToggle = this.shadowRoot.getElementById('align-right');
                        
                        
                        if (centerToggle) centerToggle.checked = false;
                        if (rightToggle) rightToggle.checked = false;
    
                    } else if (feature === 'align-center' && enabled) {
                        
    
                        // Clear all alignment classes first
                        this.clearAllAlignmentClasses();
    
                        // Uncheck other alignment toggles in UI
                        const leftToggle = this.shadowRoot.getElementById('align-left');
                        const rightToggle = this.shadowRoot.getElementById('align-right');
                        
                        
                        if (leftToggle) leftToggle.checked = false;
                        if (rightToggle) rightToggle.checked = false;
    
                    } else if (feature === 'align-right' && enabled) {
                        
    
                        // Clear all alignment classes first
                        this.clearAllAlignmentClasses();
    
                        // Uncheck other alignment toggles in UI
                        const leftToggle = this.shadowRoot.getElementById('align-left');
                        const centerToggle = this.shadowRoot.getElementById('align-center');
                        
                        
                        if (leftToggle) leftToggle.checked = false;
                        if (centerToggle) centerToggle.checked = false;
    
                    }
    
                    // Prevent multiple calls to the same alignment function
                    if (feature.startsWith('align-') && enabled) {
                        
                        return; // Skip the normal toggle processing to prevent conflicts
                    }
    
    
    
                    // Special handling for letter spacing toggle
    
                    if (feature === 'adjust-letter-spacing') {
    
                        this.toggleLetterSpacingControls(enabled);
    
                    }
    
    
    
                });
    
            });
    
    
    
            // Add keyboard support for profile items (Enter key to toggle)
    
            const profileItems = this.shadowRoot.querySelectorAll('.profile-item');
    
            profileItems.forEach(profileItem => {
    
                // Make profile items focusable
    
                profileItem.setAttribute('tabindex', '0');
    
                profileItem.setAttribute('role', 'button');
                
                // Remove tabindex from checkboxes inside profile items to prevent double-tab issue
                // The profile-item container handles keyboard navigation, so checkboxes should not be in tab order
                const checkbox = profileItem.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.setAttribute('tabindex', '-1');
                }
    
                
    
                // Add keyboard event listener
    
                profileItem.addEventListener('keydown', (e) => {
    
                    if (e.key === 'Enter' || e.key === ' ') {
    
                        e.preventDefault();
    
                        const toggle = profileItem.querySelector('input[type="checkbox"]');
    
                        if (toggle) {
    
                            toggle.checked = !toggle.checked;
    
                            const feature = toggle.id;
                            
    
                            const enabled = toggle.checked;
    
                            
    
                            this.handleToggle(feature, enabled);
    
                            // Ensure control buttons are revealed when toggled via keyboard
                            try {
                                if (feature === 'content-scaling') {
                                    
                                    this.toggleContentScalingControls(enabled);
                                    // Focus on the first control button when enabled
                                    if (enabled) {
                                        setTimeout(() => {
                                            const decreaseBtn = this.shadowRoot.getElementById('decrease-content-scale-btn');
                                            if (decreaseBtn) {
                                                decreaseBtn.focus();
                                                
                                            }
                                        }, 100);
                                    }
                                } else if (feature === 'font-sizing') {
                                    
                                    this.toggleFontSizingControls(enabled);
                                    // Focus on the first control button when enabled
                                    if (enabled) {
                                        setTimeout(() => {
                                            const decreaseBtn = this.shadowRoot.getElementById('decrease-font-size-btn');
                                            if (decreaseBtn) {
                                                decreaseBtn.focus();
                                                
                                            }
                                        }, 100);
                                    }
                                } else if (feature === 'adjust-line-height') {
                                    
                                    this.toggleLineHeightControls(enabled);
                                    // Focus on the first control button when enabled
                                    if (enabled) {
                                        setTimeout(() => {
                                            const decreaseBtn = this.shadowRoot.getElementById('decrease-line-height-btn');
                                            if (decreaseBtn) {
                                                decreaseBtn.focus();
                                                
                                            }
                                        }, 100);
                                    }
                                } else if (feature === 'adjust-letter-spacing') {
                                    
                                    this.toggleLetterSpacingControls(enabled);
                                    // Focus on the first control button when enabled
                                    if (enabled) {
                                        setTimeout(() => {
                                            const decreaseBtn = this.shadowRoot.getElementById('decrease-letter-spacing-btn');
                                            if (decreaseBtn) {
                                                decreaseBtn.focus();
                                                
                                            }
                                        }, 100);
                                    }
                                }
                            } catch (err) {
                                
                            }
    
                            
    
                            // Announce to screen reader
    
                            const featureName = profileItem.querySelector('h4')?.textContent || feature;
    
                            this.announceToScreenReader(`${featureName} ${enabled ? 'enabled' : 'disabled'}`);
    
                        }
    
                    }
    
                });
    
            });
    
            
    
            // Action buttons - using Shadow DOM
    
            const resetBtn = this.shadowRoot.getElementById('reset-settings');
    
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
    
                    
    
                    this.resetSettings();
    
                });
    
            }
    
            
    
            const statementBtn = this.shadowRoot.getElementById('statement');
    
            if (statementBtn) {
                statementBtn.addEventListener('click', () => {
    
                    
    
                    this.showStatement();
    
                });
    
            }
    
            
    
            const hideBtn = this.shadowRoot.getElementById('hide-interface');
    
            if (hideBtn) {
                hideBtn.addEventListener('click', () => {
    
                    
    
                    this.hideInterface();
    
                });
    
            }
    
            
    
            // Language selector header event listener will be set up after panel creation
    
            
    
            
    
            // Content scaling control buttons - using Shadow DOM
            const decreaseContentScaleBtn = this.shadowRoot.getElementById('decrease-content-scale-btn');
            if (decreaseContentScaleBtn) {
                decreaseContentScaleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.decreaseContentScale();
                });
                
                // Add keyboard support
                decreaseContentScaleBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.decreaseContentScale();
                    } else if (e.key === 'ArrowDown') {
                        // Down arrow decreases
                        e.preventDefault();
                        e.stopPropagation();
                        this.decreaseContentScale();
                    } else if (e.key === 'ArrowUp') {
                        // Up arrow increases
                        e.preventDefault();
                        e.stopPropagation();
                        this.increaseContentScale();
                    }
                });
            }
            
            const increaseContentScaleBtn = this.shadowRoot.getElementById('increase-content-scale-btn');
            if (increaseContentScaleBtn) {
                increaseContentScaleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.increaseContentScale();
                });
                
                // Add keyboard support
                increaseContentScaleBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.increaseContentScale();
                    } else if (e.key === 'ArrowDown') {
                        // Down arrow decreases
                        e.preventDefault();
                        e.stopPropagation();
                        this.decreaseContentScale();
                    } else if (e.key === 'ArrowUp') {
                        // Up arrow increases
                        e.preventDefault();
                        e.stopPropagation();
                        this.increaseContentScale();
                    }
                });
            }
    
    
    
            // Font sizing control buttons - using Shadow DOM
    
            const decreaseFontSizeBtn = this.shadowRoot.getElementById('decrease-font-size-btn');
    
            if (decreaseFontSizeBtn) {
    
                decreaseFontSizeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.decreaseFontSize();
                });
    
                // Add keyboard support
                decreaseFontSizeBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.decreaseFontSize();
                    } else if (e.key === 'ArrowDown') {
                        // Down arrow decreases
                        e.preventDefault();
                        e.stopPropagation();
                        this.decreaseFontSize();
                    } else if (e.key === 'ArrowUp') {
                        // Up arrow increases
                        e.preventDefault();
                        e.stopPropagation();
                        this.increaseFontSize();
                    }
                });
    
            }
    
    
    
            const increaseFontSizeBtn = this.shadowRoot.getElementById('increase-font-size-btn');
    
            if (increaseFontSizeBtn) {
    
                increaseFontSizeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.increaseFontSize();
                });
    
                // Add keyboard support
                increaseFontSizeBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.increaseFontSize();
                    } else if (e.key === 'ArrowDown') {
                        // Down arrow decreases
                        e.preventDefault();
                        e.stopPropagation();
                        this.decreaseFontSize();
                    } else if (e.key === 'ArrowUp') {
                        // Up arrow increases
                        e.preventDefault();
                        e.stopPropagation();
                        this.increaseFontSize();
                    }
                });
    
            }
    
    
    
    
    
    
    
            // Letter spacing control buttons - using Shadow DOM
    
            const decreaseLetterSpacingBtn = this.shadowRoot.getElementById('decrease-letter-spacing-btn');
    
            if (decreaseLetterSpacingBtn) {
    
                decreaseLetterSpacingBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.decreaseLetterSpacing();
                });
    
                // Add keyboard support
                decreaseLetterSpacingBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.decreaseLetterSpacing();
                    } else if (e.key === 'ArrowDown') {
                        // Down arrow decreases
                        e.preventDefault();
                        e.stopPropagation();
                        this.decreaseLetterSpacing();
                    } else if (e.key === 'ArrowUp') {
                        // Up arrow increases
                        e.preventDefault();
                        e.stopPropagation();
                        this.increaseLetterSpacing();
                    }
                });
    
            }
    
    
    
            const increaseLetterSpacingBtn = this.shadowRoot.getElementById('increase-letter-spacing-btn');
    
            if (increaseLetterSpacingBtn) {
    
                increaseLetterSpacingBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.increaseLetterSpacing();
                });
    
                // Add keyboard support
                increaseLetterSpacingBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.increaseLetterSpacing();
                    } else if (e.key === 'ArrowDown') {
                        // Down arrow decreases
                        e.preventDefault();
                        e.stopPropagation();
                        this.decreaseLetterSpacing();
                    } else if (e.key === 'ArrowUp') {
                        // Up arrow increases
                        e.preventDefault();
                        e.stopPropagation();
                        this.increaseLetterSpacing();
                    }
                });
    
            }
    
    
    
            
    
        }
    
    
    
        initTextMagnifier() {
    
            // Initialize text magnifier functionality
    
            
    
        }
    
    
    
        initKeyboardShortcuts() {
    
            
    
            
    
            // Remove existing shortcuts if any
    
            this.removeKeyboardShortcuts();
    
            
    
            // Initialize element tracking for cycling
    
            this.currentElementIndex = {};
    
            this.highlightedElements = [];
    
            
    
            // Add mouse detection for disabling keyboard focus indicators
            this.mouseHandler = (e) => {
                this.isKeyboardNavigation = false;
                this.lastInteractionMethod = 'mouse';
                
                
                // Disable highlight focus when mouse is used
                if (document.body.classList.contains('highlight-focus')) {
                    
                    this.disableHighlightFocus();
                }
            };
    
            // Add keyboard shortcuts for navigation
    
            this.keyboardShortcutHandler = (e) => {
    
                
    
                // Detect Tab key navigation
                if (e.key === 'Tab') {
                    this.isKeyboardNavigation = true;
                    this.lastInteractionMethod = 'keyboard';
                    
                    // REMOVED: Auto-enable highlight focus on Tab press
                    // Only enable highlight-focus if user explicitly turns it on in widget settings
                    // This prevents unwanted focus boxes from appearing when clicking links
                }
    
                
    
                // Global shortcuts (only work when keyboard navigation is enabled)
                // Check both settings and body class to ensure keyboard-nav is active
                const isKeyboardNavEnabled = this.settings['keyboard-nav'] || 
                                            document.body.classList.contains('keyboard-nav') ||
                                            this.isKeyboardNavigation;
    
                if (e.altKey && isKeyboardNavEnabled) {
    
                    // Arrow key adjustments for scaling values
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        // Check if user is typing in an input field - don't interfere
                        const activeElement = document.activeElement;
                        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true')) {
                            return; // Don't interfere with typing
                        }
                        
                        e.preventDefault();
                        
                        if (e.shiftKey && e.ctrlKey) {
                            // Alt+Shift+Ctrl+ArrowUp/Down: Adjust letter spacing
                            if (e.key === 'ArrowUp') {
                                this.increaseLetterSpacing();
                                this.announceToScreenReader(`Letter spacing increased to ${this.letterSpacing}%`);
                            } else {
                                this.decreaseLetterSpacing();
                                this.announceToScreenReader(`Letter spacing decreased to ${this.letterSpacing}%`);
                            }
                            return;
                        } else if (e.ctrlKey) {
                            // Alt+Ctrl+ArrowUp/Down: Adjust line height
                            if (e.key === 'ArrowUp') {
                                this.increaseLineHeight();
                                this.announceToScreenReader(`Line height increased to ${this.lineHeight}%`);
                            } else {
                                this.decreaseLineHeight();
                                this.announceToScreenReader(`Line height decreased to ${this.lineHeight}%`);
                            }
                            return;
                        } else if (e.shiftKey) {
                            // Alt+Shift+ArrowUp/Down: Adjust font size
                            if (e.key === 'ArrowUp') {
                                this.increaseFontSize();
                                this.announceToScreenReader(`Font size increased to ${this.fontSize}%`);
                            } else {
                                this.decreaseFontSize();
                                this.announceToScreenReader(`Font size decreased to ${this.fontSize}%`);
                            }
                            return;
                        } else {
                            // Alt+ArrowUp/Down: Adjust content scale
                            if (e.key === 'ArrowUp') {
                                this.increaseContentScale();
                                this.announceToScreenReader(`Content scale increased to ${this.contentScale}%`);
                            } else {
                                this.decreaseContentScale();
                                this.announceToScreenReader(`Content scale decreased to ${this.contentScale}%`);
                            }
                            return;
                        }
                    }
    
                    switch(e.key.toLowerCase()) {
    
                        case 'a': // Toggle accessibility panel
    
                            e.preventDefault();
    
                            
    
                            this.togglePanel();
    
                            this.announceToScreenReader('Accessibility panel toggled');
    
                            return;
    
                        case 's': // Toggle seizure safe
    
                            e.preventDefault();
    
                            
    
                            const currentSeizureState = this.settings['seizure-safe'];
    
                            if (currentSeizureState) {
    
                                this.disableSeizureSafe();
    
                            } else {
    
                                this.enableSeizureSafe();
    
                            }
    
                            // Update toggle switch in panel
    
                            this.updateToggleSwitch('seizure-safe', !currentSeizureState);
    
                            const seizureStatus = !currentSeizureState ? 'enabled' : 'disabled';
    
                            this.announceToScreenReader(`Seizure safe mode ${seizureStatus}`);
    
                            return;
    
                        case 'v': // Toggle vision impaired
    
                            e.preventDefault();
    
                            
    
                            // Ensure setting exists
                            if (typeof this.settings['vision-impaired'] !== 'boolean') {
                                this.settings['vision-impaired'] = false;
                            }
    
                            const viCurrent = this.settings['vision-impaired'];
    
                            if (viCurrent) {
                                this.disableVisionImpaired();
                            } else {
                                this.enableVisionImpaired();
                            }

                            const viStatus = !viCurrent ? 'enabled' : 'disabled';
                            this.announceToScreenReader(`Vision impaired mode ${viStatus}`);
    
                            return;
    
                        case 'h': // Toggle ADHD friendly
    
                            e.preventDefault();
    
                            
    
                            const currentADHDState = this.settings['adhd-friendly'];
    
                            if (currentADHDState) {
    
                                this.disableADHDFriendly();
    
                            } else {
    
                                this.enableADHDFriendly();
    
                            }
    
                            // Update toggle switch in panel
    
                            this.updateToggleSwitch('adhd-friendly', !currentADHDState);
    
                            const adhdStatus = !currentADHDState ? 'enabled' : 'disabled';
    
                            this.announceToScreenReader(`ADHD friendly mode ${adhdStatus}`);
    
                            return;
    
                        case 'r': // Reset all settings
    
                            e.preventDefault();
    
                            
    
                            this.resetSettings();
    
                            // Update all toggle switches to off
    
                            this.updateAllToggleSwitches();
    
                            this.announceToScreenReader('All accessibility settings have been reset');
    
                            return;
    
                    }
    
                }
    
                
    
                // Escape key to close panel (works regardless of keyboard navigation setting)
    
                if (e.key === 'Escape') {
    
                    if (this.isPanelOpen) {
    
                        e.preventDefault();
    
                        
    
                        this.togglePanel();
    
                        this.announceToScreenReader('Accessibility panel closed');
    
                        return;
    
                    }
    
                }
    
                
    
                // Only activate keyboard navigation if enabled
    
                if (!this.settings['keyboard-nav']) {
    
                    
    
                    return;
    
                }
    
                
    
                // Check if user is typing in an input field
    
                const activeElement = document.activeElement;
    
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true')) {
    
                    
    
                    return; // Don't interfere with typing
    
                }
    
                
    
                // Single key navigation (no Alt/Ctrl needed)
    
                switch(e.key.toLowerCase()) {
    
                    case 'm': // Menus
    
                        e.preventDefault();
    
                        
    
                        this.cycleThroughElements('nav, [role="navigation"], .menu, .navbar', 'menu');
    
                        break;
    
                    case 'h': // Headings
    
                        e.preventDefault();
    
                        
    
                        this.cycleThroughElements('h1, h2, h3, h4, h5, h6', 'heading');
    
                        break;
    
                    case 'f': // Forms
    
                        e.preventDefault();
    
                        
    
                        this.cycleThroughElements('form, input, textarea, select, button[type="submit"]', 'form');
    
                        break;
    
                    case 'b': // Buttons
    
                        e.preventDefault();
    
                        
    
                        this.cycleThroughElements('button, .btn, input[type="button"], input[type="submit"]', 'button');
    
                        break;
    
                    case 'g': // Graphics
    
                        e.preventDefault();
    
                        
    
                        this.cycleThroughElements('img, svg, canvas, .image, .graphic', 'graphic');
    
                        break;
    
                    case 'l': // Links
    
                        e.preventDefault();
    
                        
    
                        this.cycleThroughElements('a[href], .link', 'link');
    
                        break;
    
                    case 's': // Skip to main content
    
                        e.preventDefault();
    
                        
    
                        this.focusElement('main, [role="main"], .main-content, #main');
    
                        break;
    
                    default:
    
                        // For any other key, just log it to see if the event listener is working
    
                        
    
                        break;
    
                }
    
            };
    
            
    
            // Add event listeners
    
            document.addEventListener('keydown', this.keyboardShortcutHandler);
            document.addEventListener('mousedown', this.mouseHandler);
            document.addEventListener('click', this.mouseHandler);
    
            
    
            
    
            // Test if event listener is working
    
            setTimeout(() => {
    
                
    
                // Simulate a key press to test
    
                const testEvent = new KeyboardEvent('keydown', { key: 'h' });
    
                document.dispatchEvent(testEvent);
    
            }, 1000);
    
        }
    
    
    
        removeKeyboardShortcuts() {
    
            if (this.keyboardShortcutHandler) {
    
                document.removeEventListener('keydown', this.keyboardShortcutHandler);
    
                this.keyboardShortcutHandler = null;
    
                
            }
    
            if (this.mouseHandler) {
    
                document.removeEventListener('mousedown', this.mouseHandler);
    
                document.removeEventListener('click', this.mouseHandler);
    
                this.mouseHandler = null;
    
                
    
            }
    
            
    
            // Remove all highlighted elements
    
            this.removeAllHighlights();
    
            
    
            // Reset element tracking
    
            this.currentElementIndex = {};
    
        }
    
    
    
        cycleThroughElements(selector, type) {
    
            
    
            
    
            // Remove previous highlights
    
            this.removeAllHighlights();
    
            
    
            // Get all matching elements
    
            const elements = Array.from(document.querySelectorAll(selector));
    
            
    
            
    
            if (elements.length === 0) {
    
                
    
                return;
    
            }
    
            
    
            // Get current index for this type
    
            const currentIndex = this.currentElementIndex[type] || 0;
    
            const element = elements[currentIndex];
    
            
    
            
    
            
    
            // Create highlight
    
            this.createHighlight(element, type, currentIndex + 1, elements.length);
    
            
    
            // Update index for next cycle
    
            this.currentElementIndex[type] = (currentIndex + 1) % elements.length;
    
            
    
            
    
        }
    
    
    
        createHighlight(element, type, current, total) {
    
            
    
            
    
            const rect = element.getBoundingClientRect();
    
            
    
            
    
            // Create highlight box
    
            const highlight = document.createElement('div');
    
            highlight.className = 'keyboard-highlight';
    
            highlight.style.cssText = `
    
                position: fixed;
    
                top: ${rect.top - 3}px;
    
                left: ${rect.left - 3}px;
    
                width: ${rect.width + 6}px;
    
                height: ${rect.height + 6}px;
    
                border: 3px solid #6366f1;
    
                border-radius: 6px;
    
                background: transparent;
    
                pointer-events: none;
    
                z-index: 2147483645;
    
                box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);
    
                transition: all 0.3s ease;
    
            `;
    
            
    
            // Create label
    
            const label = document.createElement('div');
    
            label.className = 'keyboard-highlight-label';
    
            label.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} ${current} of ${total}`;
    
            label.style.cssText = `
    
                position: fixed;
    
                top: ${rect.top - 35}px;
    
                left: ${rect.left}px;
    
                background: #6366f1;
    
                color: white;
    
                padding: 4px 8px;
    
                border-radius: 4px;
    
                font-size: 12px;
    
                font-weight: bold;
    
                white-space: nowrap;
    
                z-index: 2147483645;
    
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    
            `;
    
            
    
            // Add to page
            // CRITICAL: Use safeDOMOperation to prevent Designer DOM manipulation
            if (!this.safeDOMOperation(() => {
                document.body.appendChild(highlight);
                document.body.appendChild(label);
            }, 'createHighlight - append highlight elements')) {
                // Failed to append - Designer mode detected, clean up created elements
                return;
            }
    
            
    
            
    
            
    
            // Store references for removal
    
            this.highlightedElements.push(highlight, label);
    
            
    
            // Auto-remove after 3 seconds
    
            setTimeout(() => {
    
                this.removeAllHighlights();
    
            }, 3000);
    
        }
    
    
    
        removeAllHighlights() {
    
            if (this.highlightedElements && Array.isArray(this.highlightedElements)) {
    
            this.highlightedElements.forEach(element => {
    
                if (element && element.parentNode) {
    
                    element.parentNode.removeChild(element);
    
                }
    
            });
    
            }
    
            this.highlightedElements = [];
    
        }
    
    
    
        focusElement(selector) {
    
            const element = document.querySelector(selector);
    
            if (element) {
    
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
                element.focus();
    
                
    
            } else {
    
                
    
            }
    
        }
    
    
    
        addFontAwesome() {
            // CRITICAL: Don't manipulate Designer DOM
            if (this.isDesignerMode()) {
                return;
            }
    
            if (!document.querySelector('link[href*="font-awesome"]')) {
    
                const fontAwesome = document.createElement('link');
    
                fontAwesome.rel = 'stylesheet';
    
                fontAwesome.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css';
    
                document.head.appendChild(fontAwesome);
    
                
    
            }
    
        }
    
    
    
        addCSS() {
    
            // Check if CSS is already loaded
    
            if (!document.querySelector('link[href*="accessbit-widget.css"]')) {
    
                const link = document.createElement('link');
    
                link.rel = 'stylesheet';
    
                link.onload = () => {
                    
                    
    
                };
    
                link.onerror = () => {
    
                    
    
                };
    
                document.head.appendChild(link);
    
                // Add this after your existing CSS
    
                // Define overrideCSS first
                const overrideCSS = `
    .accessbit-widget-panel {
      /* Position controlled by JavaScript - no hardcoded positioning */
      left: auto;
      right: auto;
      top: auto;
      bottom: auto;
      transform: none;
    }
    
    /* REMOVED the conflicting accessbit-widget-icon rule that was forcing 50% border-radius */
    
    /* Icon Shape Rules - Simplified */
    .accessbit-widget-icon[data-shape="circle"] {
        border-radius: 50%;
    }
    
    .accessbit-widget-icon[data-shape="rounded"] {
        border-radius: 12px;
    }
    
    .accessbit-widget-icon[data-shape="square"] {
        border-radius: 0px;
    }
    
    /* Z-index hierarchy: Spotlight > Panel > Icon */
    .accessbit-widget-panel {
        position: fixed;
        z-index: 2147483646; /* Below spotlight, above icon */
        overflow-y: auto;
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        /* Position controlled by JavaScript - no default top/left to prevent top-left positioning */
        top: auto;
        left: auto;
        right: auto;
        bottom: auto;
    }
    
    .accessbit-widget-icon {
        z-index: 2147483645 !important; /* Below panel */
    }
    
    /* Spotlight should be above panel */
    #reading-mask-spotlight {
        z-index: 2147483647 !important; /* Highest - above panel */
    }
    
    /* Additional shape classes for compatibility */
    .accessbit-widget-icon.rounded {
        border-radius: 12px;
    }
    
    .accessbit-widget-icon.circle {
        border-radius: 50%;
    }
    
    .accessbit-widget-icon.square {
        border-radius: 0px;
    }
    
    /* Mobile-First Responsive Design */
    
    /* Very Small Mobile Screens (430px and below) */
    @media (max-width: 430px) {
        .accessbit-widget-panel {
            font-size: 12px;
        }
        
        .accessbit-widget-panel h2 {
            font-size: 1.3em;
        }
        
        .accessbit-widget-panel h3 {
            font-size: 1.1em;
        }
        
        .accessbit-widget-panel h4 {
            font-size: 0.9em;
        }
        
        .accessbit-widget-panel p {
            font-size: 0.8em;
        }
        
        .accessbit-widget-panel .action-btn {
            font-size: 0.8em;
            padding: 4px 8px;
        }
        
        .accessbit-widget-panel .scaling-btn {
            font-size: 0.7em;
            padding: 6px 20px;
            height: 28px;
            min-width: 80px;
            width: auto;
            white-space: nowrap;
            
            /* Ensure the percentage value + icon are perfectly centered */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
        }
        
        .accessbit-widget-panel .scaling-btn i.fas {
            /* Hide icon to avoid offsetting the +2% / -2% text horizontally,
               especially when Font Awesome is not loaded */
            display: none !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        
        .accessbit-widget-panel .profile-info h4 {
            font-size: 0.8em;
        }
        
        .accessbit-widget-panel .profile-info p {
            font-size: 0.7em;
        }
        
        .accessbit-widget-panel .profile-item h4 {
            font-size: 0.8em;
        }
        
        .accessbit-widget-panel .profile-item p {
            font-size: 0.7em;
        }
        
        .accessbit-widget-panel .close-btn {
            font-size: 16px;
            padding: 4px;
        }
    }
    
    /* Mobile Devices (Small Screens) - Base styles */
    @media (max-width: 480px) {
        .accessbit-widget-panel {
            width: 90vw;
            max-width: 350px;
            padding: 12px;
            font-size: 14px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        .accessbit-widget-panel h2 {
            margin-bottom: 8px;
            font-size: 1.5em;
        }
        
        .accessbit-widget-panel h3 {
            margin-bottom: 6px;
            font-size: 1.2em;
        }
        
        .accessbit-widget-panel h4 {
            font-size: 1em;
        }
        
        .accessbit-widget-panel p {
            line-height: 1.3;
            font-size: 0.9em;
        }
        
        .accessbit-widget-panel .action-btn {
            padding: 6px 10px;
            min-height: 28px;
            font-size: 0.9em;
        }
        
        .accessbit-widget-panel .scaling-btn {
            padding: 4px 6px;
            min-height: 24px;
            font-size: 0.8em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            font-size: 0.9em;
        }
        
        .accessbit-widget-panel .profile-info p {
            font-size: 0.8em;
        }
        
        .accessbit-widget-panel .profile-item h4 {
            font-size: 0.9em;
        }
        
        .accessbit-widget-panel .profile-item p {
            font-size: 0.8em;
        }
        
        .accessbit-widget-panel .close-btn {
            font-size: 18px;
            padding: 6px;
        }
        
        .accessbit-widget-icon {
            width: 45px;
            height: 45px;
            /* Position controlled by JS; do not force a corner here */
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
    }
    
    /* Landscape Phones & Smaller Portrait Tablets */
    @media (min-width: 481px) and (max-width: 1024px) {
        .accessbit-widget-panel {
            width: 90vw;
            max-width: 450px;
            padding: 14px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h2 {
            margin-bottom: 10px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h3 {
            margin-bottom: 8px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel p {
            line-height: 1.4;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .action-btn {
            padding: 8px 12px;
            min-height: 32px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .scaling-btn {
            padding: 5px 10px !important;
            min-height: 26px;
            /* Font size controlled by JavaScript */
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 4px !important;
            text-align: center !important;
        }
        
        .accessbit-widget-panel .scaling-btn span {
            display: flex;
            align-items: center;
            line-height: 1;
            margin: 0;
            padding: 0;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-info p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .close-btn {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-icon {
            width: 50px;
            height: 50px;
            /* Position controlled by JS */
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
    }
    
    /* Tablets (Portrait & Landscape) & Laptops */
    @media (min-width: 769px) and (max-width: 1024px) {
        .accessbit-widget-panel {
            width: 75vw;
            max-width: 520px;
            max-height: calc(100vh - 40px);
            padding: 20px;
            overflow-y: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            /* Position controlled by JavaScript - no default top/left */
            top: auto;
            left: auto;
            right: auto;
            bottom: auto;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h2 {
            margin-bottom: 12px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h3 {
            margin-bottom: 10px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel p {
            line-height: 1.5;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .action-btn {
            padding: 10px 14px;
            min-height: 36px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .scaling-btn {
            padding: 6px 10px;
            min-height: 28px;
            /* Font size controlled by JavaScript */
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 4px !important;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-info p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .close-btn {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-icon {
            width: 55px;
            height: 55px;
            /* Position controlled by JS */
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
    }
    
    /* Larger Displays (Desktops) */
    @media (min-width: 1012px) {
        .accessbit-widget-panel {
            width: 600px;
            max-width: 600px;
            max-height: calc(100vh - 40px);
            padding: 24px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h2 {
            margin-bottom: 14px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h3 {
            margin-bottom: 12px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel p {
            line-height: 1.6;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .action-btn {
            padding: 12px 16px;
            min-height: 40px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .scaling-btn {
            padding: 8px 12px;
            min-height: 32px;
            /* Font size controlled by JavaScript */
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 4px !important;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-info p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .close-btn {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-icon {
            width: 60px;
            height: 60px;
            /* Position controlled by JS */
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
    }
    
    /* Orientation-specific styles */
    @media (orientation: landscape) and (max-width: 768px) {
        .accessbit-widget-panel {
            width: 85vw;
            max-width: 400px;
            /* REMOVED: height: 100vh, top: 0, bottom: 0 - Panel should position relative to icon */
            overflow-y: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h2 {
            margin-bottom: 8px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h3 {
            margin-bottom: 6px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel p {
            line-height: 1.3;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .action-btn {
            padding: 6px 10px;
            min-height: 28px;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .scaling-btn {
            padding: 4px 6px;
            min-height: 24px;
            /* Font size controlled by JavaScript */
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 4px !important;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-info p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .close-btn {
            /* Font size controlled by JavaScript */
        }
    }
    
    /* High-resolution screens */
    @media (-webkit-min-device-pixel-ratio: 2),
           (min-resolution: 192dpi) {
        .accessbit-widget-icon {
            /* Ensure crisp rendering on high-DPI displays */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
    }
        
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .action-btn {
            padding: 8px 12px !important;
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .scaling-btn {
            padding: 4px 8px !important;
            /* Font size controlled by JavaScript */
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 4px !important;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-info p {
            /* Font size controlled by JavaScript */
        }
        
        /* Mobile shape adjustments */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px;
        }
    }
    
    /* Removed - replaced with mobile-first approach above */
        
        /* Medium toggles for medium mobile screens */
        .toggle-switch {
            width: 18px !important;
            height: 11px !important;
        }
        
        .toggle-switch .slider {
            width: 18px !important;
            height: 11px !important;
        }
        
        .toggle-switch .slider:before {
            width: 7px !important;
            height: 7px !important;
            left: 2px !important;
            bottom: 2px !important;
        }
        
        .toggle-switch input:checked + .slider:before {
            transform: translateX(26px) !important;
        }
        
        /* Medium profile items for medium mobile screens */
        .profile-item {
            padding: 3px !important;
            margin-bottom: 3px !important;
        }
        
        .profile-item h4 {
            /* Font size controlled by JavaScript */
            margin-bottom: 2px !important;
        }
        
        .profile-item p {
            /* Font size controlled by JavaScript */
            margin-bottom: 2px !important;
        }
        
        /* Medium close button for medium mobile screens */
        .close-btn {
            /* Font size controlled by JavaScript */
            padding: 10px !important;
            width: 40px !important;
            height: 40px !important;
            min-width: 40px !important;
            min-height: 40px !important;
        }
        
        /* Ensure rounded shape works on medium mobile */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px !important;
            -webkit-border-radius: 12px !important;
            -moz-border-radius: 12px !important;
        }
    }
    
    /* Small Mobile Screens (375px and below) */
    @media (max-width: 400px) {
        .accessbit-widget-panel {
            /* Font size controlled by JavaScript */
            padding: 8px;
            width: 90vw;
            max-width: 300px;
            height: 100vh;
            top: 0;
            bottom: 0;
            overflow-y: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */
            margin-bottom: 6px;
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */
            margin-bottom: 4px;
        }
        
        .accessbit-widget-panel .action-btn {
            /* Font size controlled by JavaScript */
            padding: 4px 6px;
            min-height: 24px;
        }
        
        .accessbit-widget-panel .scaling-btn {
            /* Font size controlled by JavaScript */
            padding: 2px 4px;
            min-height: 20px;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 4px !important;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-info p {
            /* Font size controlled by JavaScript */
        }
        
        /* Smaller toggles for small screens */
        .toggle-switch {
            width: 16px;
            height: 10px;
        }
        
        .toggle-switch .slider {
            width: 16px;
            height: 10px;
        }
        
        .toggle-switch .slider:before {
            width: 6px;
            height: 6px;
            left: 2px;
            bottom: 2px;
        }
        
        .toggle-switch input:checked + .slider:before {
            transform: translateX(6px);
        }
        
        /* Smaller profile items for small screens */
        .profile-item {
            padding: 2px;
            margin-bottom: 2px;
        }
        
        .profile-item h4 {
            /* Font size controlled by JavaScript */
            margin-bottom: 1px;
        }
        
        .profile-item p {
            /* Font size controlled by JavaScript */
            margin-bottom: 1px;
        }
        
        /* Smaller close button for small screens */
        .close-btn {
            /* Font size controlled by JavaScript */
            padding: 8px;
            width: 36px !important;
            height: 36px !important;
            min-width: 36px !important;
            min-height: 36px !important;
        }
        
        /* Ensure rounded shape works on small mobile */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px;
            -webkit-border-radius: 12px;
            -moz-border-radius: 12px;
        }
    }
    
    @media (max-width: 480px) {
        .accessbit-widget-panel {
            /* Font size controlled by JavaScript */ /* Override external 8px */
        }
        
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */ /* Override external 9px */
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */ /* Override external 8px */
        }
        
        /* Override external button size conflicts */
        .accessbit-widget-panel .action-btn {
            /* Font size controlled by JavaScript */
            padding: 6px 10px;
        }
        
        .accessbit-widget-panel .scaling-btn {
            /* Font size controlled by JavaScript */
            padding: 3px 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .accessbit-widget-panel .profile-info h4 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel .profile-info p {
            /* Font size controlled by JavaScript */
        }
        
        /* Ensure rounded shape works on small mobile */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px;
            -webkit-border-radius: 12px;
            -moz-border-radius: 12px;
        }
    }
    
    /* Override external panel positioning conflicts */
    .accessbit-widget-panel {
        /* Let JavaScript control positioning, not external CSS */
        left: auto;
        right: auto;
        top: auto;
        bottom: auto;
        transform: none;
    }
    
    /* ===== MOBILE RESPONSIVE - PANEL CLOSE TO ICON ===== */
    
    /* Removed - replaced with mobile-first approach above */
        
        /* Ensure rounded shape works on large tablets */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px !important;
            -webkit-border-radius: 12px !important;
            -moz-border-radius: 12px !important;
        }
        
        .accessbit-widget-icon {
            width: 55px !important;
            height: 55px !important;
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
        
        /* Better content spacing for large tablets */
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */
            margin-bottom: 14px !important;
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */
            margin-bottom: 12px !important;
        }
        
        .profile-item {
            padding: 12px !important;
            margin-bottom: 10px !important;
        }
        
        .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .action-btn {
            padding: 10px 14px !important;
            /* Font size controlled by JavaScript */
        }
    }
    
    /* Removed - replaced with mobile-first approach above */
        
        /* Ensure rounded shape works on tablets */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px !important;
            -webkit-border-radius: 12px !important;
            -moz-border-radius: 12px !important;
        }
        
        .accessbit-widget-icon {
            width: 50px !important;
            height: 50px !important;
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
    }
    
    /* iPad Mini and Tablet - Responsive sizing */
    @media (max-width: 819px) and (min-width: 769px) {
        .accessbit-widget-panel {
            width: 85vw;
            max-width: 450px;
            /* Font size controlled by JavaScript */
            padding: 16px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            position: fixed;
            z-index: 100001;
            /* Position controlled by JavaScript - no default top/left */
            top: auto;
            left: auto;
            right: auto;
            bottom: auto;
        }
        
        /* Ensure rounded shape works on iPad Mini */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px;
            -webkit-border-radius: 12px;
            -moz-border-radius: 12px;
        }
        
        .accessbit-widget-icon {
            width: 50px;
            height: 50px;
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
        
        /* Better content spacing for tablet */
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */
            margin-bottom: 12px;
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */
            margin-bottom: 10px;
        }
        
        .profile-item {
            padding: 10px;
            margin-bottom: 8px;
        }
        
        .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .action-btn {
            padding: 8px 12px;
            /* Font size controlled by JavaScript */
        }
    }
    
    /* Removed - replaced with mobile-first approach above */
        
        .accessbit-widget-icon {
            width: 45px !important;
            height: 45px !important;
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
        
        /* Reasonable text and toggles for mobile landscape */
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */
            margin-bottom: 10px !important;
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */
            margin-bottom: 8px !important;
        }
        
        .profile-item {
            padding: 6px !important;
            margin-bottom: 4px !important;
        }
        
        .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .action-btn {
            padding: 4px 6px !important;
            /* Font size controlled by JavaScript */
        }
        
        /* Much smaller action buttons for mobile landscape */
        .action-btn.reset-btn,
        .action-btn.statement-btn,
        .action-btn.hide-btn {
            padding: 3px 5px !important;
            /* Font size controlled by JavaScript */
            min-height: 20px !important;
        }
        
        .action-btn i {
            /* Font size controlled by JavaScript */
            margin-right: 2px !important;
        }
        
        /* Very small toggles for mobile landscape */
        .toggle-switch {
            width: 20px !important;
            height: 12px !important;
        }
        
        .toggle-switch .slider {
            width: 20px !important;
            height: 12px !important;
        }
        
        .toggle-switch .slider:before {
            height: 8px !important;
            width: 8px !important;
            left: 2px !important;
            bottom: 2px !important;
        }
        
        .toggle-switch input:checked + .slider:before {
            transform: translateX(26px) !important;
        }
    }
    
    /* Mobile Portrait - Reasonable text and toggles */
    @media (max-width: 480px) {
        .accessbit-widget-panel {
            width: 75vw !important;
            max-width: 320px !important;
            /* Font size controlled by JavaScript */
            padding: 12px !important;
            height: 100vh !important;
            top: 0 !important;
            bottom: 0 !important;
            overflow-y: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        .accessbit-widget-icon {
            width: 40px !important;
            height: 40px !important;
        }
        
        .accessbit-widget-icon i {
            /* Font size controlled by JavaScript */
        }
        
        /* Reasonable text and toggles for mobile portrait */
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */
            margin-bottom: 8px !important;
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */
            margin-bottom: 6px !important;
        }
        
        .profile-item {
            padding: 2px !important;
            margin-bottom: 2px !important;
        }
        
        .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .action-btn {
            padding: 2px 3px !important;
            /* Font size controlled by JavaScript */
        }
        
        /* EXTREMELY small action buttons for mobile portrait */
        .action-btn.reset-btn,
        .action-btn.statement-btn,
        .action-btn.hide-btn {
            padding: 1px 2px !important;
            /* Font size controlled by JavaScript */
            min-height: 12px !important;
        }
        
        .action-btn i {
            /* Font size controlled by JavaScript */
            margin-right: 1px !important;
        }
        
        /* TINY toggles for mobile portrait */
        .toggle-switch {
            width: 12px !important;
            height: 8px !important;
        }
        
        .toggle-switch .slider {
            width: 12px !important;
            height: 8px !important;
        }
        
        .toggle-switch .slider:before {
            height: 4px !important;
            width: 4px !important;
            left: 2px !important;
            bottom: 2px !important;
        }
        
        .toggle-switch input:checked + .slider:before {
            transform: translateX(26px) !important;
        }
    }
    
    /* ===== FORCE ROUNDED SHAPES - MAXIMUM AGGRESSIVE ===== */
    
    /* Removed conflicting shape styles */
    
    /* DEBUG: Add visual indicators for shape testing */
    .accessbit-widget-icon[data-shape="circle"]::after {
        content: "CIRCLE" !important;
        position: absolute !important;
        top: -20px !important;
        left: 0 !important;
        /* Font size controlled by JavaScript */
        color: red !important;
        background: yellow !important;
        z-index: 9999 !important;
    }
    
    .accessbit-widget-icon[data-shape="rounded"]::after {
        content: "ROUNDED" !important;
        position: absolute !important;
        top: -20px !important;
        left: 0 !important;
        /* Font size controlled by JavaScript */
        color: red !important;
        background: yellow !important;
        z-index: 9999 !important;
    }
    
    .accessbit-widget-icon[data-shape="square"]::after {
        content: "SQUARE" !important;
        position: absolute !important;
        top: -20px !important;
        left: 0 !important;
        /* Font size controlled by JavaScript */
        color: red !important;
        background: yellow !important;
        z-index: 9999 !important;
    }
    
    /* Removed conflicting media query rules */
    
    /* Removed ultimate override rules */
    
    /* Removed simple clean override rules */
    }
    
    /* Removed all conflicting shape override rules */
    
    /* ===== FORCE MOBILE STYLES - MAXIMUM AGGRESSIVE ===== */
    
    /* Removed - replaced with mobile-first approach above */
        
        .accessbit-widget-panel h2 {
            /* Font size controlled by JavaScript */
        }
        
        .accessbit-widget-panel h3 {
            /* Font size controlled by JavaScript */
        }
        
        /* Mobile shape adjustments */
        .accessbit-widget-icon[data-shape="rounded"] {
            border-radius: 12px;
        }
        
        .profile-item h4 {
            /* Font size controlled by JavaScript */
        }
        
        .profile-item p {
            /* Font size controlled by JavaScript */
        }
        
        .action-btn {
            /* Font size controlled by JavaScript */
            padding: 2px 3px !important;
        }
        
        .action-btn.reset-btn,
        .action-btn.statement-btn,
        .action-btn.hide-btn {
            /* Font size controlled by JavaScript */
            padding: 1px 2px !important;
            min-height: 12px !important;
        }
        
        .toggle-switch {
            width: 12px !important;
            height: 8px !important;
        }
        
        .toggle-switch .slider {
            width: 12px !important;
            height: 8px !important;
        }
        
        .toggle-switch .slider:before {
            width: 4px !important;
            height: 4px !important;
        }
        
        .toggle-switch input:checked + .slider:before {
            transform: translateX(26px) !important;
        }
    }
    
    .accessbit-widget-panel {
        display: none !important;
        position: fixed;
        z-index: 100001 !important;
        /* Position controlled by JavaScript - no default top/left */
        top: auto;
        left: auto;
        right: auto;
        bottom: auto;
    }
    
    .accessbit-widget-panel.show {
        display: block !important;
        visibility: visible !important;
    }
    
    /* Text Alignment CSS Rules - Safe approach for text content only */
    
    /* Left alignment - only for text elements */
    body.align-left h1,
    body.align-left h2,
    body.align-left h3,
    body.align-left h4,
    body.align-left h5,
    body.align-left h6,
    body.align-left p,
    body.align-left span,
    body.align-left a,
    body.align-left li,
    body.align-left td,
    body.align-left th,
    body.align-left label,
    body.align-left small,
    body.align-left em,
    body.align-left strong,
    body.align-left i,
    body.align-left b {
        text-align: left !important;
    }
    
    /* Center alignment - only for text elements */
    body.align-center h1,
    body.align-center h2,
    body.align-center h3,
    body.align-center h4,
    body.align-center h5,
    body.align-center h6,
    body.align-center p,
    body.align-center span,
    body.align-center a,
    body.align-center li,
    body.align-center td,
    body.align-center th,
    body.align-center label,
    body.align-center small,
    body.align-center em,
    body.align-center strong,
    body.align-center i,
    body.align-center b {
        text-align: center !important;
    }
    
    /* Right alignment - only for text elements */
    body.align-right h1,
    body.align-right h2,
    body.align-right h3,
    body.align-right h4,
    body.align-right h5,
    body.align-right h6,
    body.align-right p,
    body.align-right span,
    body.align-right a,
    body.align-right li,
    body.align-right td,
    body.align-right th,
    body.align-right label,
    body.align-right small,
    body.align-right em,
    body.align-right strong,
    body.align-right i,
    body.align-right b {
        text-align: right !important;
    }
    
    /* Exclude images, animations, and layout elements from text alignment */
    body.align-left img,
    body.align-left video,
    body.align-left canvas,
    body.align-left iframe,
    body.align-left svg,
    body.align-left [class*="animated"],
    body.align-left [class*="animation"],
    body.align-left [class*="motion"],
    body.align-left .container,
    body.align-left .wrapper,
    body.align-left .row,
    body.align-left .col,
    body.align-left .grid,
    body.align-left .flex,
    body.align-left [class*="container"],
    body.align-left [class*="grid"],
    body.align-left [class*="row"],
    body.align-left [class*="col"],
    body.align-center img,
    body.align-center video,
    body.align-center canvas,
    body.align-center iframe,
    body.align-center svg,
    body.align-center [class*="animated"],
    body.align-center [class*="animation"],
    body.align-center [class*="motion"],
    body.align-center .container,
    body.align-center .wrapper,
    body.align-center .row,
    body.align-center .col,
    body.align-center .grid,
    body.align-center .flex,
    body.align-center [class*="container"],
    body.align-center [class*="grid"],
    body.align-center [class*="row"],
    body.align-center [class*="col"],
    body.align-right img,
    body.align-right video,
    body.align-right canvas,
    body.align-right iframe,
    body.align-right svg,
    body.align-right [class*="animated"],
    body.align-right [class*="animation"],
    body.align-right [class*="motion"],
    body.align-right .container,
    body.align-right .wrapper,
    body.align-right .row,
    body.align-right .col,
    body.align-right .grid,
    body.align-right .flex,
    body.align-right [class*="container"],
    body.align-right [class*="grid"],
    body.align-right [class*="row"],
    body.align-right [class*="col"] {
        text-align: inherit !important;
    }
    
    /* Exclude accessibility widget from text alignment */
    body.align-left .accessbit-widget,
    body.align-left .accessbit-widget-panel,
    body.align-left .accessbit-widget-icon,
    body.align-left #accessbit-widget,
    body.align-left #accessbit-widget-panel,
    body.align-left #accessbit-widget-icon,
    body.align-left [data-ck-widget],
    body.align-left [class*="accessbit"],
    body.align-center .accessbit-widget,
    body.align-center .accessbit-widget-panel,
    body.align-center .accessbit-widget-icon,
    body.align-center #accessbit-widget,
    body.align-center #accessbit-widget-panel,
    body.align-center #accessbit-widget-icon,
    body.align-center [data-ck-widget],
    body.align-center [class*="accessbit"],
    body.align-right .accessbit-widget,
    body.align-right .accessbit-widget-panel,
    body.align-right .accessbit-widget-icon,
    body.align-right #accessbit-widget,
    body.align-right #accessbit-widget-panel,
    body.align-right #accessbit-widget-icon,
    body.align-right [data-ck-widget],
    body.align-right [class*="accessbit"] {
        text-align: inherit !important;
    }
    `;
    
                // Inject the override CSS
                const style = document.createElement('style');
                style.textContent = overrideCSS;
                document.head.appendChild(style);
                
                const overrideStyle = document.createElement('style');
                overrideStyle.textContent = overrideCSS;
                document.head.appendChild(overrideStyle);
                
    
            }
    
        }
    
    
    
        createWidget() {
    
            // Create widget container that will host the Shadow DOM
            
            const widgetContainer = document.createElement('div');
    
            widgetContainer.id = 'accessbit-widget-container';
    
            widgetContainer.style.cssText = `
    
                position: fixed;
    
                top: 0;
    
                left: 0;
    
                width: 100%;
    
                height: 100%;
    
                pointer-events: none;
    
                z-index: 2147483645 !important;
    
            `;
    
            // Append to documentElement instead of body to avoid transform issues
            // CRITICAL: Use safeDOMOperation to prevent Designer DOM manipulation
            if (!this.safeDOMOperation(() => {
                document.documentElement.appendChild(widgetContainer);
            }, 'createWidget - append widget container')) {
                // Failed to append - Designer mode detected
                return;
            }
    
    
    
            // Create Shadow DOM
    
            const shadowRoot = widgetContainer.attachShadow({ mode: 'open' });
    
            this.shadowRoot = shadowRoot;
    
    
    
            // Add CSS to Shadow DOM - ALWAYS load CSS with widget HTML
            // Use unique ID to prevent duplicate injection and ensure it's always present
            let style = shadowRoot.querySelector('style[data-widget-css="true"]');
            if (!style) {
                style = document.createElement('style');
                style.setAttribute('data-widget-css', 'true');
                style.setAttribute('id', 'accessbit-widget-styles');
                style.textContent = this.getWidgetCSS();
                // Insert CSS FIRST before any HTML elements to ensure it's always loaded
                shadowRoot.appendChild(style);
            } else {
                // If style exists but content might be missing, ensure it's populated
                if (!style.textContent || style.textContent.trim().length === 0) {
                    style.textContent = this.getWidgetCSS();
                }
            }
    
    
    
            // Create accessibility icon inside Shadow DOM with enhanced accessibility
    
            const icon = document.createElement('div');
    
            icon.id = 'accessbit-widget-icon';
            
            icon.className = 'accessbit-widget-icon';
    
            icon.setAttribute('role', 'button');
    
            icon.setAttribute('tabindex', '0');
    
            icon.setAttribute('aria-label', 'Open accessibility options');
    
            icon.setAttribute('aria-expanded', 'false');
    
            icon.setAttribute('aria-describedby', 'accessbit-widget-icon-description');
    
            icon.textContent = '';
            const iconElement = document.createElement('i');
            iconElement.className = 'fas fa-universal-access';
            iconElement.setAttribute('aria-hidden', 'true');
            icon.appendChild(iconElement);
            const descriptionSpan = document.createElement('span');
            descriptionSpan.id = 'accessbit-widget-icon-description';
            descriptionSpan.className = 'sr-only';
            descriptionSpan.textContent = 'Click to open accessibility settings panel';
            icon.appendChild(descriptionSpan);
    
            icon.style.pointerEvents = 'auto';
            
            // Initially hide the icon - will show after customization is loaded
            console.log('[ICON HIDE] createWidget() - Initially hiding icon (will show after customization loads)');
            icon.style.display = 'none';
            icon.style.visibility = 'hidden';
            icon.style.opacity = '0';
    
            shadowRoot.appendChild(icon);
    
            
    
    
    
            // Create panel inside Shadow DOM with enhanced accessibility
    
            const panel = document.createElement('div');
    
            panel.id = 'accessbit-widget-panel';
    
            panel.className = 'accessbit-widget-panel';
    
            panel.setAttribute('role', 'dialog');
    
            panel.setAttribute('aria-label', 'Accessibility Settings');
    
            panel.setAttribute('aria-hidden', 'true');
    
            panel.setAttribute('aria-modal', 'true');
    
            panel.setAttribute('aria-describedby', 'panel-description');
    
            this.createPanelElements(panel);
    
            panel.style.pointerEvents = 'auto';
    
            shadowRoot.appendChild(panel);
    
            
    
            
            // In your createWidget function, after creating the panel:
            panel.style.pointerEvents = 'auto';
            panel.style.display = 'none'; // Hide panel by default
            panel.style.visibility = 'hidden'; // Also hide with visibility
            shadowRoot.appendChild(panel);
            // Initialize current language display
    
            this.initializeLanguageDisplay();
    
            
    
            // Set up language selector header event listener
    
            const languageSelectorHeader = this.shadowRoot.getElementById('language-selector-header');
    
            if (languageSelectorHeader) {
    
                languageSelectorHeader.addEventListener('click', (e) => {
    
                    
    
                    e.preventDefault();
    
                    e.stopPropagation();
    
                    this.toggleLanguageDropdown();
    
                });
    
                // Add keyboard support for language selector
                languageSelectorHeader.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.toggleLanguageDropdown();
                    }
                });
    
                
    
            } else {
    
                
    
            }
    
            
    
            // Create language dropdown inside the panel
    
            const languageDropdown = document.createElement('div');
    
            languageDropdown.id = 'language-dropdown';
    
            languageDropdown.className = 'language-dropdown';
    
            languageDropdown.style.display = 'none';
    
            this.createLanguageDropdownElements(languageDropdown);
    
            // Append dropdown INSIDE the panel, not to shadowRoot
            panel.appendChild(languageDropdown);
    
            
    
            
    
            
    
            
    
            // Dropdown is ready for use
    
            
    
            // Set up language dropdown event listeners after dropdown is created
    
            this.setupLanguageDropdownListeners();
    
            
    
    
    
            // Create screen reader announcements container
    
            const srAnnouncements = document.createElement('div');
    
            srAnnouncements.id = 'sr-announcements';
    
            srAnnouncements.className = 'sr-only';
    
            srAnnouncements.setAttribute('aria-live', 'polite');
    
            srAnnouncements.setAttribute('aria-atomic', 'true');
    
            shadowRoot.appendChild(srAnnouncements);
    
            
    
            // Verify elements are in Shadow DOM
    
            setTimeout(() => {
    
                const iconCheck = shadowRoot.getElementById('accessbit-widget-icon');
    
                const panelCheck = shadowRoot.getElementById('accessbit-widget-panel');
    
                
    
                
    
                
    
                // Debug: Check panel visibility
    
                if (panelCheck) {
    
                    const computedStyle = window.getComputedStyle(panelCheck);
    
                    
    
                    
    
                    
    
                    
    
                    
    
                    
    
                }
    
            }, 100);
            
            // Setup hide interface modal after a short delay to ensure elements are ready
            setTimeout(() => {
                this.setupHideInterfaceModal();
            }, 200);

            // Vision Impaired: apply saved state and bind toggle inside Shadow DOM
            try {
                const viEnabled = localStorage.getItem('accessbit-widget-vision-impaired') === 'true';
                applyVisionImpaired(viEnabled);

                const bindVIToggle = () => {
                    const viToggle = this.shadowRoot && this.shadowRoot.getElementById('vision-impaired');
                    if (!viToggle || viToggle.__viBound) return;
                    try { viToggle.checked = viEnabled; } catch (_) {}
                    viToggle.addEventListener('change', () => {
                        const on = !!viToggle.checked;
                        localStorage.setItem('accessbit-widget-vision-impaired', on ? 'true' : 'false');
                        applyVisionImpaired(on);
                    });
                    viToggle.__viBound = true;
                };
                bindVIToggle();
                try {
                    const viObs = new MutationObserver(() => bindVIToggle());
                    viObs.observe(this.shadowRoot, { subtree: true, childList: true });
                    this.__viObs = viObs;
                } catch (_) {}
            } catch (_) {}
    
        }
    
    
    
        getWidgetCSS() {
    
            return `
            /* Import FontAwesome for icons */
            @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css');
            
            /* Force icon shape overrides - must come first */
            .accessbit-widget-icon {
                /* REMOVED empty rule that was potentially conflicting */
            }
            
            /* Override external CSS with maximum specificity */
            .accessbit-widget-icon[data-shape="circle"] {
                border-radius: 50% !important;
                -webkit-border-radius: 50% !important;
                -moz-border-radius: 50% !important;
            }
            
            .accessbit-widget-icon[data-shape="rounded"] {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            .accessbit-widget-icon[data-shape="square"] {
                border-radius: 0px !important;
                -webkit-border-radius: 0px !important;
                -moz-border-radius: 0px !important;
            }
            
            /* ULTRA-AGGRESSIVE OVERRIDE FOR ROUNDED SHAPE */
            .accessbit-widget-icon.rounded,
            .accessbit-widget-icon[data-shape="rounded"],
            .accessbit-widget-icon.rounded[data-shape="rounded"],
            .accessbit-widget-icon[data-shape="rounded"].rounded {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Force rounded shape with absolute maximum specificity */
            .accessbit-widget-icon.rounded[data-shape="rounded"] {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Override any external CSS that might be forcing circle shape */
            .accessbit-widget-icon[data-shape="rounded"]:not([data-shape="circle"]) {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Force rounded shape with absolute maximum specificity */
            .accessbit-widget-icon.rounded,
            .accessbit-widget-icon[data-shape="rounded"] {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Override any external CSS that might be forcing circle shape */
            .accessbit-widget-icon[data-shape="rounded"]:not([data-shape="circle"]) {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Maximum specificity override for rounded shape */
            .accessbit-widget-icon.rounded[data-shape="rounded"] {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Force rounded shape with absolute maximum specificity */
            .accessbit-widget-icon[data-shape="rounded"].rounded {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Override any external CSS with maximum force */
            .accessbit-widget-icon[data-shape="rounded"] {
                border-radius: 12px !important;
                -webkit-border-radius: 12px !important;
                -moz-border-radius: 12px !important;
            }
            
            /* Force panel positioning */
            .accessbit-widget-panel {
                position: fixed !important;
                z-index: 2147483646 !important;
                display: none !important; /* Hidden by default */
                background: #ffffff !important;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1) !important;
                border-radius: 8px !important;
                font-family: 'DM Sans', sans-serif !important;
                pointer-events: auto !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                -webkit-overflow-scrolling: touch !important;
                scroll-behavior: smooth !important;
                overscroll-behavior: contain !important;
                height: 100vh !important;
                top: 0 !important;
                bottom: 0 !important;
                word-wrap: break-word !important;
                word-break: break-word !important;
                overflow-wrap: break-word !important;
                hyphens: auto !important;
            }
            
            .accessbit-widget-panel.show {
                display: block !important;
                visibility: visible !important;
            }
            
            /* Default desktop panel styles */
            .accessbit-widget-panel {
                width: 600px !important;
                max-width: 600px !important;
                font-size: 16px !important;
                padding: 20px !important;
            }
            
            /* Mobile responsiveness - handled by main responsive CSS above */
            
            /* Responsive styles using CSS media queries - handles all screen sizes automatically */
            @media (max-width: 480px) {
                .accessbit-widget-icon {
                    width: 40px !important;
                    height: 40px !important;
                }
                
                .accessbit-widget-icon i {
                    font-size: 16px !important;
                }
                
                .accessbit-widget-panel {
                    width: 85vw !important;
                    max-width: 85vw !important;
                    /* left/right positioning handled by JavaScript based on icon position */
                    font-size: 10px !important;
                    padding: 8px !important;
                    box-sizing: border-box !important;
                    overflow-x: hidden !important;
                    margin: 0 !important;
                }
                
                .accessbit-widget-panel * {
                    box-sizing: border-box !important;
                }
                
                .accessbit-widget-panel h2 {
                    font-size: 14px !important;
                    margin-bottom: 8px !important;
                    line-height: 1.3 !important;
                }
                
                .accessbit-widget-panel h3 {
                    font-size: 11px !important;
                    margin-bottom: 6px !important;
                    line-height: 1.3 !important;
                }
                
                .accessbit-widget-panel h4 {
                    font-size: 10px !important;
                    line-height: 1.3 !important;
                }
                
                .accessbit-widget-panel p,
                .accessbit-widget-panel .profile-item p {
                    font-size: 9px !important;
                    line-height: 1.4 !important;
                    margin: 4px 0 !important;
                }
                
                .accessbit-widget-panel button,
                .accessbit-widget-panel .action-btn,
                .accessbit-widget-panel .profile-item button {
                    font-size: 9px !important;
                    padding: 6px 10px !important;
                    min-height: 32px !important;
                }
                
                .accessbit-widget-panel .profile-item {
                    padding: 8px !important;
                    margin-bottom: 6px !important;
                }
                
                .accessbit-widget-panel .toggle-switch {
                    width: 50px !important;
                    height: 24px !important;
                    min-width: 50px !important;
                    flex-shrink: 0 !important;
                }
                
                .accessbit-widget-panel .toggle-label {
                    width: 50px !important;
                    height: 24px !important;
                }
                
                .accessbit-widget-panel .toggle-switch .slider,
                .accessbit-widget-panel .toggle-label {
                    width: 50px !important;
                    height: 24px !important;
                }
                
                .accessbit-widget-panel .toggle-switch .slider::before,
                .accessbit-widget-panel .toggle-label::after {
                    width: 20px !important;
                    height: 20px !important;
                }
                
                /* Hide toggle text on mobile screens only */
                .accessbit-widget-panel .toggle-off,
                .accessbit-widget-panel .toggle-on,
                .accessbit-widget-panel .slider::after {
                    display: none !important;
                    visibility: hidden !important;
                    opacity: 0 !important;
                    font-size: 0 !important;
                    width: 0 !important;
                    height: 0 !important;
                    overflow: hidden !important;
                }
            }
            
            @media (min-width: 481px) and (max-width: 1024px) {
                .accessbit-widget-icon {
                    width: 45px !important;
                    height: 45px !important;
                }
                
                .accessbit-widget-icon i {
                    font-size: 18px !important;
                }
                
                .accessbit-widget-panel {
                    width: 90vw !important;
                    max-width: 450px !important;
                    /* left/right positioning handled by JavaScript based on icon position */
                    font-size: 11px !important;
                    padding: 10px !important;
                    box-sizing: border-box !important;
                    overflow-x: hidden !important;
                    margin: 0 !important; /* Remove auto margin - JavaScript handles positioning */
                }
                
                .accessbit-widget-panel * {
                    box-sizing: border-box !important;
                }
                
                .accessbit-widget-panel h2 {
                    font-size: 16px !important;
                    margin-bottom: 10px !important;
                    line-height: 1.3 !important;
                }
                
                .accessbit-widget-panel h3 {
                    font-size: 12px !important;
                    margin-bottom: 8px !important;
                    line-height: 1.3 !important;
                }
                
                .accessbit-widget-panel h4 {
                    font-size: 11px !important;
                    line-height: 1.3 !important;
                }
                
                .accessbit-widget-panel p,
                .accessbit-widget-panel .profile-item p {
                    font-size: 10px !important;
                    line-height: 1.4 !important;
                    margin: 5px 0 !important;
                }
                
                .accessbit-widget-panel button,
                .accessbit-widget-panel .action-btn,
                .accessbit-widget-panel .profile-item button {
                    font-size: 10px !important;
                    padding: 7px 12px !important;
                    min-height: 36px !important;
                }
                
                .accessbit-widget-panel .profile-item {
                    padding: 10px !important;
                    margin-bottom: 8px !important;
                }
                
                .accessbit-widget-panel .toggle-switch {
                    width: 42px !important;
                    height: 22px !important;
                    min-width: 42px !important;
                    flex-shrink: 0 !important;
                }
                
                .accessbit-widget-panel .toggle-label {
                    width: 42px !important;
                    height: 22px !important;
                }
                
                .accessbit-widget-panel .toggle-switch .slider,
                .accessbit-widget-panel .toggle-label {
                    width: 42px !important;
                    height: 22px !important;
                }
                
                .accessbit-widget-panel .toggle-switch .slider::before,
                .accessbit-widget-panel .toggle-label::after {
                    width: 18px !important;
                    height: 18px !important;
                }
                
                /* Fix toggle text to be horizontal (not vertical) on tablet - smaller to fit */
                .accessbit-widget-panel .toggle-off,
                .accessbit-widget-panel .toggle-on,
                .accessbit-widget-panel .slider::after {
                    writing-mode: horizontal-tb !important;
                    text-orientation: mixed !important;
                    white-space: nowrap !important;
                    font-size: 7px !important;
                    line-height: 1 !important;
                    display: block !important;
                    width: auto !important;
                    height: auto !important;
                    letter-spacing: -0.5px !important;
                    word-spacing: 0 !important;
                    text-align: center !important;
                    overflow: hidden !important;
                    text-overflow: clip !important;
                }
                
                .accessbit-widget-panel .toggle-off {
                    left: 7px !important;
                    right: auto !important;
                    top: 50% !important;
                    transform: translateY(-50%) !important;
                    max-width: 12px !important;
                }
                
                .accessbit-widget-panel .toggle-on {
                    right: 7px !important;
                    left: auto !important;
                    top: 50% !important;
                    transform: translateY(-50%) !important;
                    max-width: 12px !important;
                }
                
                .accessbit-widget-panel .slider::after {
                    left: 11px !important;
                    font-size: 7px !important;
                    max-width: 10px !important;
                }
                
                .accessbit-widget-panel input:checked + .slider::after {
                    right: 11px !important;
                    left: auto !important;
                    font-size: 7px !important;
                    max-width: 10px !important;
                }
                
                /* Adjust slider position for smaller size */
                .accessbit-widget-panel .toggle-label::after {
                    top: 2px !important;
                    left: 2px !important;
                }
                
                .accessbit-widget-panel .toggle-switch input[type="checkbox"]:checked + .toggle-label::after {
                    transform: translateX(20px) !important;
                }
            }
            
            @media (min-width: 769px) and (max-width: 1024px) {
                .accessbit-widget-icon {
                    width: 50px !important;
                    height: 50px !important;
                }
                
                .accessbit-widget-icon i {
                    font-size: 20px !important;
                }
                
                .accessbit-widget-panel {
                    width: 75vw !important;
                    max-width: 380px !important;
                    /* left/right positioning handled by JavaScript based on icon position */
                    font-size: 14px !important;
                    padding: 16px !important;
                }
            }
            
            @media (min-width: 1025px) and (max-width: 1366px) {
                .accessbit-widget-icon {
                    width: 55px !important;
                    height: 55px !important;
                }
                
                .accessbit-widget-icon i {
                    font-size: 22px !important;
                }
                
                .accessbit-widget-panel {
                    width: 65vw !important;
                    max-width: 450px !important;
                    font-size: 15px !important;
                    padding: 18px !important;
                }
            }
            
            @media (min-width: 1367px) {
                .accessbit-widget-icon {
                    width: 60px !important;
                    height: 60px !important;
                }
                
                .accessbit-widget-icon i {
                    font-size: 24px !important;
                }
                
                .accessbit-widget-panel {
                    width: 600px !important;
                    max-width: 600px !important;
                    font-size: 16px !important;
                    padding: 20px !important;
                }
            }
            
            /* Custom size classes - respect user customization while allowing CSS media queries to work */
            /* Desktop custom sizes */
            .accessbit-widget-icon.size-small {
                width: var(--custom-icon-size, 40px) !important;
                height: var(--custom-icon-size, 40px) !important;
            }
            
            .accessbit-widget-icon.size-medium {
                width: var(--custom-icon-size, 50px) !important;
                height: var(--custom-icon-size, 50px) !important;
            }
            
            .accessbit-widget-icon.size-large {
                width: var(--custom-icon-size, 60px) !important;
                height: var(--custom-icon-size, 60px) !important;
            }
            
            .accessbit-widget-icon.size-small i {
                font-size: var(--custom-icon-font-size, 16px) !important;
            }
            
            .accessbit-widget-icon.size-medium i {
                font-size: var(--custom-icon-font-size, 20px) !important;
            }
            
            .accessbit-widget-icon.size-large i {
                font-size: var(--custom-icon-font-size, 24px) !important;
            }
            
            /* Mobile custom sizes - override default mobile sizes when custom size is set */
            @media (max-width: 768px) {
                .accessbit-widget-icon.mobile-size-small {
                    width: var(--custom-mobile-icon-size, 35px) !important;
                    height: var(--custom-mobile-icon-size, 35px) !important;
                }
                
                .accessbit-widget-icon.mobile-size-medium {
                    width: var(--custom-mobile-icon-size, 45px) !important;
                    height: var(--custom-mobile-icon-size, 45px) !important;
                }
                
                .accessbit-widget-icon.mobile-size-large {
                    width: var(--custom-mobile-icon-size, 55px) !important;
                    height: var(--custom-mobile-icon-size, 55px) !important;
                }
                
                .accessbit-widget-icon.mobile-size-small i {
                    font-size: var(--custom-mobile-icon-font-size, 14px) !important;
                }
                
                .accessbit-widget-icon.mobile-size-medium i {
                    font-size: var(--custom-mobile-icon-font-size, 18px) !important;
                }
                
                .accessbit-widget-icon.mobile-size-large i {
                    font-size: var(--custom-mobile-icon-font-size, 22px) !important;
                }
            }
            
                /* Accessibility Widget Styles - Shadow DOM */
    
                :host {
    
                    position: fixed;
    
                    top: 0;
    
                    left: 0;
    
                    width: 100%;
    
                    height: 100%;
    
                    pointer-events: none;
    
                    z-index: 2147483645 !important;
    
                    isolation: isolate;
    
                    contain: layout style paint;
    
                }
    
    
    
                /* Ensure icon positioning is always fixed and not affected by host context */
    
                .accessbit-widget-icon {
    
                    position: fixed !important;
    
                    z-index: 2147483645 !important;
                    
                    /* Ensure JavaScript positioning takes precedence */
                    top: unset !important;
                    bottom: unset !important;
                    left: unset !important;
                    right: unset !important;
                    transform: unset !important;
    
                }
    
    
    
                /* Accessibility Icon - Visual styling */
    
                .accessbit-widget-icon {
    
                    width: 60px;
    
                    height: 60px;
    
                    background: #6366f1;
    
                    display: flex;
    
                    align-items: center;
    
                    justify-content: center;
    
                    cursor: pointer;
    
                    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    
                    transition: all 0.3s ease;
    
                    pointer-events: auto;
    
                    z-index: 2147483645 !important;
    
                }
    
    
    
                .accessbit-widget-icon:hover {
    
                    transform: scale(1.05);
    
                    background: #4f46e5;
    
                }
    
    
    
                .accessbit-widget-icon i {
                    color: #ffffff;
                    font-size: 24px;
                }
                
                /* Custom size classes - respect user customization while allowing CSS media queries to work */
                /* Desktop custom sizes - only apply when not on mobile */
                .accessbit-widget-icon.size-small:not([data-mobile-size]) {
                    width: var(--custom-icon-size, 40px) !important;
                    height: var(--custom-icon-size, 40px) !important;
                }
                
                .accessbit-widget-icon.size-medium:not([data-mobile-size]) {
                    width: var(--custom-icon-size, 50px) !important;
                    height: var(--custom-icon-size, 50px) !important;
                }
                
                .accessbit-widget-icon.size-large:not([data-mobile-size]) {
                    width: var(--custom-icon-size, 60px) !important;
                    height: var(--custom-icon-size, 60px) !important;
                }
                
                .accessbit-widget-icon.size-small:not([data-mobile-size]) i {
                    font-size: var(--custom-icon-font-size, 16px) !important;
                }
                
                .accessbit-widget-icon.size-medium:not([data-mobile-size]) i {
                    font-size: var(--custom-icon-font-size, 20px) !important;
                }
                
                .accessbit-widget-icon.size-large:not([data-mobile-size]) i {
                    font-size: var(--custom-icon-font-size, 24px) !important;
                }
                
                /* Mobile custom sizes - only apply on mobile */
                @media (max-width: 768px) {
                    .accessbit-widget-icon[data-mobile-size="small"] {
                        width: var(--custom-mobile-icon-size, 35px) !important;
                        height: var(--custom-mobile-icon-size, 35px) !important;
                    }
                    
                    .accessbit-widget-icon[data-mobile-size="medium"] {
                        width: var(--custom-mobile-icon-size, 45px) !important;
                        height: var(--custom-mobile-icon-size, 45px) !important;
                    }
                    
                    .accessbit-widget-icon[data-mobile-size="large"] {
                        width: var(--custom-mobile-icon-size, 55px) !important;
                        height: var(--custom-mobile-icon-size, 55px) !important;
                    }
                    
                    .accessbit-widget-icon[data-mobile-size="small"] i {
                        font-size: var(--custom-mobile-icon-font-size, 14px) !important;
                    }
                    
                    .accessbit-widget-icon[data-mobile-size="medium"] i {
                        font-size: var(--custom-mobile-icon-font-size, 18px) !important;
                    }
                    
                    .accessbit-widget-icon[data-mobile-size="large"] i {
                        font-size: var(--custom-mobile-icon-font-size, 22px) !important;
                    }
                }
    
    
    
                /* CRITICAL: Focus indicators for keyboard navigation in Shadow DOM */
    
                .accessbit-widget-icon:focus {
    
                    
                }
    
                /* Allow focus indicators when highlight-focus is active */
                body.highlight-focus .accessbit-widget-icon:focus {
                    outline: 3px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    background: rgba(99, 102, 241, 0.1) !important;
                    border-radius: 4px !important;
                    transition: outline 0.2s ease, background 0.2s ease !important;
                }
                
                /* Additional focus styles for accessibility icon when keyboard navigation is active */
                body.highlight-focus #accessbit-widget-icon:focus {
                    outline: 3px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    background: rgba(99, 102, 241, 0.1) !important;
                    border-radius: 4px !important;
                    transition: outline 0.2s ease, background 0.2s ease !important;
                    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3) !important;
                }
    
    
    
                /* Focus indicators for all interactive elements */
    
                input:focus-visible,
    
                button:focus-visible,
    
                select:focus-visible,
    
                label:focus-visible {
                    outline: 2px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2) !important;
                }
                
                .action-btn:focus-visible {
                    outline: 2px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2) !important;
                    padding: 8px 16px !important;
                    min-height: auto !important;
                    transform: none !important;
                }
    
                /* Ensure icons inside scaling buttons align properly */
                .scaling-btn {
                    text-align: center !important;
                    line-height: 1.2 !important;
                    height: auto !important;
                    white-space: nowrap !important;
                    padding: 5px 10px !important;
                }
                
                .scaling-btn i.fas {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    line-height: 1;
                    flex-shrink: 0;
                    margin: 0;
                    padding: 0;
                }
                
                .scaling-btn span {
                    display: inline;
                    line-height: 1;
                    margin: 0;
                    padding: 0;
                }
                
                /* Removed vertical-align - it interferes with flex alignment */
                
                .scaling-btn:focus-visible,
    
                .close-btn:focus-visible,
    
                .language-selector-header:focus-visible,
                .language-option:focus-visible {
    
            
                 outline: 2px solid #6366f1 !important;
                 outline-offset: 2px !important;
                 box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2) !important;   
    
                }
    
                /* Suppress focus ring for mouse interactions */
                *:focus:not(:focus-visible) {
                    outline: none !important;
                    box-shadow: none !important;
                }
    
                /* Prevent container focus outlines that span the dropdown */
                .language-dropdown:focus-visible,
                .language-dropdown-content:focus-visible {
                    outline: none !important;
                    box-shadow: none !important;
                }
    
                /* Clip any child outlines to dropdown bounds */
                .language-dropdown,
                .language-dropdown-content {
                    overflow: hidden !important;
                    border-radius: 8px !important;
                }
    
                /* Keep option focus ring tight to the option */
                .language-option:focus-visible {
                    outline-offset: -2px !important;
                    border-radius: 8px !important;
                }
    
    
    
                .toggle-switch input:focus + .slider {
    
                     outline: none !important;
                }
                
                /* Override for accessibility icon to show focus when keyboard navigation is active */
                body.highlight-focus .accessbit-widget-icon:focus,
                body.highlight-focus #accessbit-widget-icon:focus {
                    outline: 3px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    background: rgba(99, 102, 241, 0.1) !important;
                    border-radius: 4px !important;
                    transition: outline 0.2s ease, background 0.2s ease !important;
                    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3) !important;
                }
    
    
    
                /* Focus indicator for profile items (entire feature row) */
    
                .profile-item:focus,
    
                .profile-item:focus-within {
    
                    outline: 3px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    background: rgba(99, 102, 241, 0.1) !important;
                    border-radius: 4px !important;
                    transition: outline 0.2s ease, background 0.2s ease !important;
                }
    
    
    
                .profile-item:focus {
    
                   outline: 3px solid #6366f1 !important;
                   outline-offset: 2px !important;
                   background: rgba(99, 102, 241, 0.1) !important;
                   border-radius: 4px !important;
                   transition: outline 0.2s ease, background 0.2s ease !important;
                }
    
    
    
                /* Screen reader only content */
    
                .sr-only {
    
                    position: absolute !important;
    
                    width: 1px !important;
    
                    height: 1px !important;
    
                    padding: 0 !important;
    
                    margin: -1px !important;
    
                    overflow: hidden !important;
    
                    clip: rect(0, 0, 0, 0) !important;
    
                    white-space: nowrap !important;
    
                    border: 0 !important;
    
                }
    
    
    
                /* Focus indicators for keyboard navigation */
    
                .accessbit-widget-icon:focus,
    
                .accessbit-widget-panel button:focus,
    
                .accessbit-widget-panel input:focus,
    
                .accessbit-widget-panel label:focus {
    
                    
                    outline-offset: 0px !important;
                    box-shadow: none !important;
    
                }
    
                /* Allow focus indicators when highlight-focus is active (document scope) */
                body.highlight-focus .accessbit-widget-icon:focus,
                body.highlight-focus .accessbit-widget-panel button:focus,
                body.highlight-focus .accessbit-widget-panel input:focus,
                body.highlight-focus .accessbit-widget-panel label:focus {
                    outline: 3px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    background: rgba(99, 102, 241, 0.1) !important;
                    border-radius: 4px !important;
                    transition: outline 0.2s ease, background 0.2s ease !important;
                }
    
                /* Ensure focus styles work inside Shadow DOM when body has highlight-focus */
                :host-context(.highlight-focus) #accessbit-widget-icon:focus,
                :host-context(.highlight-focus) .accessbit-widget-icon:focus,
                :host-context(.highlight-focus) .accessbit-widget-panel button:focus,
                :host-context(.highlight-focus) .accessbit-widget-panel input:focus,
                :host-context(.highlight-focus) .accessbit-widget-panel label:focus {
                    outline: 3px solid #6366f1 !important;
                    outline-offset: 2px !important;
                    background: rgba(99, 102, 241, 0.1) !important;
                    border-radius: 4px !important;
                    transition: outline 0.2s ease, background 0.2s ease !important;
                }
    
                /* High contrast focus for better visibility */
    
                .accessbit-widget-icon:focus-visible,
    
                .accessbit-widget-panel button:focus-visible,
    
                .accessbit-widget-panel input:focus-visible {
    
                    
    
                }
    
    
    
                /* Accessibility Panel - Fixed position on right side */
    
                .accessbit-widget-panel {
    
                    /* REMOVED: position: fixed; - This was preventing widget from scrolling with viewport */
    
                    width: 500px !important;
    
                    /* Desktop: Allow panel to expand to fit content, with max-height for very tall screens */
                    height: auto !important;
                    min-height: 400px !important;
                    max-height: 90vh !important;
    
                    background: #ffffff !important;
    
                    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1) !important;
                    
                    /* Fix scrolling conflicts with GSAP/Lenis libraries */
                    overflow-y: auto !important;
                    overflow-x: hidden !important;
                    scroll-behavior: smooth !important;
                    -webkit-overflow-scrolling: touch !important;
                    overscroll-behavior: contain !important;
                }
                
                /* Override GSAP/Lenis smooth scrolling for accessibility panel */
                .accessbit-widget-panel * {
                    scroll-behavior: auto !important;
                }
                
                /* Ensure panel content is always scrollable */
                .accessbit-widget-panel .panel-content {
                    overflow-y: auto !important;
                    -webkit-overflow-scrolling: touch !important;
                }
    
                .accessbit-widget-panel.active {
    
                    display: block !important;
    
                    visibility: visible !important;
    
                    opacity: 1 !important;
    
                }
    
                
    
                /* Responsive Design - handled by main responsive CSS above */
                    /* Position controlled by JavaScript - removed hardcoded left positioning */
                }
    
                
    
                @media (max-width: 480px) {
    
                    .accessbit-widget-icon {
    
                        width: 45px !important;
    
                        height: 45px !important;
    
                        /* Position controlled by JS; do not force a corner here */
    
                    }
    
                    
    
                    .accessbit-widget-icon i {
    
                        /* Font size controlled by JavaScript */
    
                    }
    
                    
    
                    .accessbit-widget-panel {
    
                        width: 500px !important;
    
                        margin: 0 10px !important;
    
                        height: 700px !important;
    
                    }
    
                    
    
                    .accessbit-widget-panel.active {
                        /* Position controlled by JavaScript - removed hardcoded left positioning */
                    }
    
                }
    
    
    
                /* Panel Header */
    
                .panel-header {
    
                    display: flex;
    
                    flex-direction: column;
    
                    padding: 10px 20px 30px 20px;
    
                    background: transparent !important;
    
                    color: #ffffff !important;
    
                    border-radius: 24px !important;
    
                    border: 4px solid #ffffff !important;
    
                    border-bottom: none !important;
    
                    position: relative;
    
                    z-index: 1002;
    
                    overflow: hidden;
    
                    min-height: 210px;
    
                }
    
    
    
                .panel-header::before {
    
                    content: '';
    
                    position: absolute;
    
                    top: 2px;
    
                    left: 4px;
    
                    right: 4px;
    
                    bottom: 0;
    
                    background: linear-gradient(135deg, #262E84, #2AA2F1);
    
                    border-radius: 16px 16px 0 0;
    
                    z-index: -1;
    
                }
    
    
    
                .close-btn {
    
                    cursor: pointer !important;
    
                    font-size: 24px;
    
                    padding: 12px !important;
    
                    position: absolute !important;
    
                    top: 0px !important;
    
                    left: 6px !important;
    
                    z-index: 1005 !important;
    
                    background: transparent !important;
    
                    border: none !important;
    
                    color: white;
    
                    /* Increased clickable area */
                    width: 48px !important;
                    height: 48px !important;
                    min-width: 48px !important;
                    min-height: 48px !important;
                    max-width: 48px !important;
                    max-height: 48px !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    box-sizing: border-box !important;
                    margin: 0 !important;
                    outline: none !important;
                    border-radius: 8px !important;
                    transition: background-color 0.2s ease !important;
                    
                    /* Ensure the entire button area is clickable */
                    position: relative !important;
                    overflow: visible !important;
    
                }
    
    
    
                .close-btn:hover {
    
                    color: white;
                    background-color: rgba(255, 255, 255, 0.1) !important;
    
                }
    
                /* Ensure entire close button area is clickable */
                .close-btn * {
                    pointer-events: none !important;
                }
    
                .close-btn {
                    pointer-events: auto !important;
                    cursor: pointer !important;
                }
                
                /* Make sure the button itself captures all clicks */
                .close-btn::before,
                .close-btn::after {
                    pointer-events: none !important;
                }
                
                /* Ensure the button background captures all clicks */
                .close-btn {
                    background-color: transparent !important;
                    background-image: none !important;
                }
                
                /* Make sure no child elements interfere with clicks */
                .close-btn i,
                .close-btn span,
                .close-btn div {
                    pointer-events: none !important;
                    user-select: none !important;
                    position: relative !important;
                    z-index: 2 !important;
                }
                
                /* Create a full-coverage clickable area */
                .close-btn::before {
                    content: '' !important;
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    bottom: 0 !important;
                    width: 100% !important;
                    height: 100% !important;
                    pointer-events: auto !important;
                    z-index: 1 !important;
                }
    
    
    
                .header-content {
    
                    display: flex;
    
                    flex-direction: column;
    
                    align-items: center;
    
                    gap: 15px;
    
                    margin-top: 10px;
    
                    position: relative;
    
                    z-index: 1005;
    
                }
    
    
    
    
    
                /* Panel Content */
    
                .accessbit-widget-panel h2 {
    
                    text-align: center;
    
                    margin: 0 0 10px 0;
    
                    color: #ffffff;
    
                    font-family: 'DM Sans', sans-serif;
    
                    font-weight: 600;
    
                    font-style: normal;
    
                    font-size: 24px;
    
                    line-height: 100%;
    
                    letter-spacing: -0.03em;
    
                    position: relative;
    
                    z-index: 1005;
    
                }
    
                
    
                /* Profile descriptions - ensure text wraps properly */
    
                .profile-description {
    
                    word-wrap: break-word;
    
                    word-break: break-word;
    
                    overflow-wrap: break-word;
    
                    hyphens: auto;
    
                    line-height: 1.4;
    
                    margin: 8px 0;
    
                }
    
                
    
                .profile-description p {
    
                    margin: 4px 0;
    
                    font-size: 13px;
    
                    color: #64748b;
    
                }
                
                .profile-item small {
                    font-size: 12px;
                    font-weight: normal;
                }
    
                
    
                /* Ensure profile items don't overflow */
    
                .profile-item {
    
                    word-wrap: break-word !important;
    
                    overflow-wrap: break-word !important;
                    
                    word-break: break-word !important;
                    
                    hyphens: auto !important;
    
                }
    
                
    
                .profile-info {
    
                    flex: 1;
    
                    min-width: 0; /* Allow flex item to shrink */
    
                }
    
                
    
                .profile-info div {
    
                    min-width: 0; /* Allow text to wrap */
                    
                    word-wrap: break-word !important;
                    
                    word-break: break-word !important;
                    
                    overflow-wrap: break-word !important;
                    
                    hyphens: auto !important;
    
                }
    
    
    
                .action-buttons {
    
                    display: flex;
    
                    flex-direction: column;
    
                    gap: 10px;
    
                    justify-content: center;
    
                    align-items: center;
    
                }
    
    
    
                .button-row {
    
                    display: flex;
    
                    flex-direction: row;
    
                    gap: 10px;
    
                    justify-content: center;
    
                    align-items: center;
    
                }
    
    
    
                .action-btn {
    
                    display: flex;
    
                    align-items: center;
    
                    gap: 8px;
    
                    padding: 8px 16px;
    
                    background: rgba(217, 217, 217, 0.3) !important;
    
                    border: 2px solid rgba(217, 217, 217, 0.3) !important;
    
                    color: #ffffff !important;
    
                    border-radius: 30px;
    
                    cursor: pointer;
    
                    font-weight: 600;
    
                    transition: all 0.3s ease;
    
                    white-space: nowrap;
    
                    font-size: 12px;
    
                    justify-content: center;
    
                }
    
    
    
                .action-btn:hover {
    
                    background: #6366f1;
    
                    color: #ffffff;
    
                    transform: translateY(-1px);
    
                    box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
    
                }
    
    
    
                /* White Content Section */
    
                .white-content-section {
    
                    padding: 0 20px 20px;
    
                    background: #ffffff !important;
    
                    border-radius: 40px 40px 0 0 !important;
    
                    margin-top: -30px !important;
    
                    position: relative;
    
                    z-index: 1003;
    
                    padding-top: 12px;
    
                }
    
    
    
                .white-content-section h3 {
    
                    color: #334155;
    
                    margin-top: 12px;
    
                    margin-bottom: 12px;
    
                    font-size: 18px;
    
                    font-weight: 600;
    
                    text-align: center;
    
                }
    
    
    
                .profile-item {
    
                    display: flex;
    
                    flex-direction: row;
    
                    align-items: center;
    
                    padding: 15px;
    
                    background: transparent;
    
                    border-radius: 0;
    
                    margin-bottom: 0;
    
                    transition: all 0.3s ease;
    
                    border: none;
    
                    border-top: 1px solid #e2e8f0;
    
                    border-bottom: 1px solid #e2e8f0;
    
                    min-height: 60px;
    
                    gap: 12px;
    
                }
    
    
    
                .profile-item:first-child {
    
                    border-top: 1px solid #e2e8f0;
    
                }
    
    
    
                .profile-item:hover {
    
                    background: rgba(99, 102, 241, 0.05);
    
                    border-top-color: #e2e8f0;
    
                    border-bottom-color: #e2e8f0;
    
                    transform: translateX(2px);
    
                    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
    
                }
    
    
    
                .profile-info {
    
                    display: flex;
    
                    flex-direction: column;
    
                    flex: 1;
    
                    min-width: 0;
    
                    order: 2;
    
                }
    
    
    
                .profile-info i {
    
                    font-size: 20px;
    
                    color: #6366f1;
    
                    width: 24px;
    
                    flex-shrink: 0;
    
                }
    
    
    
                .profile-info h4 {
    
                    margin: 0;
    
                    font-size: 16px;
    
                    color: #334155;
    
                    font-weight: 600;
    
                    white-space: normal !important;
    
                    overflow: visible !important;
    
                    text-overflow: unset !important;
                    
                    word-wrap: break-word !important;
                    
                    word-break: break-word !important;
                    
                    overflow-wrap: break-word !important;
                    
                    hyphens: auto !important;
    
                }
    
    
    
                .profile-info p {
    
                    margin: 5px 0 0 !important;
    
                    font-size: 14px;
    
                    color: #64748b;
    
                    white-space: normal !important;
    
                    overflow: visible !important;
    
                    text-overflow: unset !important;
                    
                    word-wrap: break-word !important;
                    
                    word-break: break-word !important;
                    
                    overflow-wrap: break-word !important;
                    
                    hyphens: auto !important;
    
                }
    
    
    
                .profile-info small {
    
                    display: block;
    
                    margin: 3px 0 0;
    
                    font-size: 12px;
    
                    color: #6366f1;
    
                    font-style: italic;
    
                    white-space: nowrap;
    
                    overflow: hidden;
    
                    text-overflow: ellipsis;
    
                }
    
    
    
                /* Toggle Switch */
    
                .toggle-switch {
    
                    position: relative;
    
                    display: inline-block;
    
                    width: 80px !important;
    
                    height: 40px !important;
    
                    flex-shrink: 0;
    
                }
    
    
    
                .toggle-switch input {
    
                    opacity: 0;
    
                    width: 0;
    
                    height: 0;
    
                }
    
    
    
                .slider {
    
                    position: absolute;
    
                    cursor: pointer;
    
                    top: 0;
    
                    left: 0;
    
                    right: 0;
    
                    bottom: 0;
    
                    background-color: #e5e7eb;
    
                    transition: 0.3s;
    
                    border-radius: 20px !important;
    
                }
    
    
    
                .slider:before {
    
                    position: absolute;
    
                    content: "";
    
                    height: 32px;
    
                    width: 32px;
    
                    left: 4px;
    
                    bottom: 4px;
    
                    background-color: #ffffff;
    
                    transition: 0.3s;
    
                    /* border-radius: 50%; REMOVED - conflicts with shape settings */
    
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    
                }
    
    
    
                input:checked + .slider {
    
                    background-color: #e5e7eb !important;
    
                }
    
    
    
                input:checked + .slider:before {
    
                    transform: translateX(26px) !important;
    
                }
    
    
    
                /* Toggle Switch Text Labels */
    
                .slider::after {
    
                    content: "OFF";
    
                    position: absolute;
    
                    top: 50%;
    
                    left: 20px; /* Position relative to knob center */
    
                    transform: translateY(-50%) translateX(-50%);
    
                    font-size: 12px;
    
                    font-weight: bold;
    
                    color: #374151;
    
                    pointer-events: none;
    
                    transition: 0.3s;
    
                    font-family: 'DM Sans', sans-serif;
                    
                    /* Ensure text is always horizontal */
                    writing-mode: horizontal-tb !important;
                    text-orientation: mixed !important;
                    white-space: nowrap !important;
                    letter-spacing: 0 !important;
                    word-spacing: 0 !important;
    
                }
    
    
    
                .slider:before {
    
                    position: absolute;
    
                    content: "";
    
                    height: 32px;
    
                    width: 50px;
    
                    left: 4px;
    
                    bottom: 4px;
    
                    background-color: #ffffff;
    
                    transition: 0.3s;
    
                    border-radius: 16px;
    
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    
                    display: flex;
    
                    align-items: center;
    
                    justify-content: center;
    
                    font-size: 12px;
    
                    font-weight: bold;
    
                    color: #374151;
    
                    font-family: 'DM Sans', sans-serif;
    
                }
    
    
    
                input:checked + .slider::after {
    
                    content: "ON";
    
                    color: white;
    
                    left: auto;
    
                    right: 20px; /* Position relative to knob center */
                    
                    transform: translateY(-50%) translateX(50%);
    
                }
    
    
    
                input:checked + .slider:before {
    
                    background-color: #4F46E5;
    
                    color: white;
    
                }
    
    
    
                /* Panel Footer */
    
                .panel-footer {
    
                    position: sticky;
    
                    bottom: 0;
    
                    background: linear-gradient(135deg, #262E84, #2AA2F1) !important;
    
                    color: #ffffff;
    
                    padding: 15px 20px;
    
                    display: flex;
    
                    justify-content: center;
    
                    align-items: center;
    
                    font-size: 14px;
    
                    border-radius: 0 0 8px 8px !important;
    
                    z-index: 1001;
    
                }
    
    
    
                .panel-footer .learn-more {
    
                    color: #ffffff;
    
                    text-decoration: none;
    
                    font-weight: 600;
    
                }
    
    
    
                /* Language Selector Header Styles */
    
                .language-selector-header {
    
                    display: flex;
    
                    align-items: center;
    
                    gap: 6px;
    
                    cursor: pointer;
    
                    padding: 6px 10px;
    
                    border-radius: 6px;
    
                    transition: background-color 0.2s ease;
    
                    color: #ffffff;
    
                    font-size: 12px;
    
                    font-weight: 500;
    
                    position: absolute;
    
                    top: 5px;
    
                    right: 10px;
    
                    z-index: 1002;
    
                }
    
    
    
                .language-selector-header:hover {
    
                    background: rgba(255, 255, 255, 0.1);
    
                }
    
    
    
                .language-selector-header .current-flag {
    
                    font-size: 16px;
    
                }
    
    
    
                .language-selector-header i.fa-chevron-down {
    
                    font-size: 10px;
    
                    transition: transform 0.2s ease;
    
                    opacity: 0.8;
    
                }
    
    
    
                .language-selector-header:hover i.fa-chevron-down {
    
                    transform: translateY(1px);
    
                }
    
    
    
                /* Language Dropdown Styles */
    
                .language-dropdown {
    
                    position: sticky !important;
                    top: 0 !important;
    
                    /* Keep dropdown in panel viewport when scrolling */
                    position: fixed !important;
    
                    background: #ffffff !important;
    
                    border-radius: 12px !important;
    
                    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1) !important;
    
                    border: 1px solid #e5e7eb !important;
    
                    z-index: 100001 !important;
    
                    width: 400px !important;
    
                    max-height: 400px !important;
    
                    overflow-y: auto !important;
    
                    overflow-x: hidden !important;
    
                    animation: dropdownSlideIn 0.2s ease-out !important;
    
                    /* transform: none !important; - REMOVED: This was causing elements to snap to initial positions */
    
                    clip: none !important;
    
                    display: none !important;
    
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
    
                    pointer-events: auto !important;
    
                    /* Ensure dropdown is positioned relative to panel */
    
                    margin: 0 !important;
    
                    padding: 0 !important;
    
                }
    
                
    
                /* Force dropdown to be visible when shown */
    
                .language-dropdown[style*="display: block"] {
    
                    display: block !important;
    
                    visibility: visible !important;
    
                    opacity: 1 !important;
    
                    pointer-events: auto !important;
    
                }
    
    
    
                @keyframes dropdownSlideIn {
    
                    from {
    
                        opacity: 0;
    
                        transform: translateY(-10px);
    
                    }
    
                    to {
    
                        opacity: 1;
    
                        transform: translateY(0);
    
                    }
    
                }
    
    
    
                .language-dropdown-content {
    
                    padding: 20px !important;
    
                    background: #ffffff !important;
    
                    min-height: 100px !important;
    
                }
    
    
    
                .language-option {
    
                    display: flex;
    
                    align-items: center;
    
                    gap: 12px;
    
                    padding: 12px 16px;
    
                    border: none;
    
                    border-radius: 8px;
    
                    background: transparent;
    
                    cursor: pointer;
    
                    transition: all 0.2s ease;
    
                    font-size: 14px;
    
                    font-weight: 500;
    
                    color: #374151;
    
                    text-align: left;
    
                    width: 100%;
    
                    margin-bottom: 4px;
    
                    font-family: inherit;
    
                
    
                    pointer-events: auto !important;
    
                    user-select: none;
    
                }
    
    
    
                .language-option:hover {
    
                    background: #f3f4f6;
    
                }
    
    
    
                .language-option.selected,
                .language-option[aria-selected="true"] {
    
                    background: #6366f1 !important;
    
                    color: #ffffff !important;
    
                }
    
                .language-option.selected:hover,
                .language-option[aria-selected="true"]:hover {
    
                    background: #4f46e5 !important;
    
                }
    
    
    
                .language-option .flag {
    
                    font-size: 16px;
    
                    flex-shrink: 0;
    
                }
    
    
    
                .language-option .language-name {
    
                    flex: 1;
    
                    font-weight: 500;
    
                    font-size: 14px;
    
                }
    
    
    
                /* Global Accessibility Feature Classes - These will sync with main page */
    
                /* Exclude widget from seizure-safe filter - widget should never have greyscale */
                :host,
                :host(.seizure-safe),
                :host(.seizure-safe) .accessbit-widget-icon,
                :host(.seizure-safe) .accessbit-widget-panel,
                :host(.seizure-safe) * {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
    
                
    
                /* Ensure seizure safe icon stays in correct position */
    
                :host(.seizure-safe) .accessbit-widget-icon {
    
                    position: fixed !important;
    
                    z-index: 2147483645 !important;
    
                }
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Vision impaired feature removed */
    
    
    
                /* Panel elements use specific font sizes above - no general scaling */
    
    
    
                /* Panel font sizes are handled by specific rules above - no additional scaling needed */
    
    
    
                :host(.adhd-friendly) .accessbit-widget-icon,
    
                :host(.adhd-friendly) .accessbit-widget-panel {
    
                    filter: saturate(0.9) brightness(0.9) !important;
    
                }
    
    
    
                :host(.cognitive-disability) .accessbit-widget-icon,
    
                :host(.cognitive-disability) .accessbit-widget-panel {
    
                    filter: saturate(1.2) brightness(1.1) !important;
    
                }
    
    
    
    
    
    
    
                :host(.monochrome) .accessbit-widget-icon,
    
                :host(.monochrome) .accessbit-widget-panel {
    
                    filter: grayscale(1) !important;
    
                }
    
    
    
                :host(.dark-contrast) .accessbit-widget-icon,
    
                :host(.dark-contrast) .accessbit-widget-panel {
    
                    filter: saturate(1.2) brightness(0.8) contrast(1.3) !important;
    
                }
    
    
    
                :host(.light-contrast) .accessbit-widget-icon,
    
                :host(.light-contrast) .accessbit-widget-panel {
    
                    filter: saturate(1.2) brightness(1.2) contrast(0.9) !important;
    
                }
    
    
    
                /* Reduce high contrast intensity for Shadow DOM content */
    
                /* High contrast should NOT affect widget - remove any filters */
                :host(.high-contrast) .accessbit-widget-icon,
                :host(.high-contrast) .accessbit-widget-panel,
                :host(.high-contrast) .accessbit-widget-panel * {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
    
    
    
    
    
                /* Default font styles for widget elements (when readable font is disabled) */
    
                :host(:not(.readable-font)) .accessbit-widget-icon,
    
                :host(:not(.readable-font)) .accessbit-widget-panel {
    
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
    
                    font-weight: normal !important;
    
                    letter-spacing: normal !important;
    
                }
    
    
    
                :host(:not(.readable-font)) .accessbit-widget-panel h2,
    
                :host(:not(.readable-font)) .accessbit-widget-panel h3,
    
                :host(:not(.readable-font)) .accessbit-widget-panel h4,
    
                :host(:not(.readable-font)) .accessbit-widget-panel p,
    
                :host(:not(.readable-font)) .accessbit-widget-panel .action-btn,
    
                :host(:not(.readable-font)) .accessbit-widget-panel button,
    
                :host(:not(.readable-font)) .accessbit-widget-panel input,
    
                :host(:not(.readable-font)) .accessbit-widget-panel label {
    
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
    
                    font-weight: normal !important;
    
                    letter-spacing: normal !important;
    
                }
    
    
    
                /* Widget panel font should NOT change when readable font is active */
                /* Explicitly set widget font even when readable-font class is on body */
                :host(.readable-font) .accessbit-widget-icon,
                :host(.readable-font) .accessbit-widget-panel,
                :host .accessbit-widget-icon,
                :host .accessbit-widget-panel {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    font-weight: normal;
                    letter-spacing: normal;
                }
                
                :host(.readable-font) .accessbit-widget-panel h2,
                :host(.readable-font) .accessbit-widget-panel h3,
                :host(.readable-font) .accessbit-widget-panel h4,
                :host(.readable-font) .accessbit-widget-panel p,
                :host(.readable-font) .accessbit-widget-panel .action-btn,
                :host(.readable-font) .accessbit-widget-panel button,
                :host(.readable-font) .accessbit-widget-panel input,
                :host(.readable-font) .accessbit-widget-panel label,
                :host .accessbit-widget-panel h2,
                :host .accessbit-widget-panel h3,
                :host .accessbit-widget-panel h4,
                :host .accessbit-widget-panel p,
                :host .accessbit-widget-panel .action-btn,
                :host .accessbit-widget-panel button,
                :host .accessbit-widget-panel input,
                :host .accessbit-widget-panel label {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    font-weight: normal;
                    letter-spacing: normal;
                }
    
    
    
                :host(.high-saturation) .accessbit-widget-icon,
    
                :host(.high-saturation) .accessbit-widget-panel {
    
                    filter: saturate(1.2) !important;
    
                }
    
    
    
                /* Font Awesome Icons */
    
                .fas {
    
                    font-family: 'Font Awesome 5 Free';
    
                    font-weight: 900;
    
                }
    
    
    
    
    
    
    
                .fa-universal-access:before {
    
                    content: "\\f29a";
    
                }
    
    
    
                .fa-times:before {
    
                    content: "\\f00d";
    
                }
    
    
    
                .fa-flag:before {
    
                    content: "\\f024";
    
                }
    
    
    
                .fa-redo:before {
    
                    content: "\\f01e";
    
                }
    
    
    
                .fa-file-alt:before {
    
                    content: "\\f15c";
    
                }
    
    
    
                .fa-eye-slash:before {
    
                    content: "\\f070";
    
                }
    
    
    
                .fa-bolt:before {
    
                    content: "\\f0e7";
    
                }
    
    
    
                .fa-eye:before {
    
                    content: "\\f06e";
    
                }
    
    
    
                .fa-brain:before {
    
                    content: "\\f5dc";
    
                }
    
    
    
                .fa-keyboard:before {
    
                    content: "\\f11c";
    
                }
    
    
    
                .fa-user:before {
    
                    content: "\\f007";
    
                }
    
    
    
                .fa-search-plus:before {
    
                    content: "\\f00e";
    
                }
    
    
    
                .fa-font:before {
    
                    content: "\\f031";
    
                }
    
    
    
                .fa-heading:before {
    
                    content: "\\f1dc";
    
                }
    
    
    
                .fa-link:before {
    
                    content: "\\f0c1";
    
                }
    
    
    
                .fa-search:before {
    
                    content: "\\f002";
    
                }
    
    
    
                .fa-align-center:before {
    
                    content: "\\f037";
    
                }
    
    
    
                .fa-arrows-alt-v:before {
    
                    content: "\\f07d";
    
                }
    
    
    
                .fa-text-width:before {
    
                    content: "\\f035";
    
                }
    
    
    
                .fa-palette:before {
    
                    content: "\\f53f";
    
                }
    
    
    
                .fa-volume-mute:before {
    
                    content: "\\f6a9";
    
                }
    
    
    
                .fa-image:before {
    
                    content: "\\f03e";
    
                }
    
    
    
                .fa-book-open:before {
    
                    content: "\\f518";
    
                }
    
    
    
                .fa-compass:before {
    
                    content: "\\f14e";
    
                }
    
    
    
                .fa-list:before {
    
                    content: "\\f03a";
    
                }
    
    
    
                .fa-play:before {
    
                    content: "\\f04b";
    
                }
    
    
    
                .fa-mask:before {
    
                    content: "\\f6fa";
    
                }
    
    
    
                .fa-mouse-pointer:before {
    
                    content: "\\f245";
    
                }
    
    
    
                /* Color Picker Inline */
    
                .color-picker-inline {
    
                    margin: 8px 0;
    
                    padding: 12px;
    
                    background: #f8f9fa;
    
                    border-radius: 6px;
    
                    border: 1px solid #e2e8f0;
    
                    width: 100%;
    
                    box-sizing: border-box;
    
                }
    
    
    
                .color-picker-content {
    
                    text-align: center;
    
                }
    
    
    
                .color-picker-content h4 {
    
                    margin: 0 0 12px 0;
    
                    color: #333;
    
                    font-size: 14px;
    
                    font-weight: 600;
    
                }
    
    
    
                .color-options {
    
                    display: flex;
    
                    justify-content: center;
    
                    gap: 8px;
    
                    margin-bottom: 12px;
    
                    flex-wrap: wrap;
    
                }
    
    
    
                .color-option {
    
                    width: 28px;
    
                    height: 28px;
    
                    /* border-radius: 50%; REMOVED - conflicts with shape settings */
    
                    cursor: pointer;
    
                    border: 2px solid transparent;
    
                    transition: all 0.2s ease;
    
                    position: relative;
    
                    flex-shrink: 0;
    
                }
    
    
    
                .color-option:hover {
    
                    transform: scale(1.05);
    
                    border-color: #6366f1;
    
                }
    
    
    
                .color-option.selected {
    
                    border-color: #6366f1;
    
                    box-shadow: 0 0 0 1px #fff, 0 0 0 3px #6366f1;
    
                }
    
    
    
                .cancel-btn {
    
                    background: #6b7280;
    
                    color: white;
    
                    border: none;
    
                    padding: 8px 16px;
    
                    border-radius: 4px;
    
                    cursor: pointer;
    
                    font-size: 12px;
    
                    font-weight: 500;
    
                    transition: background-color 0.2s ease;
    
                }
    
    
    
                .cancel-btn:hover {
    
                    background: #4b5563;
    
                }
    
    
    
                /* Ensure profile item has relative positioning for absolute toggle */
    
                .profile-item.has-dropdown {
    
                    position: relative !important;
    
                }
    
    
    
                /* Ensure toggle switch stays in position when dropdown is present */
    
                .profile-item.has-dropdown .toggle-switch {
    
                    flex-shrink: 0 !important;
    
                }
    
    
    
                .profile-item.has-dropdown .profile-info {
    
                    padding-left: 0 !important;
                    margin-bottom: 0 !important;
    
                }
    
    
    
                /* Enhanced dropdown styling */
    
                .useful-links-dropdown {
    
                    margin: 10px 0;
    
                    padding: 0;
    
                    width: 100%;
    
                    display: block;
    
                    background: #f8fafc;
    
                    border-radius: 8px;
    
                    border: 1px solid #e2e8f0;
    
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
    
                    transition: all 0.3s ease;
    
                }
    
    
    
                .useful-links-dropdown:hover {
    
                    border-color: #6366f1;
    
                    box-shadow: 0 4px 10px rgba(99, 102, 241, 0.12);
    
                }
    
    
    
                .useful-links-content {
    
                    padding: 10px;
    
                }
    
    
    
                .useful-links-content select {
    
                    width: 100%;
    
                    padding: 10px 14px;
    
                    border: 1px solid #6366f1;
    
                    border-radius: 6px;
    
                    background: white;
    
                    color: #374151;
    
                    font-size: 13px;
    
                    font-weight: 500;
    
                    font-family: 'DM Sans', sans-serif;
    
                    cursor: pointer;
    
                    transition: all 0.3s ease;
    
                    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    
                    appearance: none;
    
                    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
    
                    background-position: right 10px center;
    
                    background-repeat: no-repeat;
    
                    background-size: 14px;
    
                    padding-right: 35px;
    
                }
    
    
    
                .useful-links-content select:focus {
    
                    outline: 3px solid #4f46e5 !important;
    
                    outline-offset: 2px !important;
    
                    border-color: #4f46e5;
    
                    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1), 0 4px 12px rgba(0, 0, 0, 0.15);
    
                    transform: translateY(-1px);
    
                }
    
    
    
                .useful-links-content select:hover {
    
                    border-color: #4f46e5;
    
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    
                    transform: translateY(-1px);
    
                }
    
    
    
                .useful-links-content select option {
    
                    padding: 12px 16px;
    
                    background: white;
    
                    color: #374151;
    
                    font-weight: 500;
    
                    border: none;
    
                }
    
    
    
                .useful-links-content select option:hover {
    
                    background: #f3f4f6;
    
                    color: #1f2937;
    
                }
    
    
    
                .useful-links-content select option:selected {
    
                    background: #6366f1;
    
                    color: white;
    
                }
    
                /* Big Black Cursor - Clean Arrow Cursor Shape - MAXIMUM SPECIFICITY */
    /* Big Black Cursor - Arrow Cursor (default) */
    body.big-black-cursor,
    html body.big-black-cursor,
    body.big-black-cursor *,
    html body.big-black-cursor * {
        cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAxMjAgMTIwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzPjxmaWx0ZXIgaWQ9InNoYWRvdy1ibGFjayIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSI+PGZlRHJvcFNoYWRvdyBkeD0iMiIgZHk9IjIiIHN0ZERldmlhdGlvbj0iMyIgZmxvb2RPcGFjaXR5PSIwLjMiLz48L2ZpbHRlcj48L2RlZnM+PHBhdGggZD0iTSAyMCAxMCBMIDIwIDgwIEwgNDAgNjAgTCA1MCA4NSBMIDU4IDgyIEwgNDggNTcgTCA3MCA1MCBaIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgZmlsdGVyPSJ1cmwoI3NoYWRvdy1ibGFjaykiLz48L3N2Zz4=') 20 10, auto !important;
    }
    
    /* Big Black Cursor - Hand Pointer for Links - Higher specificity to override default */
    body.big-black-cursor a,
    body.big-black-cursor a *,
    body.big-black-cursor button,
    body.big-black-cursor button *,
    body.big-black-cursor [role="button"],
    body.big-black-cursor [role="button"] *,
    body.big-black-cursor [onclick],
    body.big-black-cursor [onclick] *,
    body.big-black-cursor [tabindex]:not([tabindex="-1"]),
    body.big-black-cursor [tabindex]:not([tabindex="-1"]) *,
    body.big-black-cursor input[type="button"],
    body.big-black-cursor input[type="submit"],
    body.big-black-cursor input[type="reset"],
    body.big-black-cursor .btn,
    body.big-black-cursor [class*="button"],
    body.big-black-cursor [class*="link"] {
        cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCA4MCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGZpbHRlciBpZD0ic2hhZG93LWhhbmQtYmxhY2siIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiPjxmZURyb3BTaGFkb3cgZHg9IjIiIGR5PSIyIiBzdGREZXZpYXRpb249IjMiIGZsb29kT3BhY2l0eT0iMC4zIi8+PC9maWx0ZXI+PC9kZWZzPjxwYXRoIGQ9Ik0gMjggOCBRIDI2IDggMjUgOSBRIDI0IDEwIDI0IDEyIEwgMjQgNDIgQyAyMiA0MCAyMCAzOCAxOCAzNyBDIDE2IDM2IDEzIDM2IDExIDM3LjUgQyA5IDM5IDguNSA0MSA5LjUgNDMgQyAxMC41IDQ1LjUgMTMgNDguNSAxNCA0OS41IEMgMTUgNTEgMTcuNSA1NiAxOS41IDU3LjUgQyAyMSA1OC44IDIyIDYyIDIyLjUgNjUgTCAyMi41IDY4IEwgNTIgNjggTCA1MiA2MyBDIDUyLjUgNjEuOCA1My41IDYwIDU0LjUgNTkgQyA1Ni41IDU3IDU3IDUzIDU3IDUxLjUgTCA1NyAzNiBRIDU3IDM0LjUgNTUuNSAzMyBDIDU0LjUgMzIgNTIuNSAzMS41IDUwIDMxLjMgQyA0OS44IDMxIDQ5LjUgMzAuNSA0OSAzMC4yIEMgNDcuNSAyOS4yIDQ1IDI4LjggNDIuNSAyOC43IEMgNDIuMyAyOC41IDQyIDI4LjIgNDEuNSAyNy45IEMgNDAgMjcgMzggMjYuNiAzNiAyNi41IEwgMzYgMTIgUSAzNiAxMCAzNSA5IFEgMzQgOCAzMiA4IFEgMzAgOCAyOCA4IFoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZmlsdGVyPSJ1cmwoI3NoYWRvdy1oYW5kLWJsYWNrKSIvPjwvc3ZnPg==') 24 10, pointer !important;
    }
    
    /* Big White Cursor - Arrow Cursor (default) */
    body.big-white-cursor,
    html body.big-white-cursor,
    body.big-white-cursor *,
    html body.big-white-cursor * {
        cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAxMjAgMTIwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzPjxmaWx0ZXIgaWQ9InNoYWRvdy13aGl0ZSIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSI+PGZlRHJvcFNoYWRvdyBkeD0iMiIgZHk9IjIiIHN0ZERldmlhdGlvbj0iMyIgZmxvb2RPcGFjaXR5PSIwLjUiLz48L2ZpbHRlcj48L2RlZnM+PHBhdGggZD0iTSAyMCAxMCBMIDIwIDgwIEwgNDAgNjAgTCA1MCA4NSBMIDU4IDgyIEwgNDggNTcgTCA3MCA1MCBaIiBmaWxsPSIjRkZGRkZGIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgZmlsdGVyPSJ1cmwoI3NoYWRvdy13aGl0ZSkiLz48L3N2Zz4=') 20 10, auto !important;
    }
    
    /* Big White Cursor - Hand Pointer for Links - Higher specificity to override default */
    body.big-white-cursor a,
    body.big-white-cursor a *,
    body.big-white-cursor button,
    body.big-white-cursor button *,
    body.big-white-cursor [role="button"],
    body.big-white-cursor [role="button"] *,
    body.big-white-cursor [onclick],
    body.big-white-cursor [onclick] *,
    body.big-white-cursor [tabindex]:not([tabindex="-1"]),
    body.big-white-cursor [tabindex]:not([tabindex="-1"]) *,
    body.big-white-cursor input[type="button"],
    body.big-white-cursor input[type="submit"],
    body.big-white-cursor input[type="reset"],
    body.big-white-cursor .btn,
    body.big-white-cursor [class*="button"],
    body.big-white-cursor [class*="link"] {
        cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCA4MCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGZpbHRlciBpZD0ic2hhZG93LWhhbmQtd2hpdGUiIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiPjxmZURyb3BTaGFkb3cgZHg9IjIiIGR5PSIyIiBzdGREZXZpYXRpb249IjMiIGZsb29kT3BhY2l0eT0iMC41Ii8+PC9maWx0ZXI+PC9kZWZzPjxwYXRoIGQ9Ik0gMjggOCBRIDI2IDggMjUgOSBRIDI0IDEwIDI0IDEyIEwgMjQgNDIgQyAyMiA0MCAyMCAzOCAxOCAzNyBDIDE2IDM2IDEzIDM2IDExIDM3LjUgQyA5IDM5IDguNSA0MSA5LjUgNDMgQyAxMC41IDQ1LjUgMTMgNDguNSAxNCA0OS41IEMgMTUgNTEgMTcuNSA1NiAxOS41IDU3LjUgQyAyMSA1OC44IDIyIDYyIDIyLjUgNjUgTCAyMi41IDY4IEwgNTIgNjggTCA1MiA2MyBDIDUyLjUgNjEuOCA1My41IDYwIDU0LjUgNTkgQyA1Ni41IDU3IDU3IDUzIDU3IDUxLjUgTCA1NyAzNiBRIDU3IDM0LjUgNTUuNSAzMyBDIDU0LjUgMzIgNTIuNSAzMS41IDUwIDMxLjMgQyA0OS44IDMxIDQ5LjUgMzAuNSA0OSAzMC4yIEMgNDcuNSAyOS4yIDQ1IDI4LjggNDIuNSAyOC43IEMgNDIuMyAyOC41IDQyIDI4LjIgNDEuNSAyNy45IEMgNDAgMjcgMzggMjYuNiAzNiAyNi41IEwgMzYgMTIgUSAzNiAxMCAzNSA5IFEgMzQgOCAzMiA4IFEgMzAgOCAyOCA4IFoiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZmlsdGVyPSJ1cmwoI3NoYWRvdy1oYW5kLXdoaXRlKSIvPjwvc3ZnPg==') 24 10, pointer !important;
    }
                /* Hide Interface Modal Styles */
                .hide-interface-modal {
                    position: sticky !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    bottom: 0 !important;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 100001;
                    /* Keep modal in panel viewport when scrolling */
                    width: 100% !important;
                    height: 100% !important;
                    min-height: 100% !important;
                    /* Ensure overlay covers full scrollable area */
                    max-height: none;
                    overflow: hidden;
                }
    
                .hide-interface-modal .modal-content {
                    background: white;
                    border-radius: 12px;
                    box-shadow: 0 10px 12px rgba(0, 0, 0, 0.3);
                    /* Position the modal dialog in the center of viewable area */
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    /* Ensure it stays within the panel bounds */
                    max-width: 400px;
                    width: 90%;
                    max-height: 80%;
                    overflow: hidden;
                }
    
                .hide-interface-modal .modal-header {
                    padding: 20px 20px 10px 20px;
                    border-bottom: 1px solid #e5e7eb;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
    
                .hide-interface-modal .modal-header h3 {
                    margin: 0;
                    color: #1f2937;
                    font-size: 18px;
                    font-weight: 600;
                }
    
                .hide-interface-modal .modal-close {
                    background: none;
                    border: none;
                    font-size: 24px;
                    color: #6b7280;
                    cursor: pointer;
                    padding: 0;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
    
                .hide-interface-modal .modal-close:hover {
                    color: #374151;
                }
    
                .hide-interface-modal .modal-body {
                    padding: 20px;
                }
    
                .hide-interface-modal .modal-body p {
                    margin: 0;
                    color: #374151;
                    line-height: 1.5;
                    font-size: 14px;
                }
    
                .hide-interface-modal .modal-footer {
                    padding: 10px 20px 20px 20px;
                    display: flex;
                    gap: 12px;
                    justify-content: flex-end;
                }
    
                .hide-interface-modal .modal-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
    
                .hide-interface-modal .accept-btn {
                    background: #3b82f6;
                    color: white;
                }
    
                .hide-interface-modal .accept-btn:hover {
                    background: #2563eb;
                }
    
                .hide-interface-modal .cancel-btn {
                    background: white;
                    color: #374151;
                    border: 1px solid #d1d5db;
                }
    
                .hide-interface-modal .cancel-btn:hover {
                    background: #f9fafb;
                }
    
            `;
    
        }
    
    
    
        // Helper function to create a profile item
        createProfileItem(config) {
            const profileItem = document.createElement('div');
            profileItem.className = 'profile-item';
            
            // Create toggle switch
            const label = document.createElement('label');
            label.className = 'toggle-switch';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = config.id;
            checkbox.setAttribute('tabindex', '0');
            checkbox.setAttribute('aria-label', config.ariaLabel || '');
            if (config.ariaDescribedBy) {
                checkbox.setAttribute('aria-describedby', config.ariaDescribedBy);
            }
            label.appendChild(checkbox);
            
            const slider = document.createElement('span');
            slider.className = 'slider';
            label.appendChild(slider);
            
            // Create profile info
            const profileInfo = document.createElement('div');
            profileInfo.className = 'profile-info';
            
            const infoDiv = document.createElement('div');
            
            const h4 = document.createElement('h4');
            h4.textContent = config.title;
            infoDiv.appendChild(h4);
            
            if (config.description) {
                const p = document.createElement('p');
                if (config.descriptionId) {
                    p.id = config.descriptionId;
                }
                p.textContent = config.description;
                infoDiv.appendChild(p);
            }
            
            if (config.extraContent) {
                // For scaling controls, reading guide, etc.
                const extraDiv = document.createElement('div');
                if (config.extraContent.className) {
                    extraDiv.className = config.extraContent.className;
                }
                if (config.extraContent.id) {
                    extraDiv.id = config.extraContent.id;
                }
                if (config.extraContent.style) {
                    extraDiv.style.cssText = config.extraContent.style;
                }
                // Build scaling controls or other extra content
                if (config.extraContent.type) {
                    this.buildExtraContent(extraDiv, config.extraContent);
                } else if (config.extraContent.html) {
                    // For complex nested structures, we'll build them
                    this.buildExtraContent(extraDiv, config.extraContent.html);
                }
                infoDiv.appendChild(extraDiv);
            }
            
            if (config.smallText) {
                const small = document.createElement('small');
                small.style.cssText = 'color: #6366f1; font-style: italic; font-size: 12px; font-weight: normal;';
                small.textContent = config.smallText;
                infoDiv.appendChild(small);
            }
            
            profileInfo.appendChild(infoDiv);
            
            // Order: label first if config.switchFirst, otherwise info first
            if (config.switchFirst) {
                profileItem.appendChild(label);
                profileItem.appendChild(profileInfo);
            } else {
                profileItem.appendChild(profileInfo);
                profileItem.appendChild(label);
            }
            
            return profileItem;
        }
        
        // Helper to build extra content (scaling controls, etc.)
        buildExtraContent(container, contentConfig) {
            if (contentConfig.type === 'scaling-controls') {
                const flexDiv = document.createElement('div');
                flexDiv.style.cssText = 'display: flex; align-items: center; gap: 10px;';
                
                const decreaseBtn = document.createElement('button');
                decreaseBtn.className = 'scaling-btn';
                decreaseBtn.id = contentConfig.decreaseId;
                decreaseBtn.setAttribute('tabindex', '0');
                decreaseBtn.setAttribute('aria-label', contentConfig.decreaseLabel);
                decreaseBtn.style.cssText = 'background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;';
                const decreaseSpan = document.createElement('span');
                decreaseSpan.textContent = contentConfig.decreaseText;
                decreaseBtn.appendChild(decreaseSpan);
                flexDiv.appendChild(decreaseBtn);
                
                const valueSpan = document.createElement('span');
                valueSpan.id = contentConfig.valueId;
                valueSpan.style.cssText = 'font-weight: bold; min-width: 60px; text-align: center;';
                valueSpan.textContent = contentConfig.valueText || '100%';
                flexDiv.appendChild(valueSpan);
                
                const increaseBtn = document.createElement('button');
                increaseBtn.className = 'scaling-btn';
                increaseBtn.id = contentConfig.increaseId;
                increaseBtn.setAttribute('tabindex', '0');
                increaseBtn.setAttribute('aria-label', contentConfig.increaseLabel);
                increaseBtn.style.cssText = 'background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;';
                const increaseSpan = document.createElement('span');
                increaseSpan.textContent = contentConfig.increaseText;
                increaseBtn.appendChild(increaseSpan);
                flexDiv.appendChild(increaseBtn);
                
                container.appendChild(flexDiv);
            } else if (contentConfig.type === 'description') {
                const descDiv = document.createElement('div');
                descDiv.className = 'profile-description';
                const descP = document.createElement('p');
                descP.textContent = contentConfig.text;
                descDiv.appendChild(descP);
                container.appendChild(descDiv);
            }
        }
        
        // Create panel elements programmatically (replaces getPanelHTML)
        createPanelElements(container) {
            // Clear container
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Panel Header
            const panelHeader = document.createElement('div');
            panelHeader.className = 'panel-header';
            
            const closeBtn = document.createElement('div');
            closeBtn.className = 'close-btn';
            closeBtn.id = 'close-panel';
            closeBtn.setAttribute('tabindex', '0');
            closeBtn.setAttribute('role', 'button');
            closeBtn.setAttribute('aria-label', 'Close accessibility panel');
            closeBtn.textContent = '';
            panelHeader.appendChild(closeBtn);
            
            const headerContent = document.createElement('div');
            headerContent.className = 'header-content';
            const h2 = document.createElement('h2');
            h2.textContent = 'Accessibility Adjustments';
            headerContent.appendChild(h2);
            panelHeader.appendChild(headerContent);
            
            const languageSelectorHeader = document.createElement('div');
            languageSelectorHeader.className = 'language-selector-header';
            languageSelectorHeader.id = 'language-selector-header';
            languageSelectorHeader.setAttribute('tabindex', '0');
            languageSelectorHeader.setAttribute('role', 'button');
            languageSelectorHeader.setAttribute('aria-label', 'Select language');
            languageSelectorHeader.setAttribute('aria-expanded', 'false');
            languageSelectorHeader.setAttribute('aria-haspopup', 'listbox');
            
            const currentLangSpan = document.createElement('span');
            currentLangSpan.id = 'current-language-header';
            currentLangSpan.textContent = 'ENGLISH';
            languageSelectorHeader.appendChild(currentLangSpan);
            
            const chevronIcon = document.createElement('i');
            chevronIcon.className = 'fas fa-chevron-down';
            languageSelectorHeader.appendChild(chevronIcon);
            panelHeader.appendChild(languageSelectorHeader);
            
            const actionButtons = document.createElement('div');
            actionButtons.className = 'action-buttons';
            
            const buttonRow1 = document.createElement('div');
            buttonRow1.className = 'button-row';
            
            const resetBtn = document.createElement('button');
            resetBtn.id = 'reset-settings';
            resetBtn.className = 'action-btn';
            resetBtn.setAttribute('tabindex', '0');
            resetBtn.setAttribute('aria-label', 'Reset all accessibility settings');
            const resetIcon = document.createElement('i');
            resetIcon.className = 'fas fa-redo';
            resetBtn.appendChild(resetIcon);
            resetBtn.appendChild(document.createTextNode(' Reset Settings'));
            buttonRow1.appendChild(resetBtn);
            
            const statementBtn = document.createElement('button');
            statementBtn.id = 'statement';
            statementBtn.className = 'action-btn';
            statementBtn.setAttribute('tabindex', '0');
            statementBtn.setAttribute('aria-label', 'View accessibility statement');
            const statementIcon = document.createElement('i');
            statementIcon.className = 'fas fa-file-alt';
            statementBtn.appendChild(statementIcon);
            statementBtn.appendChild(document.createTextNode(' Statement'));
            buttonRow1.appendChild(statementBtn);
            actionButtons.appendChild(buttonRow1);
            
            const buttonRow2 = document.createElement('div');
            buttonRow2.className = 'button-row';
            
            const hideBtn = document.createElement('button');
            hideBtn.id = 'hide-interface';
            hideBtn.className = 'action-btn';
            hideBtn.setAttribute('tabindex', '0');
            hideBtn.setAttribute('aria-label', 'Hide accessibility interface');
            const hideIcon = document.createElement('i');
            hideIcon.className = 'fas fa-eye-slash';
            hideBtn.appendChild(hideIcon);
            hideBtn.appendChild(document.createTextNode(' Hide Interface'));
            buttonRow2.appendChild(hideBtn);
            actionButtons.appendChild(buttonRow2);
            
            panelHeader.appendChild(actionButtons);
            container.appendChild(panelHeader);
            
            // White Content Section
            const whiteContentSection = document.createElement('div');
            whiteContentSection.className = 'white-content-section';
            
            const sectionH3 = document.createElement('h3');
            sectionH3.textContent = 'Choose the right accessibility profile for you';
            whiteContentSection.appendChild(sectionH3);
            
            // Create all profile items
            const profiles = [
                { id: 'seizure-safe', title: 'Seizure Safe Profile', description: 'Clear flashes & reduces color', descriptionId: 'seizure-safe-desc', ariaLabel: 'Seizure Safe Profile - Clear flashes and reduces color', ariaDescribedBy: 'seizure-safe-desc' },
                { id: 'reduce-motion', title: 'Reduce Motion', description: 'Disable animations and transitions', descriptionId: 'reduce-motion-desc', ariaLabel: 'Reduce Motion - Disable animations, transitions, and flash triggers', ariaDescribedBy: 'reduce-motion-desc' },
                { id: 'vision-impaired', title: 'Vision Impaired Profile', description: 'Enhances text readability and visual clarity', descriptionId: 'vision-impaired-desc', ariaLabel: 'Vision Impaired Profile - Enhances text readability and visual clarity', ariaDescribedBy: 'vision-impaired-desc' },
                { id: 'adhd-friendly', title: 'ADHD Friendly Profile', description: 'More focus & fewer distractions', ariaLabel: 'ADHD Friendly Profile - Reduces distractions and highlights focus' },
                { id: 'cognitive-disability', title: 'Cognitive Disability Profile', description: 'Assists with reading & focusing', ariaLabel: 'Cognitive Disability Profile - Simplifies interface and content' },
                { id: 'keyboard-nav', title: 'Keyboard Navigation (Motor)', description: 'Use website with the keyboard', ariaLabel: 'Keyboard Navigation - Enable keyboard-only navigation', extraContent: { type: 'description', text: 'This profile enables motor-impaired persons to operate the website using keyboard keys and shortcuts' }, smallText: 'Activates with Screen Reader' },
                { id: 'screen-reader', title: 'Blind Users (Screen Reader)', description: 'Optimize website for screen-readers', ariaLabel: 'Screen Reader - Optimize for screen readers', extraContent: { type: 'description', text: 'This profile adjusts the website to be compatible with screen-readers such as JAWS, NVDA, VoiceOver, and TalkBack. Screen-reader software is installed on the blind user\'s computer and smartphone, and websites should ensure compatibility.' }, smallText: 'Activates with Keyboard Navigation' },
                { id: 'content-scaling', title: 'Content Scaling', description: 'Scale content with arrow controls', ariaLabel: 'Content Scaling - Adjust content size for better readability', extraContent: { type: 'scaling-controls', className: 'scaling-controls', id: 'content-scaling-controls', style: 'display: none; margin-top: 10px;', decreaseId: 'decrease-content-scale-btn', decreaseLabel: 'Decrease content scale by 2%', decreaseText: '-2%', valueId: 'content-scale-value', valueText: '100%', increaseId: 'increase-content-scale-btn', increaseLabel: 'Increase content scale by 2%', increaseText: '+2%' } },
                { id: 'readable-font', title: 'Readable Font', description: 'High-legibility fonts', ariaLabel: 'Readable Font - Use dyslexia-friendly fonts' },
                { id: 'highlight-titles', title: 'Highlight Titles', description: 'Add boxes around heading tags (h1-h6)', ariaLabel: 'Highlight Titles - Emphasize headings and titles' },
                { id: 'highlight-links', title: 'Highlight Links', description: 'Add boxes around links', ariaLabel: 'Highlight Links - Emphasize clickable links' },
                { id: 'text-magnifier', title: 'Text Magnifier', description: 'Floating magnifying glass tool', ariaLabel: 'Text Magnifier - Enlarge text on hover' },
                { id: 'font-sizing', title: 'Adjust Font Sizing', description: 'Font size with arrow controls', descriptionId: 'font-sizing-desc', ariaLabel: 'Adjust Font Sizing - Font size with arrow controls', ariaDescribedBy: 'font-sizing-desc', extraContent: { type: 'scaling-controls', className: 'scaling-controls', id: 'font-sizing-controls', style: 'display: none; margin-top: 10px;', decreaseId: 'decrease-font-size-btn', decreaseLabel: 'Decrease font size by 5%', decreaseText: '-5%', valueId: 'font-size-value', valueText: '100%', increaseId: 'increase-font-size-btn', increaseLabel: 'Increase font size by 5%', increaseText: '+5%' } },
                { id: 'align-center', title: 'Align Center', description: 'Center-aligns all text content', ariaLabel: 'Align Center - Center-align text content' },
                { id: 'adjust-line-height', title: 'Adjust Line Height', description: 'Line height with arrow controls', ariaLabel: 'Adjust Line Height - Increase spacing between lines', extraContent: { type: 'scaling-controls', className: 'scaling-controls', id: 'line-height-controls', style: 'display: none; margin-top: 10px;', decreaseId: 'decrease-line-height-btn', decreaseLabel: 'Decrease line height by 10%', decreaseText: '-10%', valueId: 'line-height-value', valueText: '100%', increaseId: 'increase-line-height-btn', increaseLabel: 'Increase line height by 10%', increaseText: '+10%' } },
                { id: 'adjust-letter-spacing', title: 'Adjust Letter Spacing', description: 'Letter spacing with arrow controls', ariaLabel: 'Adjust Letter Spacing - Increase spacing between letters', extraContent: { type: 'scaling-controls', className: 'scaling-controls', id: 'letter-spacing-controls', style: 'display: none; margin-top: 10px;', decreaseId: 'decrease-letter-spacing-btn', decreaseLabel: 'Decrease letter spacing by 10%', decreaseText: '-10%', valueId: 'letter-spacing-value', valueText: '100%', increaseId: 'increase-letter-spacing-btn', increaseLabel: 'Increase letter spacing by 10%', increaseText: '+10%' } },
                { id: 'align-left', title: 'Align Left', description: 'Left-aligns text content', ariaLabel: 'Align Left - Left-align text content' },
                { id: 'align-right', title: 'Align Right', description: 'Right-aligns text content', ariaLabel: 'Align Right - Right-align text content' },
                { id: 'dark-contrast', title: 'Dark Contrast', description: 'Dark background with light text', ariaLabel: 'Dark Contrast - Apply dark color scheme' },
                { id: 'light-contrast', title: 'Light Contrast', description: 'Light background with dark text', ariaLabel: 'Light Contrast - Apply light color scheme' },
                { id: 'high-contrast', title: 'High Contrast', description: 'Maximum contrast implementation', ariaLabel: 'High Contrast - Apply high contrast colors' },
                { id: 'high-saturation', title: 'High Saturation', description: 'Increases color intensity', ariaLabel: 'High Saturation - Increase color intensity' },
                { id: 'adjust-text-colors', title: 'Adjust Text Colors', description: 'Color picker functionality', ariaLabel: 'Adjust Text Colors - Modify text color scheme' },
                { id: 'monochrome', title: 'Monochrome', description: 'Removes all colors except black, white, grays', ariaLabel: 'Monochrome - Apply grayscale color scheme', switchFirst: false },
                { id: 'adjust-title-colors', title: 'Adjust Title Colors', description: 'Color customization for headings', ariaLabel: 'Adjust Title Colors - Modify heading color scheme', switchFirst: false },
                { id: 'low-saturation', title: 'Low Saturation', description: 'Reduces color intensity', ariaLabel: 'Low Saturation - Decrease color intensity', switchFirst: false },
                { id: 'adjust-bg-colors', title: 'Adjust Background Colors', description: 'Background color customization', ariaLabel: 'Adjust Background Colors - Modify background color scheme', switchFirst: false },
                { id: 'mute-sound', title: 'Mute Sound', description: 'Disables all audio content', ariaLabel: 'Mute Sound - Disable all audio', switchFirst: false },
                { id: 'hide-images', title: 'Hide Images', description: 'Toggle to hide all images', ariaLabel: 'Hide Images - Hide all images on page', switchFirst: false },
                { id: 'read-mode', title: 'Read Mode', description: 'Removes navigation elements', ariaLabel: 'Read Mode - Simplify page for reading', switchFirst: false },
                { id: 'reading-guide', title: 'Reading Guide', description: 'Movable highlight bar', descriptionId: 'reading-guide-desc', ariaLabel: 'Reading Guide - Movable highlight bar', ariaDescribedBy: 'reading-guide-desc', switchFirst: false },
                { id: 'useful-links', title: 'Useful Links', description: 'Accessibility resources and links', descriptionId: 'useful-links-desc', ariaLabel: 'Useful Links - Accessibility resources and links', ariaDescribedBy: 'useful-links-desc', switchFirst: false },
                { id: 'stop-animation', title: 'Stop Animation', description: 'Pauses all CSS animations', ariaLabel: 'Stop Animation - Pauses all CSS animations' },
                { id: 'reading-mask', title: 'Reading Mask', description: 'Semi-transparent overlay', ariaLabel: 'Reading Mask - Focus on specific text area', switchFirst: false },
                { id: 'highlight-hover', title: 'Highlight Hover', description: 'Visual feedback on hover', ariaLabel: 'Highlight Hover - Highlight elements on mouse hover', switchFirst: false },
                { id: 'highlight-focus', title: 'Highlight Focus', description: 'Prominent focus indicators', ariaLabel: 'Highlight Focus - Highlight focused elements', switchFirst: false },
                { id: 'big-black-cursor', title: 'Big Black Cursor', description: 'Increases cursor size', ariaLabel: 'Big Black Cursor - Larger black mouse cursor', switchFirst: false },
                { id: 'big-white-cursor', title: 'Big White Cursor', description: 'Increases cursor size', ariaLabel: 'Big White Cursor - Larger white mouse cursor', switchFirst: false }
            ];
            
            profiles.forEach(profileConfig => {
                const profileItem = this.createProfileItem(profileConfig);
                whiteContentSection.appendChild(profileItem);
            });
            
            container.appendChild(whiteContentSection);
            
            // Panel Footer
            const panelFooter = document.createElement('div');
            panelFooter.className = 'panel-footer';
            const footerDiv = document.createElement('div');
            const checkIcon = document.createElement('i');
            checkIcon.className = 'fas fa-check';
            footerDiv.appendChild(checkIcon);
            panelFooter.appendChild(footerDiv);
            container.appendChild(panelFooter);
            
            // Hide Interface Modal
            const hideModal = document.createElement('div');
            hideModal.id = 'hide-interface-modal';
            hideModal.className = 'hide-interface-modal';
            hideModal.style.display = 'none';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            
            const modalHeader = document.createElement('div');
            modalHeader.className = 'modal-header';
            const modalTitle = document.createElement('h3');
            modalTitle.id = 'hide-modal-title';
            modalTitle.textContent = 'Hide Accessibility Interface?';
            modalHeader.appendChild(modalTitle);
            const modalClose = document.createElement('button');
            modalClose.className = 'modal-close';
            modalClose.id = 'hide-modal-close';
            modalClose.textContent = '';
            modalHeader.appendChild(modalClose);
            modalContent.appendChild(modalHeader);
            
            const modalBody = document.createElement('div');
            modalBody.className = 'modal-body';
            const modalText = document.createElement('p');
            modalText.id = 'hide-modal-text';
            modalText.textContent = 'Please note: If you choose to hide the accessibility interface, you won\'t be able to see it anymore, unless you clear your browsing history and data. Are you sure that you wish to hide the interface?';
            modalBody.appendChild(modalText);
            modalContent.appendChild(modalBody);
            
            const modalFooter = document.createElement('div');
            modalFooter.className = 'modal-footer';
            const acceptBtn = document.createElement('button');
            acceptBtn.id = 'hide-modal-accept';
            acceptBtn.className = 'modal-btn accept-btn';
            acceptBtn.textContent = 'Accept';
            modalFooter.appendChild(acceptBtn);
            const cancelBtn = document.createElement('button');
            cancelBtn.id = 'hide-modal-cancel';
            cancelBtn.className = 'modal-btn cancel-btn';
            cancelBtn.textContent = 'Cancel';
            modalFooter.appendChild(cancelBtn);
            modalContent.appendChild(modalFooter);
            
            hideModal.appendChild(modalContent);
            container.appendChild(hideModal);
        }
        
        // Keep old method for reference but mark as deprecated
        getPanelHTML() {
    
            return `
    
                <div class="panel-header">
    
                    <div class="close-btn" id="close-panel" tabindex="0" role="button" aria-label="Close accessibility panel">
    
                        
                    </div>
    
                    <div class="header-content">
    
                        <h2>Accessibility Adjustments</h2>
    
                    </div>
    
                    <div class="language-selector-header" id="language-selector-header" tabindex="0" role="button" aria-label="Select language" aria-expanded="false" aria-haspopup="listbox">
    
                        <span id="current-language-header">ENGLISH</span>
    
                        <i class="fas fa-chevron-down"></i>
    
                    </div>
    
                    <div class="action-buttons">
    
                            <div class="button-row">
    
                                <button id="reset-settings" class="action-btn" tabindex="0" aria-label="Reset all accessibility settings">
    
                                    <i class="fas fa-redo"></i>
    
                                    Reset Settings
    
                                </button>
    
                                <button id="statement" class="action-btn" tabindex="0" aria-label="View accessibility statement">
    
                                    <i class="fas fa-file-alt"></i>
    
                                    Statement
    
                                </button>
    
                            </div>
    
                            <div class="button-row">
    
                                <button id="hide-interface" class="action-btn" tabindex="0" aria-label="Hide accessibility interface">
    
                                    <i class="fas fa-eye-slash"></i>
    
                                    Hide Interface
    
                                </button>
    
                            </div>
    
                        </div>
    
                    </div>
    
                </div>
    
    
    
                <div class="white-content-section">
    
                    <h3>Choose the right accessibility profile for you</h3>
    
                    
    
                    <!-- Module 1: Seizure Safe Profile -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="seizure-safe" tabindex="0" aria-label="Seizure Safe Profile - Clear flashes and reduces color" aria-describedby="seizure-safe-desc">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Seizure Safe Profile</h4>
    
                                <p id="seizure-safe-desc">Clear flashes & reduces color</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 1.5: Reduce Motion -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="reduce-motion" tabindex="0" aria-label="Reduce Motion - Disable animations, transitions, and flash triggers" aria-describedby="reduce-motion-desc">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Reduce Motion</h4>
    
                                <p id="reduce-motion-desc">Disable animations and transitions</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 2: Vision Impaired Profile -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="vision-impaired" tabindex="0" aria-label="Vision Impaired Profile - Enhances text readability and visual clarity" aria-describedby="vision-impaired-desc">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Vision Impaired Profile</h4>
    
                                <p id="vision-impaired-desc">Enhances text readability and visual clarity</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 3: ADHD Friendly Profile -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="adhd-friendly" tabindex="0" aria-label="ADHD Friendly Profile - Reduces distractions and highlights focus">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>ADHD Friendly Profile</h4>
    
                                <p>More focus & fewer distractions</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 4: Cognitive Disability Profile -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="cognitive-disability" tabindex="0" aria-label="Cognitive Disability Profile - Simplifies interface and content">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Cognitive Disability Profile</h4>
    
                                <p>Assists with reading & focusing</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 5: Keyboard Navigation -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="keyboard-nav" tabindex="0" aria-label="Keyboard Navigation - Enable keyboard-only navigation">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Keyboard Navigation (Motor)</h4>
    
                                <p>Use website with the keyboard</p>
    
                                <div class="profile-description">
    
                                    <p>This profile enables motor-impaired persons to operate the website using keyboard keys and shortcuts</p>
    
    
                                </div>
    
                                <small style="color: #6366f1; font-style: italic; font-size: 12px; font-weight: normal;">Activates with Screen Reader</small>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 6: Blind Users Screen Reader -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="screen-reader" tabindex="0" aria-label="Screen Reader - Optimize for screen readers">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Blind Users (Screen Reader)</h4>
    
                                <p>Optimize website for screen-readers</p>
    
                                <div class="profile-description">
    
                                    <p>This profile adjusts the website to be compatible with screen-readers such as JAWS, NVDA, VoiceOver, and TalkBack. Screen-reader software is installed on the blind user's computer and smartphone, and websites should ensure compatibility.</p>
    
                                    
    
                                </div>
    
                                <small style="color: #6366f1; font-style: italic; font-size: 12px; font-weight: normal;">Activates with Keyboard Navigation</small>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 7: Content Scaling -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="content-scaling" tabindex="0" aria-label="Content Scaling - Adjust content size for better readability">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Content Scaling</h4>
    
                                <p>Scale content with arrow controls</p>
    
                                <div class="scaling-controls" id="content-scaling-controls" style="display: none; margin-top: 10px;">
    
                                    <div style="display: flex; align-items: center; gap: 10px;">
    
                                        <button class="scaling-btn" id="decrease-content-scale-btn" tabindex="0" aria-label="Decrease content scale by 2%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>-2%</span>
                                        </button>
    
                                        <span id="content-scale-value" style="font-weight: bold; min-width: 60px; text-align: center;">100%</span>
    
                                        <button class="scaling-btn" id="increase-content-scale-btn" tabindex="0" aria-label="Increase content scale by 2%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>+2%</span>
                                        </button>
    
                                    </div>
    
                                </div>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 8: Readable Font -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="readable-font" tabindex="0" aria-label="Readable Font - Use dyslexia-friendly fonts">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Readable Font</h4>
    
                                <p>High-legibility fonts</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 9: Highlight Titles -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="highlight-titles" tabindex="0" aria-label="Highlight Titles - Emphasize headings and titles">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Highlight Titles</h4>
    
                                <p>Add boxes around heading tags (h1-h6)</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 10: Highlight Links -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="highlight-links" tabindex="0" aria-label="Highlight Links - Emphasize clickable links">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Highlight Links</h4>
    
                                <p>Add boxes around links</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 11: Text Magnifier -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="text-magnifier" tabindex="0" aria-label="Text Magnifier - Enlarge text on hover">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Text Magnifier</h4>
    
                                <p>Floating magnifying glass tool</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 12: Adjust Font Sizing -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="font-sizing" tabindex="0" aria-label="Adjust Font Sizing - Font size with arrow controls" aria-describedby="font-sizing-desc">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Adjust Font Sizing</h4>
    
                                <p id="font-sizing-desc">Font size with arrow controls</p>
    
                                <div class="scaling-controls" id="font-sizing-controls" style="display: none; margin-top: 10px;">

                                    <div style="display: flex; align-items: center; gap: 10px;">

                                        <button class="scaling-btn" id="decrease-font-size-btn" tabindex="0" aria-label="Decrease font size by 5%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>-5%</span>
                                        </button>

                                        <span id="font-size-value" style="font-weight: bold; min-width: 60px; text-align: center;">100%</span>

                                        <button class="scaling-btn" id="increase-font-size-btn" tabindex="0" aria-label="Increase font size by 5%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>+5%</span>
                                        </button>

                                    </div>

                                </div>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 13: Align Center -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="align-center" tabindex="0" aria-label="Align Center - Center-align text content">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Align Center</h4>
    
                                <p>Center-aligns all text content</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 15: Adjust Line Height -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="adjust-line-height" tabindex="0" aria-label="Adjust Line Height - Increase spacing between lines">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Adjust Line Height</h4>
    
                                <p>Line height with arrow controls</p>
    
                                <div class="scaling-controls" id="line-height-controls" style="display: none; margin-top: 10px;">

                                    <div style="display: flex; align-items: center; gap: 10px;">

                                        <button class="scaling-btn" id="decrease-line-height-btn" tabindex="0" aria-label="Decrease line height by 10%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>-10%</span>
                                        </button>

                                        <span id="line-height-value" style="font-weight: bold; min-width: 60px; text-align: center;">100%</span>

                                        <button class="scaling-btn" id="increase-line-height-btn" tabindex="0" aria-label="Increase line height by 10%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>+10%</span>
                                        </button>

                                    </div>

                                </div>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 16: Adjust Letter Spacing -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="adjust-letter-spacing" tabindex="0" aria-label="Adjust Letter Spacing - Increase spacing between letters">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Adjust Letter Spacing</h4>
    
                                <p>Letter spacing with arrow controls</p>
    
                                <div class="scaling-controls" id="letter-spacing-controls" style="display: none; margin-top: 10px;">

                                    <div style="display: flex; align-items: center; gap: 10px;">

                                        <button class="scaling-btn" id="decrease-letter-spacing-btn" tabindex="0" aria-label="Decrease letter spacing by 10%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>-10%</span>
                                        </button>

                                        <span id="letter-spacing-value" style="font-weight: bold; min-width: 60px; text-align: center;">100%</span>

                                        <button class="scaling-btn" id="increase-letter-spacing-btn" tabindex="0" aria-label="Increase letter spacing by 10%" style="background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; height: 28px; min-width: 80px; padding: 6px 20px; text-align: center;">
                                            <span>+10%</span>
                                        </button>

                                    </div>

                                </div>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 17: Align Left -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="align-left" tabindex="0" aria-label="Align Left - Left-align text content">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Align Left</h4>
    
                                <p>Left-aligns text content</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 18: Align Right -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="align-right" tabindex="0" aria-label="Align Right - Right-align text content">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Align Right</h4>
    
                                <p>Right-aligns text content</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 19: Dark Contrast -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="dark-contrast" tabindex="0" aria-label="Dark Contrast - Apply dark color scheme">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Dark Contrast</h4>
    
                                <p>Dark background with light text</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 20: Light Contrast -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="light-contrast" tabindex="0" aria-label="Light Contrast - Apply light color scheme">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Light Contrast</h4>
    
                                <p>Light background with dark text</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 20: High Contrast -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="high-contrast" tabindex="0" aria-label="High Contrast - Apply high contrast colors">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>High Contrast</h4>
    
                                <p>Maximum contrast implementation</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 21: High Saturation -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="high-saturation" tabindex="0" aria-label="High Saturation - Increase color intensity">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>High Saturation</h4>
    
                                <p>Increases color intensity</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 22: Adjust Text Colors -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="adjust-text-colors" tabindex="0" aria-label="Adjust Text Colors - Modify text color scheme">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Adjust Text Colors</h4>
    
                                <p>Color picker functionality</p>
    
                            </div>
    
                        </div>
    
                    </div>
    
    
    
                    <!-- Module 23: Monochrome -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Monochrome</h4>
    
                                <p>Removes all colors except black, white, grays</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="monochrome" tabindex="0" aria-label="Monochrome - Apply grayscale color scheme">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 24: Adjust Title Colors -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Adjust Title Colors</h4>
    
                                <p>Color customization for headings</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="adjust-title-colors" tabindex="0" aria-label="Adjust Title Colors - Modify heading color scheme">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 25: Low Saturation -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Low Saturation</h4>
    
                                <p>Reduces color intensity</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="low-saturation" tabindex="0" aria-label="Low Saturation - Decrease color intensity">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 26: Adjust Background Colors -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Adjust Background Colors</h4>
    
                                <p>Background color customization</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="adjust-bg-colors" tabindex="0" aria-label="Adjust Background Colors - Modify background color scheme">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 27: Mute Sound -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Mute Sound</h4>
    
                                <p>Disables all audio content</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="mute-sound" tabindex="0" aria-label="Mute Sound - Disable all audio">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 28: Hide Images -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Hide Images</h4>
    
                                <p>Toggle to hide all images</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="hide-images" tabindex="0" aria-label="Hide Images - Hide all images on page">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 29: Read Mode -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Read Mode</h4>
    
                                <p>Removes navigation elements</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="read-mode" tabindex="0" aria-label="Read Mode - Simplify page for reading">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 30: Reading Guide -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Reading Guide</h4>
    
                                <p id="reading-guide-desc">Movable highlight bar</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="reading-guide" tabindex="0" aria-label="Reading Guide - Movable highlight bar" aria-describedby="reading-guide-desc">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
    
    
    
                    <!-- Module 32: Useful Links -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Useful Links</h4>
    
                                <p id="useful-links-desc">Accessibility resources and links</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="useful-links" tabindex="0" aria-label="Useful Links - Accessibility resources and links" aria-describedby="useful-links-desc">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 32: Stop Animation -->
    
                    <div class="profile-item">
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="stop-animation" tabindex="0" aria-label="Stop Animation - Pauses all CSS animations">
    
                            <span class="slider"></span>
    
                        </label>
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Stop Animation</h4>
    
                                <p>Pauses all CSS animations</p>
    
                            </div>
    
                        </div>
    
    
                    </div>
    
    
    
                    <!-- Module 33: Reading Mask -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Reading Mask</h4>
    
                                <p>Semi-transparent overlay</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="reading-mask" tabindex="0" aria-label="Reading Mask - Focus on specific text area">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 34: Highlight Hover -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Highlight Hover</h4>
    
                                <p>Visual feedback on hover</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="highlight-hover" tabindex="0" aria-label="Highlight Hover - Highlight elements on mouse hover">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 35: Highlight Focus -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Highlight Focus</h4>
    
                                <p>Prominent focus indicators</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="highlight-focus" tabindex="0" aria-label="Highlight Focus - Highlight focused elements">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 36: Big Black Cursor -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Big Black Cursor</h4>
    
                                <p>Increases cursor size</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="big-black-cursor" tabindex="0" aria-label="Big Black Cursor - Larger black mouse cursor">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
    
    
                    <!-- Module 37: Big White Cursor -->
    
                    <div class="profile-item">
    
                        <div class="profile-info">
    
                            <div>
    
                                <h4>Big White Cursor</h4>
    
                                <p>Increases cursor size</p>
    
                            </div>
    
                        </div>
    
                        <label class="toggle-switch">
    
                            <input type="checkbox" id="big-white-cursor" tabindex="0" aria-label="Big White Cursor - Larger white mouse cursor">
    
                            <span class="slider"></span>
    
                        </label>
    
                    </div>
    
                </div>
    
    
    
                <div class="panel-footer">
    
                    <div>
    
                        <i class="fas fa-check"></i>
    
                        
    
                    </div>
    
                </div>
    
                <!-- Hide Interface Confirmation Modal -->
                <div id="hide-interface-modal" class="hide-interface-modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 id="hide-modal-title">Hide Accessibility Interface?</h3>
                            <button class="modal-close" id="hide-modal-close">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p id="hide-modal-text">Please note: If you choose to hide the accessibility interface, you won't be able to see it anymore, unless you clear your browsing history and data. Are you sure that you wish to hide the interface?</p>
                        </div>
                        <div class="modal-footer">
                            <button id="hide-modal-accept" class="modal-btn accept-btn">Accept</button>
                            <button id="hide-modal-cancel" class="modal-btn cancel-btn">Cancel</button>
                        </div>
                    </div>
                </div>
    
            `;
    
        }
    
    
    
        createLanguageDropdownElements(container) {
            // Clear container
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            const dropdownContent = document.createElement('div');
            dropdownContent.className = 'language-dropdown-content';
            
            const languages = [
                { lang: 'en', flag: '', name: 'English', label: 'Select English language' },
                { lang: 'de', flag: '', name: 'Deutsch', label: 'Select German language' },
                { lang: 'fr', flag: '', name: 'Franais', label: 'Select French language' },
                { lang: 'he', flag: '', name: '', label: 'Select Hebrew language' },
                { lang: 'ru', flag: '', name: '', label: 'Select Russian language' },
                { lang: 'ar', flag: '', name: '', label: 'Select Arabic language' },
                { lang: 'es', flag: '', name: 'Espaol', label: 'Select Spanish language' },
                { lang: 'pt', flag: '', name: 'Portugus', label: 'Select Portuguese language' },
                { lang: 'it', flag: '', name: 'Italiano', label: 'Select Italian language' },
                { lang: 'tw', flag: '', name: '', label: 'Select Traditional Chinese language' }
            ];
            
            languages.forEach(langData => {
                const button = document.createElement('button');
                button.className = 'language-option';
                button.setAttribute('data-lang', langData.lang);
                button.setAttribute('data-flag', langData.flag);
                button.setAttribute('tabindex', '0');
                button.setAttribute('role', 'option');
                button.setAttribute('aria-label', langData.label);
                
                const flagSpan = document.createElement('span');
                flagSpan.className = 'flag';
                flagSpan.textContent = langData.flag;
                button.appendChild(flagSpan);
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'language-name';
                nameSpan.textContent = langData.name;
                button.appendChild(nameSpan);
                
                dropdownContent.appendChild(button);
            });
            
            container.appendChild(dropdownContent);
        }
    
    
    
        getTranslations() {
    
            return {
    
                en: {
    
                    title: "Accessibility Adjustments",
    
                    profilesTitle: "Choose the right accessibility profile for you",
    
                    seizureSafe: "Seizure Safe Profile",
    
                    seizureSafeDesc: "Clear flashes & reduces color",
    
                    visionImpaired: "Vision Impaired Profile",
    
                    visionImpairedDesc: "Enhances text readability and visual clarity",
    
                    adhdFriendly: "ADHD Friendly Profile",
    
                    adhdFriendlyDesc: "More focus & fewer distractions",
    
                    cognitiveDisability: "Cognitive Disability Profile",
    
                    cognitiveDisabilityDesc: "Assists with reading & focusing",
    
                    keyboardNav: "Keyboard Navigation (Motor)",
    
                    keyboardNavDesc: "Use website with the keyboard",
    
                    screenReader: "Blind Users (Screen Reader)",
    
                    screenReaderDesc: "Optimize website for screen-readers",
    
                    contentScaling: "Content Scaling",
    
                    contentScalingDesc: "Scale content with arrow controls",
    
                    readableFont: "Readable Font",
    
                    readableFontDesc: "High-legibility fonts",
    
                    highlightTitles: "Highlight Titles",
    
                    highlightTitlesDesc: "Add boxes around heading tags (h1-h6)",
    
                    highlightLinks: "Highlight Links",
    
                    highlightLinksDesc: "Add boxes around links",
    
                    textMagnifier: "Text Magnifier",
    
                    textMagnifierDesc: "Floating magnifying glass tool",
    
                    fontSizing: "Adjust Font Sizing",
    
                    fontSizingDesc: "Font size with arrow controls",
    
                    alignCenter: "Align Center",
    
                    alignCenterDesc: "Center-aligns all text content",
    
                    adjustLineHeight: "Adjust Line Height",
    
                    adjustLineHeightDesc: "Line height with arrow controls",
    
                    adjustLetterSpacing: "Adjust Letter Spacing",
    
                    adjustLetterSpacingDesc: "Letter spacing with arrow controls",
    
                    alignLeft: "Align Left",
    
                    alignLeftDesc: "Left-aligns text content",
    
                    alignRight: "Align Right",
    
                    alignRightDesc: "Right-aligns text content",
    
                    darkContrast: "Dark Contrast",
    
                    darkContrastDesc: "Dark background with light text",
    
                    lightContrast: "Light Contrast",
    
                    lightContrastDesc: "Light background with dark text",
    
                    highContrast: "High Contrast",
    
                    highContrastDesc: "Maximum contrast implementation",
    
                    highSaturation: "High Saturation",
    
                    highSaturationDesc: "Increases color intensity",
    
                    adjustTextColors: "Adjust Text Colors",
    
                    adjustTextColorsDesc: "Color picker functionality",
    
                    monochrome: "Monochrome",
    
                    monochromeDesc: "Removes all colors except black, white, grays",
    
                    adjustTitleColors: "Adjust Title Colors",
    
                    adjustTitleColorsDesc: "Color customization for headings",
    
                    lowSaturation: "Low Saturation",
    
                    lowSaturationDesc: "Reduces color intensity",
    
                    adjustBgColors: "Adjust Background Colors",
    
                    adjustBgColorsDesc: "Background color customization",
    
                    muteSound: "Mute Sound",
    
                    muteSoundDesc: "Disables all audio content",
    
                    hideImages: "Hide Images",
    
                    hideImagesDesc: "Toggle to hide all images",
    
                    readMode: "Read Mode",
    
                    readModeDesc: "Removes navigation elements",
    
                    readingGuide: "Reading Guide",
    
                    readingGuideDesc: "Movable highlight bar",
    
    
                    usefulLinks: "Useful Links",
    
                    usefulLinksDesc: "Accessibility resources and links",
    
    
                    readingMask: "Reading Mask",
    
                    readingMaskDesc: "Semi-transparent overlay",
    
                    highlightHover: "Highlight Hover",
    
                    highlightHoverDesc: "Visual feedback on hover",
    
                    highlightFocus: "Highlight Focus",
    
                    highlightFocusDesc: "Prominent focus indicators",
    
                    bigBlackCursor: "Big Black Cursor",
    
                    bigBlackCursorDesc: "Increases cursor size",
    
                    bigWhiteCursor: "Big White Cursor",
    
                    bigWhiteCursorDesc: "Increases cursor size",
    
                    reduceMotion: "Reduce Motion",
    
                    reduceMotionDesc: "Disable animations and transitions",
    
                    resetSettings: "Reset Settings",
    
                    statement: "Statement",
    
                    hideInterface: "Hide Interface",
    
                    accessibilityFeatures: "Accessibility Features",
    
                    // Additional detailed descriptions
    
                    keyboardNavDetailed: "This profile enables motor-impaired persons to operate the website using keyboard keys (Tab, Shift+Tab, Enter) and shortcuts (e.g., \"M\" for menus, \"H\" for headings, \"F\" for forms, \"B\" for buttons, \"G\" for graphics).",
    
                    keyboardNavNote: "Note: This profile prompts automatically for keyboard users.",
    
                    screenReaderDetailed: "This profile adjusts the website to be compatible with screen-readers such as JAWS, NVDA, VoiceOver, and TalkBack. Screen-reader software is installed on the blind user's computer and smartphone, and websites should ensure compatibility.",
    
                    screenReaderNote: "Note: This profile prompts automatically to screen-readers.",
    
                    activatesWithScreenReader: "Activates with Screen Reader",
    
                    activatesWithKeyboardNav: "Activates with Keyboard Navigation",
                    
                    // Hide Interface Modal
                    hideInterfaceModalTitle: "Hide Accessibility Interface?",
                    hideInterfaceModalText: "Please note: If you choose to hide the accessibility interface, you won't be able to see it anymore, unless you clear your browsing history and data. Are you sure that you wish to hide the interface?",
                    hideInterfaceModalAccept: "Accept",
                    hideInterfaceModalCancel: "Cancel",
    
                    // Toggle switch text
                    toggleOn: "ON",
                    toggleOff: "OFF"
    
                },
    
                es: {
                    title: "Ajustes de Accesibilidad",
                    profilesTitle: "Elige el perfil de accesibilidad adecuado para ti",
        seizureSafe: "Perfil Anti-Convulsiones",
                    seizureSafeDesc: "Elimina destellos y reduce colores",
        visionImpaired: "Perfil para Baja Visin",
        visionImpairedDesc: "Mejora la legibilidad del texto y la claridad visual",
                    adhdFriendly: "Perfil Amigable para TDAH",
                    adhdFriendlyDesc: "Ms enfoque y menos distracciones",
                    cognitiveDisability: "Perfil de Discapacidad Cognitiva",
        cognitiveDisabilityDesc: "Ayuda con la lectura y concentracin",
        keyboardNav: "Navegacin por Teclado (Motora)",
                    keyboardNavDesc: "Usar el sitio web con el teclado",
                    screenReader: "Usuarios Ciegos (Lector de Pantalla)",
                    screenReaderDesc: "Optimizar el sitio web para lectores de pantalla",
                    contentScaling: "Escalado de Contenido",
        contentScalingDesc: "Escalar contenido con controles de flechas",
                    readableFont: "Fuente Legible",
                    readableFontDesc: "Fuentes de alta legibilidad",
                    highlightTitles: "Resaltar Ttulos",
        highlightTitlesDesc: "Agregar marcos alrededor de los ttulos",
                    highlightLinks: "Resaltar Enlaces",
        highlightLinksDesc: "Agregar marcos alrededor de los enlaces",
                    textMagnifier: "Lupa de Texto",
                    textMagnifierDesc: "Herramienta de lupa flotante",
                    fontSizing: "Ajustar Tamao de Fuente",
        fontSizingDesc: "Tamao de fuente con controles de flechas",
        alignCenter: "Alinear al Centro",
        alignCenterDesc: "Centra todo el contenido de texto",
                    adjustLineHeight: "Ajustar Altura de Lnea",
        adjustLineHeightDesc: "Altura de lnea con controles de flechas",
                    adjustLetterSpacing: "Ajustar Espaciado de Letras",
        adjustLetterSpacingDesc: "Espaciado de letras con controles de flechas",
        alignLeft: "Alinear a la Izquierda",
                    alignLeftDesc: "Alinea el contenido de texto a la izquierda",
        alignRight: "Alinear a la Derecha",
                    alignRightDesc: "Alinea el contenido de texto a la derecha",
                    darkContrast: "Contraste Oscuro",
                    darkContrastDesc: "Fondo oscuro con texto claro",
                    lightContrast: "Contraste Claro",
                    lightContrastDesc: "Fondo claro con texto oscuro",
                    highContrast: "Alto Contraste",
                    highContrastDesc: "Implementacin de contraste mximo",
                    highSaturation: "Alta Saturacin",
        highSaturationDesc: "Aumenta la intensidad de colores",
                    adjustTextColors: "Ajustar Colores de Texto",
                    adjustTextColorsDesc: "Funcionalidad de selector de color",
                    monochrome: "Monocromo",
        monochromeDesc: "Elimina todos los colores excepto negro, blanco, gris",
                    adjustTitleColors: "Ajustar Colores de Ttulos",
        adjustTitleColorsDesc: "Personalizacin de colores para ttulos",
                    lowSaturation: "Baja Saturacin",
        lowSaturationDesc: "Reduce la intensidad de colores",
                    adjustBgColors: "Ajustar Colores de Fondo",
        adjustBgColorsDesc: "Personalizacin de colores de fondo",
                    muteSound: "Silenciar Sonido",
                    muteSoundDesc: "Desactiva todo el contenido de audio",
                    hideImages: "Ocultar Imgenes",
                    hideImagesDesc: "Alternar para ocultar todas las imgenes",
                    readMode: "Modo de Lectura",
                    readModeDesc: "Elimina elementos de navegacin",
                    readingGuide: "Gua de Lectura",
                    readingGuideDesc: "Barra de resaltado mvil",
                    usefulLinks: "Enlaces tiles",
                    usefulLinksDesc: "Recursos y enlaces de accesibilidad",
                    stopAnimation: "Detener Animacin",
                    stopAnimationDesc: "Pausa todas las animaciones CSS",
                    reduceMotion: "Reducir Movimiento",
                    reduceMotionDesc: "Desactivar animaciones y transiciones",
                    readingMask: "Mscara de Lectura",
                    readingMaskDesc: "Superposicin semi-transparente",
        highlightHover: "Resaltar al Pasar",
                    highlightHoverDesc: "Retroalimentacin visual al pasar el mouse",
                    highlightFocus: "Resaltar Enfoque",
                    highlightFocusDesc: "Indicadores de enfoque prominentes",
                    bigBlackCursor: "Cursor Negro Grande",
                    bigBlackCursorDesc: "Aumenta el tamao del cursor",
                    bigWhiteCursor: "Cursor Blanco Grande",
                    bigWhiteCursorDesc: "Aumenta el tamao del cursor",
                    resetSettings: "Restablecer Configuracin",
                    statement: "Declaracin",
                    hideInterface: "Ocultar Interfaz",
                    accessibilityFeatures: "Caractersticas de Accesibilidad",
    
        // Descripciones detalladas adicionales
        keyboardNavDetailed: "Este perfil permite a las personas con discapacidades motoras operar el sitio web usando teclas del teclado (Tab, Shift+Tab, Enter) y atajos (ej: \"M\" para mens, \"H\" para ttulos, \"F\" para formularios, \"B\" para botones, \"G\" para grficos).",
                    keyboardNavNote: "Nota: Este perfil se activa automticamente para usuarios de teclado.",
                    screenReaderDetailed: "Este perfil ajusta el sitio web para ser compatible con lectores de pantalla como JAWS, NVDA, VoiceOver y TalkBack. El software lector de pantalla est instalado en la computadora y smartphone del usuario ciego, y los sitios web deben asegurar compatibilidad.",
        screenReaderNote: "Nota: Este perfil se activa automticamente con lectores de pantalla.",
                    activatesWithScreenReader: "Se activa con Lector de Pantalla",
                    activatesWithKeyboardNav: "Se activa con Navegacin por Teclado",
                    
                    // Hide Interface Modal
                    hideInterfaceModalTitle: "Ocultar Interfaz de Accesibilidad?",
                    hideInterfaceModalText: "Tenga en cuenta: Si elige ocultar la interfaz de accesibilidad, no podr verla ms, a menos que borre el historial de navegacin y los datos. Est seguro de que desea ocultar la interfaz?",
                    hideInterfaceModalAccept: "Aceptar",
                    hideInterfaceModalCancel: "Cancelar",
    
                    // Toggle switch text
                    toggleOn: "S",
                    toggleOff: "NO"
                },
    
                de: {
    
                    title: "Barrierefreiheitseinstellungen",
    
                    profilesTitle: "Whlen Sie das richtige Barrierefreiheitsprofil fr Sie",
    
                    seizureSafe: "Anfallssicheres Profil",
    
                    seizureSafeDesc: "Entfernt Blitze und reduziert Farben",
    
                    visionImpaired: "Profil fr Sehbehinderte",
    
                    visionImpairedDesc: "Verbessert die Textlesbarkeit und visuelle Klarheit",
    
                    adhdFriendly: "ADHS-freundliches Profil",
    
                    adhdFriendlyDesc: "Mehr Fokus und weniger Ablenkungen",
    
                    cognitiveDisability: "Kognitives Behinderungsprofil",
    
                    cognitiveDisabilityDesc: "Hilft beim Lesen und Fokussieren",
    
                    keyboardNav: "Tastaturnavigation (Motor)",
    
                    keyboardNavDesc: "Website mit der Tastatur verwenden",
    
                    screenReader: "Blinde Benutzer (Bildschirmleser)",
    
                    screenReaderDesc: "Website fr Bildschirmleser optimieren",
    
                    contentScaling: "Inhaltsskalierung",
    
                    contentScalingDesc: "Inhalt mit Pfeilsteuerungen skalieren",
    
                    readableFont: "Lesbare Schriftart",
    
                    readableFontDesc: "Hochlegible Schriftarten",
    
                    highlightTitles: "berschriften hervorheben",
    
                    highlightTitlesDesc: "Ksten um berschriften hinzufgen",
    
                    highlightLinks: "Links hervorheben",
    
                    highlightLinksDesc: "Ksten um Links hinzufgen",
    
                    textMagnifier: "Textlupe",
    
                    textMagnifierDesc: "Schwebendes Lupenwerkzeug",
    
                    fontSizing: "Schriftgre anpassen",
    
                    fontSizingDesc: "Schriftgre mit Pfeilsteuerungen",
    
                    alignCenter: "Zentrieren",
    
                    alignCenterDesc: "Zentriert allen Textinhalt",
    
                    adjustLineHeight: "Zeilenhhe anpassen",
    
                    adjustLineHeightDesc: "Zeilenhhe mit Pfeilsteuerungen",
    
                    adjustLetterSpacing: "Buchstabenabstand anpassen",
    
                    adjustLetterSpacingDesc: "Buchstabenabstand mit Pfeilsteuerungen",
    
                    alignLeft: "Links ausrichten",
    
                    alignLeftDesc: "Richtet Textinhalt links aus",
    
                    alignRight: "Rechts ausrichten",
    
                    alignRightDesc: "Richtet Textinhalt rechts aus",
    
                    darkContrast: "Dunkler Kontrast",
    
                    darkContrastDesc: "Dunkler Hintergrund mit hellem Text",
    
                    lightContrast: "Heller Kontrast",
    
                    lightContrastDesc: "Heller Hintergrund mit dunklem Text",
    
                    highContrast: "Hoher Kontrast",
    
                    highContrastDesc: "Maximale Kontrastimplementierung",
    
                    highSaturation: "Hohe Sttigung",
    
                    highSaturationDesc: "Erhht die Farbintensitt",
    
                    adjustTextColors: "Textfarben anpassen",
    
                    adjustTextColorsDesc: "Farbauswahl-Funktionalitt",
    
                    monochrome: "Monochrom",
    
                    monochromeDesc: "Entfernt alle Farben auer Schwarz, Wei, Grau",
    
                    adjustTitleColors: "Titelfarben anpassen",
    
                    adjustTitleColorsDesc: "Farbanpassung fr berschriften",
    
                    lowSaturation: "Niedrige Sttigung",
    
                    lowSaturationDesc: "Reduziert die Farbintensitt",
    
                    adjustBgColors: "Hintergrundfarben anpassen",
    
                    adjustBgColorsDesc: "Hintergrundfarbanpassung",
    
                    muteSound: "Ton stummschalten",
    
                    muteSoundDesc: "Deaktiviert alle Audioinhalte",
    
                    hideImages: "Bilder ausblenden",
    
                    hideImagesDesc: "Umschalten zum Ausblenden aller Bilder",
    
                    readMode: "Lesemodus",
    
                    readModeDesc: "Entfernt Navigationselemente",
    
                    readingGuide: "Lesehilfe",
    
                    readingGuideDesc: "Bewegliche Hervorhebungsleiste",
    
                    usefulLinks: "Ntzliche Links",
    
                    usefulLinksDesc: "Barrierefreiheitsressourcen und Links",
    
                    stopAnimation: "Animation stoppen",
    
                    stopAnimationDesc: "Pausiert alle CSS-Animationen",
    
                    reduceMotion: "Bewegung reduzieren",
    
                    reduceMotionDesc: "Animationen und bergnge deaktivieren",
    
                    readingMask: "Lesemaske",
    
                    readingMaskDesc: "Halbdurchsichtige berlagerung",
    
                    highlightHover: "Hover hervorheben",
    
                    highlightHoverDesc: "Visuelles Feedback beim berfahren",
    
                    highlightFocus: "Fokus hervorheben",
    
                    highlightFocusDesc: "Prominente Fokusindikatoren",
    
                    bigBlackCursor: "Groer schwarzer Cursor",
    
                    bigBlackCursorDesc: "Erhht die Cursorgre",
    
                    bigWhiteCursor: "Groer weier Cursor",
    
                    bigWhiteCursorDesc: "Erhht die Cursorgre",
    
                    resetSettings: "Einstellungen zurcksetzen",
    
                    statement: "Erklrung",
    
                    hideInterface: "Schnittstelle ausblenden",
    
                    accessibilityFeatures: "Barrierefreiheitsfunktionen",
    
                    // Additional detailed descriptions
    
                    keyboardNavDetailed: "Dieses Profil ermglicht es motorisch beeintrchtigten Personen, die Website mit Tastaturtasten (Tab, Shift+Tab, Enter) und Tastenkombinationen zu bedienen (z.B. \"M\" fr Mens, \"H\" fr berschriften, \"F\" fr Formulare, \"B\" fr Schaltflchen, \"G\" fr Grafiken).",
    
                    keyboardNavNote: "Hinweis: Dieses Profil wird automatisch fr Tastaturnutzer aktiviert.",
    
                    screenReaderDetailed: "Dieses Profil passt die Website fr die Kompatibilitt mit Bildschirmlesern wie JAWS, NVDA, VoiceOver und TalkBack an. Die Bildschirmleser-Software ist auf dem Computer und Smartphone des blinden Benutzers installiert, und Websites sollten die Kompatibilitt sicherstellen.",
    
                    screenReaderNote: "Hinweis: Dieses Profil wird automatisch fr Bildschirmleser aktiviert.",
    
                    activatesWithScreenReader: "Aktiviert sich mit Bildschirmleser",
    
                    activatesWithKeyboardNav: "Aktiviert sich mit Tastaturnavigation",
                    
                    // Hide Interface Modal
                    hideInterfaceModalTitle: "Barrierefreiheits-Interface ausblenden?",
                    hideInterfaceModalText: "Bitte beachten Sie: Wenn Sie sich entscheiden, das Barrierefreiheits-Interface auszublenden, knnen Sie es nicht mehr sehen, es sei denn, Sie lschen Ihren Browserverlauf und Ihre Daten. Sind Sie sicher, dass Sie das Interface ausblenden mchten?",
                    hideInterfaceModalAccept: "Akzeptieren",
                    hideInterfaceModalCancel: "Abbrechen",
    
                    // Toggle switch text
                    toggleOn: "EIN",
                    toggleOff: "AUS"
    
                },
    
                fr: {
        title: "Ajustements d'accessibilit",
        profilesTitle: "Choisissez le bon profil d'accessibilit pour vous",
        seizureSafe: "Profil Anti-pilepsie",
        seizureSafeDesc: "limine les flashs et rduit les couleurs",
        visionImpaired: "Profil pour Malvoyants",
        visionImpairedDesc: "Amliore la lisibilit du texte et la clart visuelle",
        adhdFriendly: "Profil TDAH",
        adhdFriendlyDesc: "Plus de concentration et moins de distractions",
        cognitiveDisability: "Profil Dficience Cognitive",
        cognitiveDisabilityDesc: "Aide  la lecture et  la concentration",
        keyboardNav: "Navigation Clavier (Moteur)",
        keyboardNavDesc: "Utiliser le site web avec le clavier",
        screenReader: "Utilisateurs Aveugles (Lecteur d'cran)",
        screenReaderDesc: "Optimiser le site web pour les lecteurs d'cran",
        contentScaling: "Mise  l'chelle du contenu",
        contentScalingDesc: "Mettre  l'chelle le contenu avec les contrles flchs",
        readableFont: "Police Lisible",
        readableFontDesc: "Polices  haute lisibilit",
        highlightTitles: "Surligner les Titres",
        highlightTitlesDesc: "Ajouter des encadrs autour des titres",
        highlightLinks: "Surligner les Liens",
        highlightLinksDesc: "Ajouter des encadrs autour des liens",
        textMagnifier: "Loupe de Texte",
        textMagnifierDesc: "Outil de loupe flottant",
        fontSizing: "Ajuster la Taille de Police",
        fontSizingDesc: "Taille de police avec les contrles flchs",
        alignCenter: "Centrer",
        alignCenterDesc: "Centre tout le contenu texte",
        adjustLineHeight: "Ajuster l'Interlignage",
        adjustLineHeightDesc: "Interlignage avec les contrles flchs",
        adjustLetterSpacing: "Ajuster l'Espacement des Lettres",
        adjustLetterSpacingDesc: "Espacement des lettres avec les contrles flchs",
        alignLeft: "Aligner  Gauche",
        alignLeftDesc: "Aligne le contenu texte  gauche",
        alignRight: "Aligner  Droite",
        alignRightDesc: "Aligne le contenu texte  droite",
        darkContrast: "Contraste Sombre",
        darkContrastDesc: "Arrire-plan sombre avec texte clair",
        lightContrast: "Contraste Clair",
        lightContrastDesc: "Arrire-plan clair avec texte sombre",
        highContrast: "Contraste lev",
        highContrastDesc: "Implmentation de contraste maximum",
        highSaturation: "Saturation leve",
        highSaturationDesc: "Augmente l'intensit des couleurs",
        adjustTextColors: "Ajuster les Couleurs du Texte",
        adjustTextColorsDesc: "Fonctionnalit de slecteur de couleur",
        monochrome: "Monochrome",
        monochromeDesc: "Supprime toutes les couleurs sauf noir, blanc, gris",
        adjustTitleColors: "Ajuster les Couleurs des Titres",
        adjustTitleColorsDesc: "Personnalisation des couleurs pour les titres",
        lowSaturation: "Saturation Faible",
        lowSaturationDesc: "Rduit l'intensit des couleurs",
        adjustBgColors: "Ajuster les Couleurs d'Arrire-plan",
        adjustBgColorsDesc: "Personnalisation des couleurs d'arrire-plan",
        muteSound: "Couper le Son",
        muteSoundDesc: "Dsactive tout le contenu audio",
        hideImages: "Masquer les Images",
        hideImagesDesc: "Basculer pour masquer toutes les images",
        readMode: "Mode Lecture",
        readModeDesc: "Supprime les lments de navigation",
        readingGuide: "Guide de Lecture",
        readingGuideDesc: "Barre de surlignage mobile",
        usefulLinks: "Liens Utiles",
        usefulLinksDesc: "Ressources et liens d'accessibilit",
        stopAnimation: "Arrter l'Animation",
        stopAnimationDesc: "Met en pause toutes les animations CSS",
        reduceMotion: "Rduire le Mouvement",
        reduceMotionDesc: "Dsactiver les animations et transitions",
        readingMask: "Masque de Lecture",
        readingMaskDesc: "Superposition semi-transparente",
        highlightHover: "Surligner au Survol",
        highlightHoverDesc: "Retour visuel au survol",
        highlightFocus: "Surligner le Focus",
        highlightFocusDesc: "Indicateurs de focus prominents",
        bigBlackCursor: "Gros Curseur Noir",
        bigBlackCursorDesc: "Augmente la taille du curseur",
        bigWhiteCursor: "Gros Curseur Blanc",
        bigWhiteCursorDesc: "Augmente la taille du curseur",
        resetSettings: "Rinitialiser les Paramtres",
        statement: "Dclaration",
        hideInterface: "Masquer l'Interface",
        accessibilityFeatures: "Fonctionnalits d'Accessibilit",
        
        // Descriptions dtailles supplmentaires
        keyboardNavDetailed: "Ce profil permet aux personnes ayant des dficiences motrices d'utiliser le site web avec les touches du clavier (Tab, Shift+Tab, Entre) et les raccourcis (ex: \"M\" pour les menus, \"H\" pour les titres, \"F\" pour les formulaires, \"B\" pour les boutons, \"G\" pour les graphiques).",
        keyboardNavNote: "Note: Ce profil se dclenche automatiquement pour les utilisateurs de clavier.",
        screenReaderDetailed: "Ce profil ajuste le site web pour tre compatible avec les lecteurs d'cran comme JAWS, NVDA, VoiceOver et TalkBack. Le logiciel de lecteur d'cran est install sur l'ordinateur et le smartphone de l'utilisateur aveugle, et les sites web doivent assurer la compatibilit.",
        screenReaderNote: "Note: Ce profil se dclenche automatiquement avec les lecteurs d'cran.",
        activatesWithScreenReader: "S'active avec le Lecteur d'cran",
        activatesWithKeyboardNav: "S'active avec la Navigation Clavier",
        
        // Hide Interface Modal
        hideInterfaceModalTitle: "Masquer l'Interface d'Accessibilit?",
        hideInterfaceModalText: "Veuillez noter: Si vous choisissez de masquer l'interface d'accessibilit, vous ne pourrez plus la voir, sauf si vous effacez votre historique de navigation et vos donnes. tes-vous sr de vouloir masquer l'interface?",
        hideInterfaceModalAccept: "Accepter",
        hideInterfaceModalCancel: "Annuler",
    
        // Toggle switch text
        toggleOn: "OUI",
        toggleOff: "NON"
    },
    
                pt: {
                    title: "Ajustes de Acessibilidade",
        profilesTitle: "Escolha o perfil de acessibilidade certo para voc",
        seizureSafe: "Perfil Anti-Convulses",
        seizureSafeDesc: "Elimina flashes e reduz cores",
        visionImpaired: "Perfil para Baixa Viso",
        visionImpairedDesc: "Melhora a legibilidade do texto e a clareza visual",
                    adhdFriendly: "Perfil Amigvel para TDAH",
        adhdFriendlyDesc: "Mais foco e menos distraes",
                    cognitiveDisability: "Perfil de Deficincia Cognitiva",
        cognitiveDisabilityDesc: "Ajuda com leitura e concentrao",
        keyboardNav: "Navegao por Teclado (Motora)",
                    keyboardNavDesc: "Usar o site com o teclado",
                    screenReader: "Usurios Cegos (Leitor de Tela)",
                    screenReaderDesc: "Otimizar o site para leitores de tela",
                    contentScaling: "Escala de Contedo",
        contentScalingDesc: "Escalar contedo com controles de setas",
                    readableFont: "Fonte Legvel",
                    readableFontDesc: "Fontes de alta legibilidade",
                    highlightTitles: "Destacar Ttulos",
        highlightTitlesDesc: "Adicionar molduras ao redor dos ttulos",
                    highlightLinks: "Destacar Links",
        highlightLinksDesc: "Adicionar molduras ao redor dos links",
                    textMagnifier: "Lupa de Texto",
                    textMagnifierDesc: "Ferramenta de lupa flutuante",
        fontSizing: "Ajustar Tamanho da Fonte",
        fontSizingDesc: "Tamanho da fonte com controles de setas",
        alignCenter: "Alinhar ao Centro",
                    alignCenterDesc: "Centraliza todo o contedo de texto",
                    adjustLineHeight: "Ajustar Altura da Linha",
        adjustLineHeightDesc: "Altura da linha com controles de setas",
                    adjustLetterSpacing: "Ajustar Espaamento das Letras",
        adjustLetterSpacingDesc: "Espaamento das letras com controles de setas",
        alignLeft: "Alinhar  Esquerda",
                    alignLeftDesc: "Alinha o contedo de texto  esquerda",
        alignRight: "Alinhar  Direita",
                    alignRightDesc: "Alinha o contedo de texto  direita",
                    darkContrast: "Contraste Escuro",
                    darkContrastDesc: "Fundo escuro com texto claro",
                    lightContrast: "Contraste Claro",
                    lightContrastDesc: "Fundo claro com texto escuro",
                    highContrast: "Alto Contraste",
                    highContrastDesc: "Implementao de contraste mximo",
                    highSaturation: "Alta Saturao",
        highSaturationDesc: "Aumenta a intensidade das cores",
                    adjustTextColors: "Ajustar Cores do Texto",
                    adjustTextColorsDesc: "Funcionalidade de seletor de cor",
                    monochrome: "Monocromtico",
        monochromeDesc: "Remove todas as cores exceto preto, branco, cinza",
                    adjustTitleColors: "Ajustar Cores dos Ttulos",
        adjustTitleColorsDesc: "Personalizao de cores para ttulos",
                    lowSaturation: "Baixa Saturao",
        lowSaturationDesc: "Reduz a intensidade das cores",
                    adjustBgColors: "Ajustar Cores de Fundo",
        adjustBgColorsDesc: "Personalizao de cores de fundo",
                    muteSound: "Silenciar Som",
                    muteSoundDesc: "Desativa todo o contedo de udio",
                    hideImages: "Ocultar Imagens",
                    hideImagesDesc: "Alternar para ocultar todas as imagens",
                    readMode: "Modo de Leitura",
                    readModeDesc: "Remove elementos de navegao",
                    readingGuide: "Guia de Leitura",
                    readingGuideDesc: "Barra de destaque mvel",
                    usefulLinks: "Links teis",
                    usefulLinksDesc: "Recursos e links de acessibilidade",
                    stopAnimation: "Parar Animao",
                    stopAnimationDesc: "Pausa todas as animaes CSS",
                    reduceMotion: "Reduzir Movimento",
                    reduceMotionDesc: "Desativar animaes e transies",
                    readingMask: "Mscara de Leitura",
                    readingMaskDesc: "Sobreposio semi-transparente",
        highlightHover: "Destacar ao Passar",
                    highlightHoverDesc: "Feedback visual ao passar o mouse",
                    highlightFocus: "Destacar Foco",
                    highlightFocusDesc: "Indicadores de foco proeminentes",
                    bigBlackCursor: "Cursor Preto Grande",
                    bigBlackCursorDesc: "Aumenta o tamanho do cursor",
                    bigWhiteCursor: "Cursor Branco Grande",
                    bigWhiteCursorDesc: "Aumenta o tamanho do cursor",
                    resetSettings: "Redefinir Configuraes",
                    statement: "Declarao",
                    hideInterface: "Ocultar Interface",
                    accessibilityFeatures: "Recursos de Acessibilidade",
    
        // Descries detalhadas adicionais
        keyboardNavDetailed: "Este perfil permite que pessoas com deficincias motoras operem o site usando teclas do teclado (Tab, Shift+Tab, Enter) e atalhos (ex: \"M\" para menus, \"H\" para ttulos, \"F\" para formulrios, \"B\" para botes, \"G\" para grficos).",
                    keyboardNavNote: "Nota: Este perfil  ativado automaticamente para usurios de teclado.",
                    screenReaderDetailed: "Este perfil ajusta o site para ser compatvel com leitores de tela como JAWS, NVDA, VoiceOver e TalkBack. O software leitor de tela est instalado no computador e smartphone do usurio cego, e os sites devem garantir compatibilidade.",
        screenReaderNote: "Nota: Este perfil  ativado automaticamente com leitores de tela.",
                    activatesWithScreenReader: "Ativa com Leitor de Tela",
                    activatesWithKeyboardNav: "Ativa com Navegao por Teclado",
                    
                    // Hide Interface Modal
                    hideInterfaceModalTitle: "Ocultar Interface de Acessibilidade?",
                    hideInterfaceModalText: "Por favor, note: Se voc escolher ocultar a interface de acessibilidade, no conseguir v-la novamente, a menos que limpe o histrico de navegao e os dados. Tem certeza de que deseja ocultar a interface?",
                    hideInterfaceModalAccept: "Aceitar",
                    hideInterfaceModalCancel: "Cancelar",
    
                    // Toggle switch text
                    toggleOn: "SIM",
                    toggleOff: "NO"
                },
    
                it: {
        title: "Impostazioni di Accessibilit",
                    profilesTitle: "Scegli il profilo di accessibilit giusto per te",
        seizureSafe: "Profilo Anti-Epilettico",
        seizureSafeDesc: "Elimina i flash e riduce i colori",
        visionImpaired: "Profilo per Ipovedenti",
        visionImpairedDesc: "Migliora la leggibilit del testo e la chiarezza visiva",
                    adhdFriendly: "Profilo Amichevole per ADHD",
        adhdFriendlyDesc: "Pi concentrazione e meno distrazioni",
        cognitiveDisability: "Profilo per Disabilit Cognitive",
                    cognitiveDisabilityDesc: "Aiuta con la lettura e la concentrazione",
        keyboardNav: "Navigazione da Tastiera (Motoria)",
                    keyboardNavDesc: "Usare il sito web con la tastiera",
                    screenReader: "Utenti Ciechi (Lettore di Schermo)",
                    screenReaderDesc: "Ottimizzare il sito web per i lettori di schermo",
        contentScaling: "Ridimensionamento Contenuto",
        contentScalingDesc: "Ridimensionare il contenuto con controlli frecce",
        readableFont: "Font Leggibile",
        readableFontDesc: "Font ad alta leggibilit",
        highlightTitles: "Evidenziare Titoli",
        highlightTitlesDesc: "Aggiungere cornici attorno ai titoli",
        highlightLinks: "Evidenziare Link",
        highlightLinksDesc: "Aggiungere cornici attorno ai link",
                    textMagnifier: "Lente di Ingrandimento Testo",
                    textMagnifierDesc: "Strumento lente di ingrandimento flottante",
        fontSizing: "Regolare Dimensione Font",
        fontSizingDesc: "Dimensione font con controlli frecce",
        alignCenter: "Allineare al Centro",
                    alignCenterDesc: "Centra tutto il contenuto di testo",
        adjustLineHeight: "Regolare Altezza Riga",
        adjustLineHeightDesc: "Altezza riga con controlli frecce",
        adjustLetterSpacing: "Regolare Spaziatura Lettere",
        adjustLetterSpacingDesc: "Spaziatura lettere con controlli frecce",
        alignLeft: "Allineare a Sinistra",
                    alignLeftDesc: "Allinea il contenuto di testo a sinistra",
        alignRight: "Allineare a Destra",
                    alignRightDesc: "Allinea il contenuto di testo a destra",
                    darkContrast: "Contrasto Scuro",
                    darkContrastDesc: "Sfondo scuro con testo chiaro",
                    lightContrast: "Contrasto Chiaro",
                    lightContrastDesc: "Sfondo chiaro con testo scuro",
                    highContrast: "Alto Contrasto",
                    highContrastDesc: "Implementazione di contrasto massimo",
                    highSaturation: "Alta Saturazione",
        highSaturationDesc: "Aumenta l'intensit dei colori",
        adjustTextColors: "Regolare Colori Testo",
        adjustTextColorsDesc: "Funzionalit selettore colori",
                    monochrome: "Monocromatico",
        monochromeDesc: "Rimuove tutti i colori eccetto nero, bianco, grigio",
        adjustTitleColors: "Regolare Colori Titoli",
        adjustTitleColorsDesc: "Personalizzazione colori per i titoli",
                    lowSaturation: "Bassa Saturazione",
        lowSaturationDesc: "Riduce l'intensit dei colori",
        adjustBgColors: "Regolare Colori Sfondo",
        adjustBgColorsDesc: "Personalizzazione colori di sfondo",
                    muteSound: "Disattiva Suono",
                    muteSoundDesc: "Disabilita tutto il contenuto audio",
        hideImages: "Nascondere Immagini",
                    hideImagesDesc: "Attiva/disattiva per nascondere tutte le immagini",
                    readMode: "Modalit Lettura",
                    readModeDesc: "Rimuove elementi di navigazione",
                    readingGuide: "Guida alla Lettura",
                    readingGuideDesc: "Barra di evidenziazione mobile",
                    usefulLinks: "Link Utili",
                    usefulLinksDesc: "Risorse e link di accessibilit",
        stopAnimation: "Fermare Animazione",
                    stopAnimationDesc: "Mette in pausa tutte le animazioni CSS",
                    reduceMotion: "Ridurre Movimento",
                    reduceMotionDesc: "Disattiva animazioni e transizioni",
                    readingMask: "Maschera di Lettura",
                    readingMaskDesc: "Sovrapposizione semi-trasparente",
        highlightHover: "Evidenziare al Passaggio",
                    highlightHoverDesc: "Feedback visivo al passaggio del mouse",
        highlightFocus: "Evidenziare Focus",
                    highlightFocusDesc: "Indicatori di focus prominenti",
                    bigBlackCursor: "Cursore Nero Grande",
                    bigBlackCursorDesc: "Aumenta la dimensione del cursore",
                    bigWhiteCursor: "Cursore Bianco Grande",
                    bigWhiteCursorDesc: "Aumenta la dimensione del cursore",
                    resetSettings: "Ripristina Impostazioni",
                    statement: "Dichiarazione",
        hideInterface: "Nascondere Interfaccia",
                    accessibilityFeatures: "Funzionalit di Accessibilit",
    
        // Descrizioni dettagliate aggiuntive
        keyboardNavDetailed: "Questo profilo consente alle persone con disabilit motorie di operare il sito web usando i tasti della tastiera (Tab, Shift+Tab, Enter) e scorciatoie (es: \"M\" per i menu, \"H\" per i titoli, \"F\" per i moduli, \"B\" per i pulsanti, \"G\" per i grafici).",
                    keyboardNavNote: "Nota: Questo profilo si attiva automaticamente per gli utenti della tastiera.",
                    screenReaderDetailed: "Questo profilo regola il sito web per essere compatibile con i lettori di schermo come JAWS, NVDA, VoiceOver e TalkBack. Il software lettore di schermo  installato sul computer e smartphone dell'utente cieco, e i siti web devono garantire la compatibilit.",
        screenReaderNote: "Nota: Questo profilo si attiva automaticamente con i lettori di schermo.",
                    activatesWithScreenReader: "Si attiva con Lettore di Schermo",
                    activatesWithKeyboardNav: "Si attiva con Navigazione da Tastiera",
                    
                    // Hide Interface Modal
                    hideInterfaceModalTitle: "Nascondere l'Interfaccia di Accessibilit?",
                    hideInterfaceModalText: "Si prega di notare: Se scegli di nascondere l'interfaccia di accessibilit, non potrai pi vederla, a meno che non cancelli la cronologia di navigazione e i dati. Sei sicuro di voler nascondere l'interfaccia?",
                    hideInterfaceModalAccept: "Accetta",
                    hideInterfaceModalCancel: "Annulla",
    
                    // Toggle switch text
                    toggleOn: "S",
                    toggleOff: "NO"
    },
    
                il: {
        title: " ",
        profilesTitle: "     ",
        seizureSafe: "   ",
        seizureSafeDesc: "   ",
        visionImpaired: "  ",
        visionImpairedDesc: "      ",
        adhdFriendly: "  -ADHD",
        adhdFriendlyDesc: "    ",
        cognitiveDisability: "  ",
        cognitiveDisabilityDesc: "  ",
        keyboardNav: "  ()",
        keyboardNavDesc: "   ",
        screenReader: "  ( )",
        screenReaderDesc: "    ",
        contentScaling: " ",
        contentScalingDesc: "    ",
        readableFont: " ",
        readableFontDesc: "   ",
        highlightTitles: " ",
        highlightTitlesDesc: "   ",
        highlightLinks: " ",
        highlightLinksDesc: "   ",
        textMagnifier: "  ",
        textMagnifierDesc: "   ",
        fontSizing: "  ",
        fontSizingDesc: "    ",
        alignCenter: " ",
        alignCenterDesc: "    ",
        adjustLineHeight: "  ",
        adjustLineHeightDesc: "    ",
        adjustLetterSpacing: "   ",
        adjustLetterSpacingDesc: "     ",
        alignLeft: " ",
        alignLeftDesc: "   ",
        alignRight: " ",
        alignRightDesc: "   ",
        darkContrast: " ",
        darkContrastDesc: "    ",
        lightContrast: " ",
        lightContrastDesc: "    ",
        highContrast: " ",
        highContrastDesc: "  ",
        highSaturation: " ",
        highSaturationDesc: "  ",
        adjustTextColors: "  ",
        adjustTextColorsDesc: "  ",
        monochrome: "",
        monochromeDesc: "     , , ",
        adjustTitleColors: "  ",
        adjustTitleColorsDesc: "    ",
        lowSaturation: " ",
        lowSaturationDesc: "  ",
        adjustBgColors: "  ",
        adjustBgColorsDesc: "    ",
        muteSound: " ",
        muteSoundDesc: "    ",
        hideImages: " ",
        hideImagesDesc: "   ",
        readMode: " ",
        readModeDesc: "  ",
        readingGuide: " ",
        readingGuideDesc: "  ",
        usefulLinks: " ",
        usefulLinksDesc: "  ",
        stopAnimation: " ",
        stopAnimationDesc: "    -CSS",
        reduceMotion: " ",
        reduceMotionDesc: "  ",
        readingMask: " ",
        readingMaskDesc: "   ",
        highlightHover: "  ",
        highlightHoverDesc: "   ",
        highlightFocus: " ",
        highlightFocusDesc: "  ",
        bigBlackCursor: "  ",
        bigBlackCursorDesc: "   ",
        bigWhiteCursor: "  ",
        bigWhiteCursorDesc: "   ",
        resetSettings: " ",
        statement: "",
        hideInterface: " ",
        accessibilityFeatures: " ",
        
        //   
        keyboardNavDetailed: "             (Tab, Shift+Tab, Enter)   ( \"M\" , \"H\" , \"F\" , \"B\" , \"G\" ).",
        keyboardNavNote: ":      .",
        screenReaderDetailed: "          JAWS, NVDA, VoiceOver -TalkBack.         ,    .",
        screenReaderNote: ":       .",
        activatesWithScreenReader: "   ",
        activatesWithKeyboardNav: "   ",
        
        // Hide Interface Modal
        hideInterfaceModalTitle: "   ?",
        hideInterfaceModalText: " :      ,     ,       .       ?",
        hideInterfaceModalAccept: "",
        hideInterfaceModalCancel: "",
    
        // Toggle switch text
        toggleOn: "",
        toggleOff: ""
                },
    
                he: {
    
                    title: " ",
    
                    profilesTitle: "     ",
    
                    seizureSafe: "  ",
    
                    seizureSafeDesc: "   ",
    
                    visionImpaired: "  ",
    
                    visionImpairedDesc: "      ",
    
                    adhdFriendly: "  -ADHD",
    
                    adhdFriendlyDesc: "    ",
    
                    cognitiveDisability: "  ",
    
                    cognitiveDisabilityDesc: "   ",
    
                    keyboardNav: "  ()",
    
                    keyboardNavDesc: "   ",
    
                    screenReader: "  ( )",
    
                    screenReaderDesc: "    ",
    
                    contentScaling: "  ",
    
                    contentScalingDesc: "     ",
    
                    readableFont: " ",
    
                    readableFontDesc: "   ",
    
                    highlightTitles: " ",
    
                    highlightTitlesDesc: "   ",
    
                    highlightLinks: " ",
    
                    highlightLinksDesc: "   ",
    
                    textMagnifier: "  ",
    
                    textMagnifierDesc: "   ",
    
                    fontSizing: " ",
    
                    fontSizingDesc: "     ",
    
                    alignCenter: " ",
    
                    alignCenterDesc: "    ",
    
                    adjustLineHeight: "  ",
    
                    adjustLineHeightDesc: "     ",
    
                    adjustLetterSpacing: "   ",
    
                    adjustLetterSpacingDesc: "      ",
    
                    alignLeft: " ",
    
                    alignLeftDesc: "    ",
    
                    alignRight: " ",
    
                    alignRightDesc: "    ",
    
                    darkContrast: " ",
    
                    darkContrastDesc: "    ",
    
                    lightContrast: " ",
    
                    lightContrastDesc: "    ",
    
                    highContrast: " ",
    
                    highContrastDesc: "  ",
    
                    highSaturation: " ",
    
                    highSaturationDesc: "   ",
    
                    adjustTextColors: "  ",
    
                    adjustTextColorsDesc: "  ",
    
                    monochrome: "",
    
                    monochromeDesc: "     , , ",
    
                    adjustTitleColors: "  ",
    
                    adjustTitleColorsDesc: "    ",
    
                    lowSaturation: " ",
    
                    lowSaturationDesc: "   ",
    
                    adjustBgColors: "  ",
    
                    adjustBgColorsDesc: "    ",
    
                    muteSound: " ",
    
                    muteSoundDesc: "    ",
    
                    hideImages: " ",
    
                    hideImagesDesc: "    ",
    
                    readMode: " ",
    
                    readModeDesc: "  ",
    
                    readingGuide: " ",
    
                    readingGuideDesc: "  ",
    
                    usefulLinks: " ",
    
                    usefulLinksDesc: "  ",
    
                    stopAnimation: " ",
    
                    stopAnimationDesc: "    CSS",
    
                    reduceMotion: " ",
    
                    reduceMotionDesc: "  ",
    
                    readingMask: " ",
    
                    readingMaskDesc: "   ",
    
                    highlightHover: " hover",
    
                    highlightHoverDesc: "    ",
    
                    highlightFocus: " ",
    
                    highlightFocusDesc: "  ",
    
                    bigBlackCursor: "  ",
    
                    bigBlackCursorDesc: "   ",
    
                    bigWhiteCursor: "  ",
    
                    bigWhiteCursorDesc: "   ",
    
                    resetSettings: " ",
    
                    statement: "",
    
                    hideInterface: " ",
    
                    accessibilityFeatures: " ",
    
                    // Additional detailed descriptions
    
                    keyboardNavDetailed: "             (Tab, Shift+Tab, Enter)   ( \"M\" , \"H\" , \"F\" , \"B\" , \"G\" ).",
    
                    keyboardNavNote: ":      .",
    
                    screenReaderDetailed: "          JAWS, NVDA, VoiceOver -TalkBack.         ,    .",
    
                    screenReaderNote: ":      .",
    
                    activatesWithScreenReader: "   ",
    
                    activatesWithKeyboardNav: "   ",
                    
                    // Hide Interface Modal
                    hideInterfaceModalTitle: "   ?",
                    hideInterfaceModalText: " :      ,     ,       .       ?",
                    hideInterfaceModalAccept: "",
                    hideInterfaceModalCancel: "",
    
                    // Toggle switch text
                    toggleOn: "",
                    toggleOff: ""
    
                },
    
                ru: {
                    title: " ",
        profilesTitle: "   ",
        seizureSafe: "  ",
        seizureSafeDesc: "    ",
        visionImpaired: "  ",
        visionImpairedDesc: "     ",
                    adhdFriendly: "  ",
        adhdFriendlyDesc: "     ",
                    cognitiveDisability: "  ",
                    cognitiveDisabilityDesc: "    ",
        keyboardNav: "   ()",
        keyboardNavDesc: "   ",
        screenReader: "  (-)",
        screenReaderDesc: "   -",
                    contentScaling: " ",
        contentScalingDesc: "    ",
                    readableFont: " ",
                    readableFontDesc: "   ",
        highlightTitles: " ",
        highlightTitlesDesc: "   ",
        highlightLinks: " ",
        highlightLinksDesc: "   ",
                    textMagnifier: "   ",
                    textMagnifierDesc: "  ",
        fontSizing: "  ",
        fontSizingDesc: "    ",
        alignCenter: "  ",
                    alignCenterDesc: "   ",
        adjustLineHeight: "  ",
        adjustLineHeightDesc: "    ",
        adjustLetterSpacing: "  ",
        adjustLetterSpacingDesc: "    ",
        alignLeft: "   ",
                    alignLeftDesc: "     ",
        alignRight: "   ",
                    alignRightDesc: "     ",
                    darkContrast: " ",
                    darkContrastDesc: "    ",
                    lightContrast: " ",
                    lightContrastDesc: "    ",
                    highContrast: " ",
                    highContrastDesc: "  ",
                    highSaturation: " ",
        highSaturationDesc: "  ",
        adjustTextColors: "  ",
                    adjustTextColorsDesc: "  ",
        monochrome: "",
                    monochromeDesc: "    , , ",
        adjustTitleColors: "  ",
        adjustTitleColorsDesc: "   ",
                    lowSaturation: " ",
        lowSaturationDesc: "  ",
        adjustBgColors: "  ",
        adjustBgColorsDesc: "  ",
                    muteSound: " ",
                    muteSoundDesc: "   ",
                    hideImages: " ",
        hideImagesDesc: "    ",
                    readMode: " ",
                    readModeDesc: "  ",
                    readingGuide: "  ",
                    readingGuideDesc: "  ",
                    usefulLinks: " ",
                    usefulLinksDesc: "   ",
                    stopAnimation: " ",
                    stopAnimationDesc: "  CSS ",
                    reduceMotion: " ",
                    reduceMotionDesc: "   ",
                    readingMask: "  ",
                    readingMaskDesc: " ",
        highlightHover: "  ",
                    highlightHoverDesc: "    ",
        highlightFocus: " ",
        highlightFocusDesc: "  ",
                    bigBlackCursor: "  ",
                    bigBlackCursorDesc: "  ",
                    bigWhiteCursor: "  ",
                    bigWhiteCursorDesc: "  ",
                    resetSettings: " ",
                    statement: "",
                    hideInterface: " ",
                    accessibilityFeatures: " ",
    
        //   
        keyboardNavDetailed: "             (Tab, Shift+Tab, Enter)    (, \"M\"  , \"H\"  , \"F\"  , \"B\"  , \"G\"  ).",
                    keyboardNavNote: ":       .",
        screenReaderDetailed: "       -,   JAWS, NVDA, VoiceOver  TalkBack.   -       ,  -   .",
        screenReaderNote: ":      -.",
        activatesWithScreenReader: "  -",
        activatesWithKeyboardNav: "    ",
        
        // Hide Interface Modal
        hideInterfaceModalTitle: "  ?",
        hideInterfaceModalText: " :      ,      ,        .  ,    ?",
        hideInterfaceModalAccept: "",
        hideInterfaceModalCancel: "",
    
        // Toggle switch text
        toggleOn: "",
        toggleOff: ""
    },
                tw: {
        title: "",
        profilesTitle: "",
        seizureSafe: "",
        seizureSafeDesc: "",
        visionImpaired: "",
        visionImpairedDesc: "",
        adhdFriendly: "ADHD",
        adhdFriendlyDesc: "",
        cognitiveDisability: "",
        cognitiveDisabilityDesc: "",
        keyboardNav: "",
        keyboardNavDesc: "",
        screenReader: "",
        screenReaderDesc: "",
        contentScaling: "",
        contentScalingDesc: "",
        readableFont: "",
        readableFontDesc: "",
        highlightTitles: "",
        highlightTitlesDesc: "",
        highlightLinks: "",
        highlightLinksDesc: "",
        textMagnifier: "",
        textMagnifierDesc: "",
        fontSizing: "",
        fontSizingDesc: "",
        alignCenter: "",
        alignCenterDesc: "",
        adjustLineHeight: "",
        adjustLineHeightDesc: "",
        adjustLetterSpacing: "",
        adjustLetterSpacingDesc: "",
        alignLeft: "",
        alignLeftDesc: "",
        alignRight: "",
        alignRightDesc: "",
        darkContrast: "",
        darkContrastDesc: "",
        lightContrast: "",
        lightContrastDesc: "",
        highContrast: "",
        highContrastDesc: "",
        highSaturation: "",
        highSaturationDesc: "",
        adjustTextColors: "",
        adjustTextColorsDesc: "",
        monochrome: "",
        monochromeDesc: "",
        adjustTitleColors: "",
        adjustTitleColorsDesc: "",
        lowSaturation: "",
        lowSaturationDesc: "",
        adjustBgColors: "",
        adjustBgColorsDesc: "",
        muteSound: "",
        muteSoundDesc: "",
        hideImages: "",
        hideImagesDesc: "",
        readMode: "",
        readModeDesc: "",
        readingGuide: "",
        readingGuideDesc: "",
        usefulLinks: "",
        usefulLinksDesc: "",
        stopAnimation: "",
        stopAnimationDesc: "CSS",
        reduceMotion: "",
        reduceMotionDesc: "",
        readingMask: "",
        readingMaskDesc: "",
        highlightHover: "",
        highlightHoverDesc: "",
        highlightFocus: "",
        highlightFocusDesc: "",
        bigBlackCursor: "",
        bigBlackCursorDesc: "",
        bigWhiteCursor: "",
        bigWhiteCursorDesc: "",
        resetSettings: "",
        statement: "",
        hideInterface: "",
        accessibilityFeatures: "",
        
        // 
        keyboardNavDetailed: "TabShift+TabEnterMHFBG",
        keyboardNavNote: "",
        screenReaderDetailed: "JAWSNVDAVoiceOverTalkBack",
        screenReaderNote: "",
        activatesWithScreenReader: "",
        activatesWithKeyboardNav: "",
        
        // Hide Interface Modal
        hideInterfaceModalTitle: "",
        hideInterfaceModalText: "",
        hideInterfaceModalAccept: "",
        hideInterfaceModalCancel: "",
    
        // Toggle switch text
        toggleOn: "",
        toggleOff: ""
    },
                ar: {
    
                    title: "  ",
    
                    profilesTitle: "     ",
    
                    seizureSafe: "  ",
    
                    seizureSafeDesc: "   ",
    
                    visionImpaired: "  ",
    
                    visionImpairedDesc: "    ",
    
                    adhdFriendly: "    ",
    
                    adhdFriendlyDesc: "    ",
    
                    cognitiveDisability: "  ",
    
                    cognitiveDisabilityDesc: "   ",
    
                    keyboardNav: "   ()",
    
                    keyboardNavDesc: "   ",
    
                    screenReader: "  ( )",
    
                    screenReaderDesc: "   ",
    
                    contentScaling: " ",
    
                    contentScalingDesc: "    ",
    
                    readableFont: " ",
    
                    readableFontDesc: "  ",
    
                    highlightTitles: " ",
    
                    highlightTitlesDesc: "   ",
    
                    highlightLinks: " ",
    
                    highlightLinksDesc: "   ",
    
                    textMagnifier: " ",
    
                    textMagnifierDesc: "  ",
    
                    fontSizing: " ",
    
                    fontSizingDesc: "    ",
    
                    alignCenter: " ",
    
                    alignCenterDesc: "     ",
    
                    adjustLineHeight: "  ",
    
                    adjustLineHeightDesc: "    ",
    
                    adjustLetterSpacing: "   ",
    
                    adjustLetterSpacingDesc: "     ",
    
                    alignLeft: " ",
    
                    alignLeftDesc: "    ",
    
                    alignRight: " ",
    
                    alignRightDesc: "    ",
    
                    darkContrast: " ",
    
                    darkContrastDesc: "    ",
    
                    lightContrast: " ",
    
                    lightContrastDesc: "    ",
    
                    highContrast: " ",
    
                    highContrastDesc: "  ",
    
                    highSaturation: " ",
    
                    highSaturationDesc: "   ",
    
                    adjustTextColors: "  ",
    
                    adjustTextColorsDesc: "  ",
    
                    monochrome: " ",
    
                    monochromeDesc: "       ",
    
                    adjustTitleColors: "  ",
    
                    adjustTitleColorsDesc: "  ",
    
                    lowSaturation: " ",
    
                    lowSaturationDesc: "   ",
    
                    adjustBgColors: "  ",
    
                    adjustBgColorsDesc: "  ",
    
                    muteSound: " ",
    
                    muteSoundDesc: "   ",
    
                    hideImages: " ",
    
                    hideImagesDesc: "   ",
    
                    readMode: " ",
    
                    readModeDesc: "  ",
    
                    readingGuide: " ",
    
                    readingGuideDesc: "  ",
    
                    usefulLinks: " ",
    
                    usefulLinksDesc: "   ",
    
                    stopAnimation: "  ",
    
                    stopAnimationDesc: "   CSS ",
    
                    reduceMotion: " ",
    
                    reduceMotionDesc: "   ",
    
                    readingMask: " ",
    
                    readingMaskDesc: "  ",
    
                    highlightHover: " ",
    
                    highlightHoverDesc: "    ",
    
                    highlightFocus: " ",
    
                    highlightFocusDesc: "  ",
    
                    bigBlackCursor: "  ",
    
                    bigBlackCursorDesc: "   ",
    
                    bigWhiteCursor: "  ",
    
                    bigWhiteCursorDesc: "   ",
    
                    resetSettings: "  ",
    
                    statement: "",
    
                    hideInterface: " ",
    
                    accessibilityFeatures: "  ",
    
                    // Additional detailed descriptions
    
                    keyboardNavDetailed: "             (Tab, Shift+Tab, Enter)  ( \"M\"  \"H\"  \"F\"  \"B\"  \"G\" ).",
    
                    keyboardNavNote: ":        .",
    
                    screenReaderDetailed: "          JAWS  NVDA  VoiceOver  TalkBack.              .",
    
                    screenReaderNote: ":       .",
    
                    activatesWithScreenReader: "   ",
    
                    activatesWithKeyboardNav: "    ",
                    
                    // Hide Interface Modal
                    hideInterfaceModalTitle: "   ",
                    hideInterfaceModalText: " :                   .        ",
                    hideInterfaceModalAccept: "",
                    hideInterfaceModalCancel: "",
    
                    // Toggle switch text
                    toggleOn: "",
                    toggleOff: ""
    
                },
                ae: {
        title: "  ",
        profilesTitle: "     ",
        seizureSafe: "   ",
        seizureSafeDesc: "   ",
        // Vision impaired feature removed
        adhdFriendly: "    ",
        adhdFriendlyDesc: "    ",
        cognitiveDisability: "  ",
        cognitiveDisabilityDesc: "   ",
        keyboardNav: "   ()",
        keyboardNavDesc: "   ",
        screenReader: "  ( )",
        screenReaderDesc: "   ",
        contentScaling: " ",
        contentScalingDesc: "   ",
        readableFont: " ",
        readableFontDesc: "  ",
        highlightTitles: " ",
        highlightTitlesDesc: "   ",
        highlightLinks: " ",
        highlightLinksDesc: "   ",
        textMagnifier: " ",
        textMagnifierDesc: "  ",
        fontSizing: "  ",
        fontSizingDesc: "   ",
        alignCenter: " ",
        alignCenterDesc: "   ",
        adjustLineHeight: "  ",
        adjustLineHeightDesc: "   ",
        adjustLetterSpacing: "   ",
        adjustLetterSpacingDesc: "    ",
        alignLeft: " ",
        alignLeftDesc: "   ",
        alignRight: " ",
        alignRightDesc: "   ",
        darkContrast: " ",
        darkContrastDesc: "    ",
        lightContrast: " ",
        lightContrastDesc: "    ",
        highContrast: " ",
        highContrastDesc: "  ",
        highSaturation: " ",
        highSaturationDesc: "   ",
        adjustTextColors: "  ",
        adjustTextColorsDesc: "  ",
        monochrome: " ",
        monochromeDesc: "      ",
        adjustTitleColors: "  ",
        adjustTitleColorsDesc: "  ",
        lowSaturation: " ",
        lowSaturationDesc: "   ",
        adjustBgColors: "  ",
        adjustBgColorsDesc: "  ",
        muteSound: " ",
        muteSoundDesc: "   ",
        hideImages: " ",
        hideImagesDesc: "   ",
        readMode: " ",
        readModeDesc: "  ",
        readingGuide: " ",
        readingGuideDesc: "  ",
        usefulLinks: " ",
        usefulLinksDesc: "   ",
        stopAnimation: "  ",
        stopAnimationDesc: "   CSS ",
        reduceMotion: " ",
        reduceMotionDesc: "   ",
        readingMask: " ",
        readingMaskDesc: "  ",
        highlightHover: "  ",
        highlightHoverDesc: "    ",
        highlightFocus: " ",
        highlightFocusDesc: "  ",
        bigBlackCursor: "  ",
        bigBlackCursorDesc: "   ",
        bigWhiteCursor: "  ",
        bigWhiteCursorDesc: "   ",
        resetSettings: "  ",
        statement: "",
        hideInterface: " ",
        accessibilityFeatures: "  ",
        
        //   
        keyboardNavDetailed: "             (Tab Shift+Tab Enter)  ( \"M\"  \"H\"  \"F\"  \"B\"  \"G\" ).",
        keyboardNavNote: ":       .",
        screenReaderDetailed: "          JAWS NVDA VoiceOver TalkBack.              .",
        screenReaderNote: ":       .",
        activatesWithScreenReader: "   ",
        activatesWithKeyboardNav: "    ",
        
        // Hide Interface Modal
        hideInterfaceModalTitle: "   ",
        hideInterfaceModalText: " :                   .        ",
        hideInterfaceModalAccept: "",
        hideInterfaceModalCancel: "",
    
        // Toggle switch text
        toggleOn: "",
        toggleOff: ""
    },
                zh: { title: "", seizureSafe: "", seizureSafeDesc: "", visionImpaired: "", visionImpairedDesc: "", adhdFriendly: "", adhdFriendlyDesc: "", fontSizing: "", fontSizingDesc: "", adjustLineHeight: "", adjustLineHeightDesc: "", adjustLetterSpacing: "", adjustLetterSpacingDesc: "", contentScaling: "", contentScalingDesc: "", resetSettings: "", statement: "", hideInterface: "", accessibilityFeatures: "", toggleOn: "", toggleOff: "" },
    
                ja: { title: "", seizureSafe: "", seizureSafeDesc: "", visionImpaired: "", visionImpairedDesc: "", adhdFriendly: "ADHD", adhdFriendlyDesc: "", fontSizing: "", fontSizingDesc: "", adjustLineHeight: "", adjustLineHeightDesc: "", adjustLetterSpacing: "", adjustLetterSpacingDesc: "", contentScaling: "", contentScalingDesc: "", resetSettings: "", statement: "", hideInterface: "", accessibilityFeatures: "", toggleOn: "", toggleOff: "" },
    
                pl: { title: "Ustawienia dostpnoci", seizureSafe: "Profil bezpieczny dla napadw", seizureSafeDesc: "Usuwa byski i zmniejsza kolory", visionImpaired: "Profil dla osb niedowidzcych", visionImpairedDesc: "Poprawia elementy wizualne strony", adhdFriendly: "Profil przyjazny dla ADHD", adhdFriendlyDesc: "Zmniejsza rozpraszanie i pomaga si skupi", fontSizing: "Rozmiar czcionki", fontSizingDesc: "Zwiksz lub zmniejsz rozmiar czcionki", adjustLineHeight: "Dostosuj wysoko linii", adjustLineHeightDesc: "Zwiksz lub zmniejsz wysoko linii", adjustLetterSpacing: "Dostosuj odstpy midzy literami", adjustLetterSpacingDesc: "Zwiksz lub zmniejsz odstpy midzy literami", contentScaling: "Skalowanie treci", contentScalingDesc: "Zwiksz lub zmniejsz rozmiar treci", resetSettings: "Resetuj ustawienia", statement: "Owiadczenie", hideInterface: "Ukryj interfejs", accessibilityFeatures: "Funkcje dostpnoci" },
    
                tr: { title: "Eriilebilirlik Ayarlar", seizureSafe: "Nbet Gvenli Profil", seizureSafeDesc: "Flalar temizler ve renkleri azaltr", visionImpaired: "Grme Engelli Profil", visionImpairedDesc: "Web sitesinin grsel elerini gelitirir", adhdFriendly: "DEHB Dostu Profil", adhdFriendlyDesc: "Dikkat dankln azaltr ve odaklanmaya yardmc olur", fontSizing: "Yaz Tipi Boyutu", fontSizingDesc: "Yaz tipi boyutunu artr veya azalt", adjustLineHeight: "Satr Yksekliini Ayarla", adjustLineHeightDesc: "Satr yksekliini artr veya azalt", adjustLetterSpacing: "Harf Araln Ayarla", adjustLetterSpacingDesc: "Harf araln artr veya azalt", contentScaling: "erik leklendirme", contentScalingDesc: "erik boyutunu artr veya azalt", resetSettings: "Ayarlar Sfrla", statement: "Beyan", hideInterface: "Arayz Gizle", accessibilityFeatures: "Eriilebilirlik zellikleri" },
    
                // Add new language codes from screenshots
    
                ps: { title: "  ", profilesTitle: "     ", seizureSafe: "  ", seizureSafeDesc: "   ", visionImpaired: "  ", visionImpairedDesc: "   ", adhdFriendly: "    ", adhdFriendlyDesc: "    ", fontSizing: " ", fontSizingDesc: "    ", adjustLineHeight: "  ", adjustLineHeightDesc: "    ", adjustLetterSpacing: "   ", adjustLetterSpacingDesc: "     ", contentScaling: " ", contentScalingDesc: "    ", resetSettings: "  ", statement: "", hideInterface: " ", accessibilityFeatures: "  " },
    
                cz: { title: "Nastaven pstupnosti", profilesTitle: "Vyberte sprvn profil pstupnosti pro vs", seizureSafe: "Profil bezpen pro zchvaty", seizureSafeDesc: "Odstrauje blikn a sniuje barvy", visionImpaired: "Profil pro zrakov postien", visionImpairedDesc: "Zlepuje vizuln prvky webu", adhdFriendly: "Profil vhodn pro ADHD", adhdFriendlyDesc: "Sniuje rozptylovn a pomh se soustedit", fontSizing: "Velikost psma", fontSizingDesc: "Zvtit nebo zmenit velikost psma", adjustLineHeight: "Upravit vku dku", adjustLineHeightDesc: "Zvtit nebo zmenit vku dku", adjustLetterSpacing: "Upravit mezery mezi psmeny", adjustLetterSpacingDesc: "Zvtit nebo zmenit mezery mezi psmeny", contentScaling: "klovn obsahu", contentScalingDesc: "Zvtit nebo zmenit velikost obsahu", resetSettings: "Obnovit nastaven", statement: "Prohlen", hideInterface: "Skrt rozhran", accessibilityFeatures: "Funkce pstupnosti" },
    
                si: { title: "Nastavitve dostopnosti", profilesTitle: "Izberite pravilen profil dostopnosti za vas", seizureSafe: "Profil varen za napade", seizureSafeDesc: "Odstrani utripanje in zmanja barve", visionImpaired: "Profil za slabovidne", visionImpairedDesc: "Izbolja vizualne elemente spletne strani", adhdFriendly: "Profil prijazen za ADHD", adhdFriendlyDesc: "Zmanja motnje in pomaga pri osredotoanju", fontSizing: "Velikost pisave", fontSizingDesc: "Poveaj ali zmanjaj velikost pisave", adjustLineHeight: "Prilagodi viino vrstice", adjustLineHeightDesc: "Poveaj ali zmanjaj viino vrstice", adjustLetterSpacing: "Prilagodi razmik med rkami", adjustLetterSpacingDesc: "Poveaj ali zmanjaj razmik med rkami", contentScaling: "Poveevanje vsebine", contentScalingDesc: "Poveaj ali zmanjaj velikost vsebine", resetSettings: "Ponastavi nastavitve", statement: "Izjava", hideInterface: "Skrij vmesnik", accessibilityFeatures: "Funkcije dostopnosti" },
    
                no: { title: "Tilgjengelighetsjusteringer", profilesTitle: "Velg riktig tilgjengelighetsprofil for deg", seizureSafe: "Anfallssikker profil", seizureSafeDesc: "Fjerner blitser og reduserer farger", visionImpaired: "Profil for synshemmede", visionImpairedDesc: "Forbedrer nettstedets visuelle elementer", adhdFriendly: "ADHD-vennlig profil", adhdFriendlyDesc: "Reduserer distraksjoner og hjelper med fokus", fontSizing: "Skriftstrrelse", fontSizingDesc: "k eller reduser skriftstrrelse", adjustLineHeight: "Juster linjehyde", adjustLineHeightDesc: "k eller reduser linjehyde", adjustLetterSpacing: "Juster bokstavavstand", adjustLetterSpacingDesc: "k eller reduser bokstavavstand", contentScaling: "Innholdsskalering", contentScalingDesc: "k eller reduser innholdsstrrelse", resetSettings: "Tilbakestill innstillinger", statement: "Erklring", hideInterface: "Skjul grensesnitt", accessibilityFeatures: "Tilgjengelighetsfunksjoner" },
    
                fi: { title: "Saavutettavuusasetukset", profilesTitle: "Valitse oikea saavutettavuusprofiili sinulle", seizureSafe: "Kohtausvakaa profiili", seizureSafeDesc: "Poistaa vlhdyksi ja vhent vrej", visionImpaired: "Nkvammaisten profiili", visionImpairedDesc: "Parantaa verkkosivuston visuaalisia elementtej", adhdFriendly: "ADHD-ystvllinen profiili", adhdFriendlyDesc: "Vhent hiritekijit ja auttaa keskittymisess", fontSizing: "Fonttikoko", fontSizingDesc: "Kasvata tai pienenn fonttikokoa", adjustLineHeight: "Sd rivikorkeutta", adjustLineHeightDesc: "Kasvata tai pienenn rivikorkeutta", adjustLetterSpacing: "Sd kirjainvlist", adjustLetterSpacingDesc: "Kasvata tai pienenn kirjainvlist", contentScaling: "Sislln skaalaus", contentScalingDesc: "Kasvata tai pienenn sislln kokoa", resetSettings: "Nollaa asetukset", statement: "Lausunto", hideInterface: "Piilota kyttliittym", accessibilityFeatures: "Saavutettavuustoiminnot" },
    
                ro: { title: "Setri de accesibilitate", profilesTitle: "Alege profilul de accesibilitate potrivit pentru tine", seizureSafe: "Profil sigur pentru crize", seizureSafeDesc: "Elimin flash-urile i reduce culorile", visionImpaired: "Profil pentru persoane cu deficiene de vedere", visionImpairedDesc: "mbuntete elementele vizuale ale site-ului", adhdFriendly: "Profil prietenos cu ADHD", adhdFriendlyDesc: "Reduce distragerile i ajut la concentrare", fontSizing: "Dimensiunea fontului", fontSizingDesc: "Mrete sau micoreaz dimensiunea fontului", adjustLineHeight: "Ajusteaz nlimea liniei", adjustLineHeightDesc: "Mrete sau micoreaz nlimea liniei", adjustLetterSpacing: "Ajusteaz spaierea literelor", adjustLetterSpacingDesc: "Mrete sau micoreaz spaierea literelor", contentScaling: "Scalarea coninutului", contentScalingDesc: "Mrete sau micoreaz dimensiunea coninutului", resetSettings: "Reseteaz setrile", statement: "Declaraie", hideInterface: "Ascunde interfaa", accessibilityFeatures: "Funcii de accesibilitate" },
    
                gr: { title: " ", profilesTitle: "      ", seizureSafe: "   ", seizureSafeDesc: "      ", visionImpaired: "     ", visionImpairedDesc: "     ", adhdFriendly: "   ADHD", adhdFriendlyDesc: "      ", fontSizing: " ", fontSizingDesc: "    ", adjustLineHeight: "  ", adjustLineHeightDesc: "    ", adjustLetterSpacing: "  ", adjustLetterSpacingDesc: "    ", contentScaling: " ", contentScalingDesc: "    ", resetSettings: " ", statement: "", hideInterface: " ", accessibilityFeatures: " " },
    
                // Add remaining language codes from screenshots
    
                ba: { title: "Postavke pristupanosti", profilesTitle: "Odaberite odgovarajui profil pristupanosti za vas", seizureSafe: "Siguran profil za napade", seizureSafeDesc: "Uklanja bljeskanje i smanjuje boje", visionImpaired: "Profil za osobe s oteenjem vida", visionImpairedDesc: "Poboljava vizualne elemente web stranice", adhdFriendly: "Profil prijateljski za ADHD", adhdFriendlyDesc: "Smanjuje ometanja i pomae u fokusiranju", fontSizing: "Veliina fonta", fontSizingDesc: "Poveaj ili smanji veliinu fonta", adjustLineHeight: "Prilagodi visinu linije", adjustLineHeightDesc: "Poveaj ili smanji visinu linije", adjustLetterSpacing: "Prilagodi razmak izmeu slova", adjustLetterSpacingDesc: "Poveaj ili smanji razmak izmeu slova", contentScaling: "Skaliranje sadraja", contentScalingDesc: "Poveaj ili smanji veliinu sadraja", resetSettings: "Resetuj postavke", statement: "Izjava", hideInterface: "Sakrij interfejs", accessibilityFeatures: "Funkcije pristupanosti" },
    
                lu: { title: "Zougangsastellungen", profilesTitle: "Wielt de richtegen Zougangsprofil fir Iech", seizureSafe: "Scheren Profil fir Kriise", seizureSafeDesc: "Ewechhlt Blitzen a reduziert Faarwen", visionImpaired: "Profil fir Leit mat Gesiichtsschwch", visionImpairedDesc: "Verbessert d'visuell Elementer vun der Websit", adhdFriendly: "ADHD-frndlechen Profil", adhdFriendlyDesc: "Reduziert Ofleedungen an hlleft beim Fokussieren", fontSizing: "Schrftgrisst", fontSizingDesc: "Erhicht oder reduziert Schrftgrisst", adjustLineHeight: "Linnenhicht upassen", adjustLineHeightDesc: "Erhicht oder reduziert Linnenhicht", adjustLetterSpacing: "Buschtawenofstand upassen", adjustLetterSpacingDesc: "Erhicht oder reduziert Buschtawenofstand", contentScaling: "Inhalts-Skalierung", contentScalingDesc: "Erhicht oder reduziert Inhaltsgrisst", resetSettings: "Astellungen zrcksetzen", statement: "Deklaratioun", hideInterface: "Interface verstoppen", accessibilityFeatures: "Zougangsfunktiounen" },
    
                dk: { title: "Tilgngelighedsindstillinger", profilesTitle: "Vlg den rigtige tilgngelighedsprofil til dig", seizureSafe: "Anfaldssikker profil", seizureSafeDesc: "Fjerner blink og reducerer farver", visionImpaired: "Profil for synshandicappede", visionImpairedDesc: "Forbedrer webstedets visuelle elementer", adhdFriendly: "ADHD-venlig profil", adhdFriendlyDesc: "Reducerer distraktioner og hjlper med fokus", fontSizing: "Skriftstrrelse", fontSizingDesc: "g eller reducer skriftstrrelse", adjustLineHeight: "Juster linjehjde", adjustLineHeightDesc: "g eller reducer linjehjde", adjustLetterSpacing: "Juster bogstavafstand", adjustLetterSpacingDesc: "g eller reducer bogstavafstand", contentScaling: "Indholdsskalering", contentScalingDesc: "g eller reducer indholdsstrrelse", resetSettings: "Nulstil indstillinger", statement: "Erklring", hideInterface: "Skjul interface", accessibilityFeatures: "Tilgngelighedsfunktioner" },
    
                sk: { title: "Nastavenia dostupnosti", profilesTitle: "Vyberte sprvny profil dostupnosti pre vs", seizureSafe: "Bezpen profil pre zchvaty", seizureSafeDesc: "Odstrauje blikanie a zniuje farby", visionImpaired: "Profil pre zrakovo postihnutch", visionImpairedDesc: "Zlepuje vizulne prvky webu", adhdFriendly: "Profil vhodn pre ADHD", adhdFriendlyDesc: "Zniuje rozptyovanie a pomha sa sstredi", fontSizing: "Vekos psma", fontSizingDesc: "Zvi alebo zmeni vekos psma", adjustLineHeight: "Upravi vku riadku", adjustLineHeightDesc: "Zvi alebo zmeni vku riadku", adjustLetterSpacing: "Upravi medzery medzi psmenami", adjustLetterSpacingDesc: "Zvi alebo zmeni medzery medzi psmenami", contentScaling: "klovanie obsahu", contentScalingDesc: "Zvi alebo zmeni vekos obsahu", resetSettings: "Obnovi nastavenia", statement: "Vyhlsenie", hideInterface: "Skry rozhranie", accessibilityFeatures: "Funkcie dostupnosti" },
    
                se: { title: "Tillgnglighetsinstllningar", profilesTitle: "Vlj rtt tillgnglighetsprofil fr dig", seizureSafe: "Anfallssker profil", seizureSafeDesc: "Tar bort blinkningar och minskar frger", visionImpaired: "Profil fr synskadade", visionImpairedDesc: "Frbttrar webbplatsens visuella element", adhdFriendly: "ADHD-vnlig profil", adhdFriendlyDesc: "Minskar distraktioner och hjlper med fokus", fontSizing: "Typsnittsstorlek", fontSizingDesc: "ka eller minska typsnittsstorlek", adjustLineHeight: "Justera radhjd", adjustLineHeightDesc: "ka eller minska radhjd", adjustLetterSpacing: "Justera bokstavavstnd", adjustLetterSpacingDesc: "ka eller minska bokstavavstnd", contentScaling: "Innehllsskalning", contentScalingDesc: "ka eller minska innehllsstorlek", resetSettings: "terstll instllningar", statement: "Frklaring", hideInterface: "Dlj grnssnitt", accessibilityFeatures: "Tillgnglighetsfunktioner" },
    
                ua: { title: " ", profilesTitle: "     ", seizureSafe: "   ", seizureSafeDesc: "    ", visionImpaired: "     ", visionImpairedDesc: "   -", adhdFriendly: ",   ADHD", adhdFriendlyDesc: "    ", fontSizing: " ", fontSizingDesc: "    ", adjustLineHeight: "  ", adjustLineHeightDesc: "    ", adjustLetterSpacing: "  ", adjustLetterSpacingDesc: "    ", contentScaling: " ", contentScalingDesc: "    ", resetSettings: " ", statement: "", hideInterface: " ", accessibilityFeatures: " " },
    
                ie: { title: "Socruithe Inrochtaineachta", profilesTitle: "Roghnaigh an prifl inrochtaineachta ceart duit", seizureSafe: "Prifl sbhailte do thuitim", seizureSafeDesc: "Baineann s lasracha agus laghdaonn dathanna", visionImpaired: "Prifl do dhaoine le lag radhairc", visionImpairedDesc: "Feabhsaonn eilimint amhairc an lithrein ghrasin", adhdFriendly: "Prifl cairdiil ADHD", adhdFriendlyDesc: "Laghdaonn mearbhall agus cuidonn le fcas", fontSizing: "Mid cl", fontSizingDesc: "Madaigh n laghdaigh mid cl", adjustLineHeight: "Coigeartaigh airde lne", adjustLineHeightDesc: "Madaigh n laghdaigh airde lne", adjustLetterSpacing: "Coigeartaigh spsil litreacha", adjustLetterSpacingDesc: "Madaigh n laghdaigh spsil litreacha", contentScaling: "Scl bhair", contentScalingDesc: "Madaigh n laghdaigh mid bhair", resetSettings: "Athshocraigh socruithe", statement: "Riteas", hideInterface: "Folaigh comhadan", accessibilityFeatures: "Gnithe inrochtaineachta" },
    
                rs: { title: " ", profilesTitle: "     ", seizureSafe: "   ", seizureSafeDesc: "    ", visionImpaired: "     ", visionImpairedDesc: "    ", adhdFriendly: "   ADHD", adhdFriendlyDesc: "     ", fontSizing: " ", fontSizingDesc: "    ", adjustLineHeight: "  ", adjustLineHeightDesc: "    ", adjustLetterSpacing: "   ", adjustLetterSpacingDesc: "     ", contentScaling: " ", contentScalingDesc: "    ", resetSettings: " ", statement: "", hideInterface: " ", accessibilityFeatures: " " },
    
                al: { title: "Cilsimet e aksesueshmris", profilesTitle: "Zgjidhni profilin e duhur t aksesueshmris pr ju", seizureSafe: "Profil i sigurt pr sulmet", seizureSafeDesc: "Heq rrezatimet dhe zvoglon ngjyrat", visionImpaired: "Profil pr personat me probleme shikimi", visionImpairedDesc: "Prmirson elementet vizuale t faqes s internetit", adhdFriendly: "Profil miqsor pr ADHD", adhdFriendlyDesc: "Zvoglon shprqendrimet dhe ndihmon n fokusim", fontSizing: "Madhsia e shkronjave", fontSizingDesc: "Rrit ose zvoglo madhsin e shkronjave", adjustLineHeight: "Rregullo lartsin e rreshtit", adjustLineHeightDesc: "Rrit ose zvoglo lartsin e rreshtit", adjustLetterSpacing: "Rregullo hapsirn midis shkronjave", adjustLetterSpacingDesc: "Rrit ose zvoglo hapsirn midis shkronjave", contentScaling: "Shkalla e prmbajtjes", contentScalingDesc: "Rrit ose zvoglo madhsin e prmbajtjes", resetSettings: "Rivendos cilsimet", statement: "Deklarata", hideInterface: "Fshih ndrfaqen", accessibilityFeatures: "Funksionet e aksesueshmris" }
    
            };
    
        }
    
    
    
        togglePanel() {
    
            
    
            const panel = this.shadowRoot.getElementById('accessbit-widget-panel');
    
            
    
            if (panel) {
    
                
    
                
    
                
    
                
    
                if (panel.classList.contains('active')) {
    
                    panel.classList.remove('active');
    
                    
                    
                    // Re-enable smooth scrolling libraries when panel is closed
                    this.enableSmoothScrollingLibraries();
    
                } else {
    
                    panel.classList.add('active');
    
                    
                    
                    // Fix scrolling conflicts with GSAP/Lenis libraries
                    setTimeout(() => {
                        this.fixPanelScrolling();
                    }, 100);
    
                }
    
                
    
                
    
                
    
                
    
                // Force a repaint
    
                panel.offsetHeight;
    
            } else {
    
                
    
            }
    
        }
    
    
    
        showStatement() {
            // Check if we have a custom accessibility statement link
            if (this.customizationData && this.customizationData.accessibilityStatementLink) {
                // Validate the link before opening
                const link = this.customizationData.accessibilityStatementLink.trim();
                if (link !== '') {
                    window.open(link, '_blank');
                    return;
                }
            }
            
            // Default statement if no link is provided
            const message = 'Accessibility Statement: This website is committed to providing an accessible experience for all users. We follow WCAG 2.1 guidelines and continuously work to improve accessibility.';
            alert(message);
        }
    
        
    
        
    
        
    
        
    
        updatePanelContent() {
    
            // Panel content is now static in English
    
            // No language translation needed
    
        }
    
    
    
        // Language functionality
    
        setupLanguageDropdownListeners() {
    
            
    
            // Language options
    
            const languageOptions = this.shadowRoot.querySelectorAll('.language-option');
    
     
    
            
    
            languageOptions.forEach((option, index) => {
    
    
                option.addEventListener('click', (e) => {
    
                 
    
                    e.preventDefault();
    
                    e.stopPropagation();
    
                    const selectedLang = e.currentTarget.dataset.lang;
    
                    const selectedFlag = e.currentTarget.dataset.flag;
    
                    this.selectLanguage(selectedLang, selectedFlag);
    
                });
    
                // Ensure option is keyboard selectable
                option.setAttribute('role', 'option');
                option.setAttribute('tabindex', '0');
                option.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        option.click();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.hideLanguageDropdown();
                    }
                });
    
            });
    
    
    
            // Close dropdown when clicking outside
    
            document.addEventListener('click', (e) => {
    
                // Don't close if we're currently opening the dropdown
    
                if (this.isOpeningDropdown) {
    
                    return;
    
                }
    
                
    
                const dropdown = this.shadowRoot.getElementById('language-dropdown');
    
                const header = this.shadowRoot.getElementById('language-selector-header');
    
                if (dropdown && header && !header.contains(e.target) && !dropdown.contains(e.target)) {
    
                
    
                    this.hideLanguageDropdown();
    
                }
    
            });
    
    
        }
    
    
    
        toggleLanguageDropdown() {
    
        
    
            const dropdown = this.shadowRoot.getElementById('language-dropdown');
    
    
            if (dropdown) {
    
                const currentDisplay = dropdown.style.display;
    
                const computedDisplay = window.getComputedStyle(dropdown).display;
    
         
    
                
    
                if (dropdown.style.display === 'none' || dropdown.style.display === '' || window.getComputedStyle(dropdown).display === 'none') {
    
                    this.isOpeningDropdown = true;
    
                    this.showLanguageDropdown();
    
                    // Reset flag after a short delay
    
                    setTimeout(() => {
    
                        this.isOpeningDropdown = false;
    
                    }, 200);
    
                } else {
    
              
    
                    this.hideLanguageDropdown();
    
                }
    
            } else {
    
              
    
            }
    
        }
    
    
    
        showLanguageDropdown() {
    
       
    
            const dropdown = this.shadowRoot.getElementById('language-dropdown');
    
            
    
            if (dropdown) {
    
                dropdown.style.display = 'block';
    
                dropdown.style.visibility = 'visible';
    
                dropdown.style.opacity = '1';
    
                dropdown.style.zIndex = '100001';
    
                
    
               
    
                
    
                // Mark current language as selected and focus first option
                setTimeout(() => {
                    this.updateSelectedLanguage();
                    const header = this.shadowRoot.getElementById('language-selector-header');
                    if (header) header.setAttribute('aria-expanded', 'true');
                    const options = dropdown.querySelectorAll('.language-option');
                    // Make all options tabbable so Tab moves through each language
                    options.forEach((opt) => {
                        opt.setAttribute('tabindex', '0');
                    });
                    const first = options[0];
                    if (first) first.focus();
                }, 50);
    
                // Add keyboard navigation and focus trap inside dropdown
                const handleKeyNav = (e) => {
                    const options = Array.from(dropdown.querySelectorAll('.language-option'));
                    const activeIndex = options.findIndex(el => el === this.shadowRoot.activeElement);
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        // Cycle within dropdown options
                        const direction = e.shiftKey ? -1 : 1;
                        const nextIndex = (activeIndex === -1 ? (e.shiftKey ? options.length - 1 : 0) : (activeIndex + direction + options.length) % options.length);
                        options.forEach(o => o.setAttribute('tabindex', '-1'));
                        const target = options[nextIndex];
                        if (target) { target.setAttribute('tabindex', '0'); target.focus(); }
                        return;
                    }
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        const next = options[(activeIndex + 1 + options.length) % options.length];
                        options.forEach(o => o.setAttribute('tabindex', '-1'));
                        if (next) { next.setAttribute('tabindex', '0'); next.focus(); }
                        return;
                    }
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prev = options[(activeIndex - 1 + options.length) % options.length];
                        options.forEach(o => o.setAttribute('tabindex', '-1'));
                        if (prev) { prev.setAttribute('tabindex', '0'); prev.focus(); }
                        return;
                    }
                    if (e.key === 'Home') {
                        e.preventDefault();
                        options.forEach(o => o.setAttribute('tabindex', '-1'));
                        if (options[0]) { options[0].setAttribute('tabindex', '0'); options[0].focus(); }
                        return;
                    }
                    if (e.key === 'End') {
                        e.preventDefault();
                        const last = options[options.length - 1];
                        options.forEach(o => o.setAttribute('tabindex', '-1'));
                        if (last) { last.setAttribute('tabindex', '0'); last.focus(); }
                        return;
                    }
                    if (e.key === 'Enter' || e.key === ' ') {
                        const focused = this.shadowRoot.activeElement;
                        if (focused && focused.classList.contains('language-option')) {
                            e.preventDefault();
                            focused.click();
                            return;
                        }
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.hideLanguageDropdown();
                    }
                };
                // Replace existing handler if present to avoid duplicates
                if (dropdown._langKeyNavRef) {
                    dropdown.removeEventListener('keydown', dropdown._langKeyNavRef);
                }
                dropdown._langKeyNavRef = handleKeyNav;
                dropdown.addEventListener('keydown', handleKeyNav);
    
                // Announce to screen reader
    
                this.announceToScreenReader('Language selection dropdown opened');
    
            } else {
    
            
    
            }
    
        }
    
    
    
        hideLanguageDropdown() {
    
            const dropdown = this.shadowRoot.getElementById('language-dropdown');
    
            if (dropdown) {
    
                dropdown.style.display = 'none';
                dropdown.style.visibility = 'hidden';
                dropdown.style.opacity = '0';
    
                // Announce to screen reader
    
                this.announceToScreenReader('Language selection dropdown closed');
    
                const header = this.shadowRoot.getElementById('language-selector-header');
                if (header) {
                    header.setAttribute('aria-expanded', 'false');
                    header.focus();
                }
    
                // Remove focus trap handler
                if (dropdown._langKeyNavRef) {
                    dropdown.removeEventListener('keydown', dropdown._langKeyNavRef);
                    dropdown._langKeyNavRef = null;
                }
    
            }
    
        }
    
    
    
        updateSelectedLanguage() {
        
    
            const currentLang = this.getCurrentLanguage();
         
    
            const languageOptions = this.shadowRoot.querySelectorAll('.language-option');
       
            // Normalize language value to a two-letter code used in data-lang
            const normalizeLang = (lang) => {
                if (!lang) return 'en';
                const lower = String(lang).toLowerCase();
                // Map common name variants to codes
                const map = {
                    'english': 'en', 'en': 'en',
                    'german': 'de', 'deutsch': 'de', 'de': 'de',
                    'french': 'fr', 'franais': 'fr', 'fr': 'fr',
                    'spanish': 'es', 'espaol': 'es', 'es': 'es',
                    'portugus': 'pt', 'portuguese': 'pt', 'pt': 'pt',
                    'italian': 'it', 'italiano': 'it', 'it': 'it',
                    'hebrew': 'he', 'il': 'he', 'he': 'he',
                    'russian': 'ru', '': 'ru', 'ru': 'ru',
                    'chinese (traditional)': 'tw', '': 'tw', 'tw': 'tw',
                    'arabic': 'ae', 'ar': 'ae', 'ae': 'ae'
                };
                return map[lower] || (lower.length === 2 ? lower : 'en');
            };
    
            const normalizedCurrent = normalizeLang(currentLang);
    
            languageOptions.forEach(option => {
                // clear previous state
                option.classList.remove('selected');
                option.setAttribute('aria-selected', 'false');
                option.setAttribute('data-selected', 'false');
                // clear any inline fallback styles
                option.style.background = '';
                option.style.color = '';
    
                // apply selected state
                if (normalizeLang(option.dataset.lang) === normalizedCurrent) {
                   
                    option.classList.add('selected');
                    option.setAttribute('aria-selected', 'true');
                    option.setAttribute('data-selected', 'true');
                    // Fallback inline styles to guarantee visibility over external CSS
                    option.style.background = '#6366f1';
                    option.style.color = '#ffffff';
                  
                } else {
                    
                }
            });
    
            // Also reflect the selected state on the header for consistency
            const header = this.shadowRoot.getElementById('language-selector-header');
            if (header) {
                header.setAttribute('data-current-lang', normalizedCurrent);
            }
        }
    
    
    
        selectLanguage(langCode, flag) {
           
    
            // Update current language display in header
    
            const currentLangSpan = this.shadowRoot.getElementById('current-language-header');
    
            if (currentLangSpan) {
    
                const languageNames = {
    
                    'en': 'ENGLISH', 'es': 'ESPAOL', 'de': 'DEUTSCH', 'pt': 'PORTUGUS', 'fr': 'FRANAIS',
    
                    'it': 'ITALIANO', 'he': '', 'tw': '', 'ru': '', 'ar': '',
    
                    'ae': '', 'nl': 'NEDERLANDS', 'zh-cn': '', 'ja': '', 'pl': 'POLSKI', 'tr': 'TRKE',
    
                    'cz': 'ETINA', 'si': 'SLOVENINA', 'no': 'NORSK BOKML', 'fi': 'SUOMI', 'ro': 'ROMN',
    
                    'gr': '', 'ba': 'BOSANSKI', 'lu': 'LTZEBUERGESCH', 'dk': 'DANSK', 'hu': 'MAGYAR',
    
                    'sk': 'SLOVENINA', 'se': 'SVENSKA', 'ua': '', 'ie': 'GAEILGE', 'rs': '',
    
                    'hr': 'HRVATSKI', 'al': 'SHQIP', 'ps': ''
    
                };
    
                currentLangSpan.textContent = languageNames[langCode] || 'ENGLISH';
    
            }
    
    
    
            // Store selected language
    
            this.currentLanguage = langCode;
    
            localStorage.setItem('accessbit-widget-language', langCode);
    
    
    
            // Update panel content with new language - add delay to ensure DOM is ready
    
            setTimeout(() => {
    
            this.updatePanelLanguage(langCode);
    
            }, 100);
    
    
    
       
            this.updateSelectedLanguage();
         
    
    
    
            // Hide dropdown
    
            this.hideLanguageDropdown();
    
    
    
            // Announce language change
    
            this.announceToScreenReader(`Language changed to ${currentLangSpan.textContent}`);
    
    
    
        }
    
    
    
        updatePanelLanguage(langCode) {
    
         
    
            const translations = this.translations[langCode] || this.translations['en'];
    
            
    
            // If the language doesn't have complete translations, use English as fallback
    
            const hasCompleteTranslations = this.hasCompleteTranslations(langCode);
    
            if (!hasCompleteTranslations) {
    
              
    
            }
    
            
    
            // Update main panel title (h2)
    
            const panelTitle = this.shadowRoot.querySelector('h2');
    
            if (panelTitle) {
    
                panelTitle.textContent = translations.title;
    
            
    
            }
    
            
    
            // Update white content section title (h3)
    
            const profilesTitle = this.shadowRoot.querySelector('.white-content-section h3');
    
            if (profilesTitle) {
    
                profilesTitle.textContent = translations.profilesTitle || "Choose the right accessibility profile for you";
    
            }
    
            
    
            // Update all profile items - use a more robust approach
    
            const featureIds = [
    
                'seizure-safe', 'vision-impaired', 'adhd-friendly', 'cognitive-disability',
    
                'keyboard-nav', 'screen-reader', 'content-scaling', 'readable-font',
    
                'highlight-titles', 'highlight-links', 'text-magnifier', 'font-sizing',
    
                'align-center', 'adjust-line-height', 'adjust-letter-spacing', 'align-left',
    
                'align-right', 'dark-contrast', 'light-contrast', 'high-contrast',
    
                'high-saturation', 'adjust-text-colors', 'monochrome', 'adjust-title-colors',
    
                'low-saturation', 'adjust-bg-colors', 'mute-sound', 'hide-images',
    
                'read-mode', 'reading-guide', 'useful-links',
    
                'reading-mask', 'highlight-hover', 'highlight-focus', 'big-black-cursor',
    
                'big-white-cursor'
    
            ];
    
            
            
    
            featureIds.forEach(featureId => {
    
                const checkbox = this.shadowRoot.getElementById(featureId);
    
                if (!checkbox) {
    
    
                    return;
    
                }
    
                
    
                const profileItem = checkbox.closest('.profile-item');
    
                if (!profileItem) {
    
                  
    
                    return;
    
                }
    
                
    
                const title = profileItem.querySelector('h4');
    
                const desc = profileItem.querySelector('p:not(.profile-description p)');

    
                
    
                // Force update the elements even if they're not visible
    
                if (title || desc) {
    
    
                }
    
                
    
                switch (featureId) {
    
                    case 'seizure-safe':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'seizureSafe', 'Seizure Safe Profile');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'seizureSafeDesc', 'Clear flashes & reduces color');
    
                        break;
    
                    case 'vision-impaired':
    
                     
                        break;
    
                    case 'adhd-friendly':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'adhdFriendly', 'ADHD Friendly Profile');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'adhdFriendlyDesc', 'More focus & fewer distractions');
    
                        break;
    
                    case 'cognitive-disability':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'cognitiveDisability', 'Cognitive Disability Profile');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'cognitiveDisabilityDesc', 'Assists with reading & focusing');
    
                        break;
    
                    case 'keyboard-nav':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'keyboardNav', 'Keyboard Navigation (Motor)');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'keyboardNavDesc', 'Use website with the keyboard');
    
                        break;
    
                    case 'screen-reader':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'screenReader', 'Blind Users (Screen Reader)');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'screenReaderDesc', 'Optimize website for screen-readers');
    
                        break;
    
                    case 'content-scaling':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'contentScaling', 'Content Scaling');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'contentScalingDesc', 'Scale content with arrow controls');
    
                        break;
    
                    case 'readable-font':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'readableFont', 'Readable Font');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'readableFontDesc', 'High-legibility fonts');
    
                        break;
    
                    case 'highlight-titles':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'highlightTitles', 'Highlight Titles');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'highlightTitlesDesc', 'Add boxes around heading tags (h1-h6)');
    
                        break;
    
                    case 'highlight-links':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'highlightLinks', 'Highlight Links');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'highlightLinksDesc', 'Add boxes around links');
    
                        break;
    
                    case 'text-magnifier':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'textMagnifier', 'Text Magnifier');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'textMagnifierDesc', 'Floating magnifying glass tool');
    
                        break;
    
                    case 'font-sizing':
    
                        if (title) title.textContent = this.getTranslation(langCode, 'fontSizing', 'Adjust Font Sizing');
    
                        if (desc) desc.textContent = this.getTranslation(langCode, 'fontSizingDesc', 'Font size with arrow controls');
    
                        break;
    
                    case 'align-center':
    
                        if (title) title.textContent = translations.alignCenter || 'Align Center';
    
                        if (desc) desc.textContent = translations.alignCenterDesc || 'Center-aligns all text content';
    
                        break;
    
                    case 'adjust-line-height':
    
                        if (title) title.textContent = translations.adjustLineHeight || 'Adjust Line Height';
    
                        if (desc) desc.textContent = translations.adjustLineHeightDesc || 'Line height with arrow controls';
    
                        break;
    
                    case 'adjust-letter-spacing':
    
                        if (title) title.textContent = translations.adjustLetterSpacing || 'Adjust Letter Spacing';
    
                        if (desc) desc.textContent = translations.adjustLetterSpacingDesc || 'Letter spacing with arrow controls';
    
                        break;
    
                    case 'align-left':
    
                        if (title) title.textContent = translations.alignLeft || 'Align Left';
    
                        if (desc) desc.textContent = translations.alignLeftDesc || 'Left-aligns text content';
    
                        break;
    
                    case 'align-right':
    
                        if (title) title.textContent = translations.alignRight || 'Align Right';
    
                        if (desc) desc.textContent = translations.alignRightDesc || 'Right-aligns text content';
    
                        break;
    
                    case 'dark-contrast':
    
                        if (title) title.textContent = translations.darkContrast || 'Dark Contrast';
    
                        if (desc) desc.textContent = translations.darkContrastDesc || 'Dark background with light text';
    
                        break;
    
                    case 'light-contrast':
    
                        if (title) title.textContent = translations.lightContrast || 'Light Contrast';
    
                        if (desc) desc.textContent = translations.lightContrastDesc || 'Light background with dark text';
    
                        break;
    
                    case 'high-contrast':
    
                        if (title) title.textContent = translations.highContrast || 'High Contrast';
    
                        if (desc) desc.textContent = translations.highContrastDesc || 'Maximum contrast implementation';
    
                        break;
    
                    case 'high-saturation':
    
                        if (title) title.textContent = translations.highSaturation || 'High Saturation';
    
                        if (desc) desc.textContent = translations.highSaturationDesc || 'Increases color intensity';
    
                        break;
    
                    case 'adjust-text-colors':
    
                        if (title) title.textContent = translations.adjustTextColors || 'Adjust Text Colors';
    
                        if (desc) desc.textContent = translations.adjustTextColorsDesc || 'Color picker functionality';
    
                        break;
    
                    case 'monochrome':
    
                        if (title) title.textContent = translations.monochrome || 'Monochrome';
    
                        if (desc) desc.textContent = translations.monochromeDesc || 'Removes all colors except black, white, grays';
    
                        break;
    
                    case 'adjust-title-colors':
    
                        if (title) title.textContent = translations.adjustTitleColors || 'Adjust Title Colors';
    
                        if (desc) desc.textContent = translations.adjustTitleColorsDesc || 'Color customization for headings';
    
                        break;
    
                    case 'low-saturation':
    
                        if (title) title.textContent = translations.lowSaturation || 'Low Saturation';
    
                        if (desc) desc.textContent = translations.lowSaturationDesc || 'Reduces color intensity';
    
                        break;
    
                    case 'adjust-bg-colors':
    
                        if (title) title.textContent = translations.adjustBgColors || 'Adjust Background Colors';
    
                        if (desc) desc.textContent = translations.adjustBgColorsDesc || 'Background color customization';
    
                        break;
    
                    case 'mute-sound':
    
                        if (title) title.textContent = translations.muteSound || 'Mute Sound';
    
                        if (desc) desc.textContent = translations.muteSoundDesc || 'Disables all audio content';
    
                        break;
    
                    case 'hide-images':
    
                        if (title) title.textContent = translations.hideImages || 'Hide Images';
    
                        if (desc) desc.textContent = translations.hideImagesDesc || 'Toggle to hide all images';
    
                        break;
    
                    case 'read-mode':
    
                        if (title) title.textContent = translations.readMode || 'Read Mode';
    
                        if (desc) desc.textContent = translations.readModeDesc || 'Removes navigation elements';
    
                        break;
    
                    case 'reading-guide':
    
                        if (title) title.textContent = translations.readingGuide || 'Reading Guide';
    
                        if (desc) desc.textContent = translations.readingGuideDesc || 'Movable highlight bar';
    
                        break;
    
    
                    case 'useful-links':
    
                        if (title) title.textContent = translations.usefulLinks || 'Useful Links';
    
                        if (desc) desc.textContent = translations.usefulLinksDesc || 'Accessibility resources and links';
    
                        break;
    
                    case 'reduce-motion':
    
                        if (title) title.textContent = translations.reduceMotion || 'Reduce Motion';
    
                        if (desc) desc.textContent = translations.reduceMotionDesc || 'Disable animations and transitions';
    
                        break;
    
    
                    case 'reading-mask':
    
                        if (title) title.textContent = translations.readingMask || 'Reading Mask';
    
                        if (desc) desc.textContent = translations.readingMaskDesc || 'Semi-transparent overlay';
    
                        break;
    
                    case 'highlight-hover':
    
                        if (title) title.textContent = translations.highlightHover || 'Highlight Hover';
    
                        if (desc) desc.textContent = translations.highlightHoverDesc || 'Visual feedback on hover';
    
                        break;
    
                    case 'highlight-focus':
    
                        if (title) title.textContent = translations.highlightFocus || 'Highlight Focus';
    
                        if (desc) desc.textContent = translations.highlightFocusDesc || 'Prominent focus indicators';
    
                        break;
    
                    case 'big-black-cursor':
    
                        if (title) title.textContent = translations.bigBlackCursor || 'Big Black Cursor';
    
                        if (desc) desc.textContent = translations.bigBlackCursorDesc || 'Increases cursor size';
    
                        break;
    
                    case 'big-white-cursor':
    
                        if (title) title.textContent = translations.bigWhiteCursor || 'Big White Cursor';
    
                        if (desc) desc.textContent = translations.bigWhiteCursorDesc || 'Increases cursor size';
    
                        break;
    
                }
    
            });
    
            
    
            // Update button texts
    
            const resetBtn = this.shadowRoot.querySelector('#reset-settings');
    
            const statementBtn = this.shadowRoot.querySelector('#statement');
    
            const hideBtn = this.shadowRoot.querySelector('#hide-interface');
    
            
    
            if (resetBtn) {
                // Security: Use textContent for safe text insertion, create icon separately
                resetBtn.textContent = '';
                const resetIcon = document.createElement('i');
                resetIcon.className = 'fas fa-redo';
                resetIcon.setAttribute('aria-hidden', 'true');
                resetBtn.appendChild(resetIcon);
                const resetText = document.createTextNode(' ' + (translations.resetSettings || 'Reset Settings'));
                resetBtn.appendChild(resetText);
            }
    
            if (statementBtn) {
                // Security: Use textContent for safe text insertion, create icon separately
                statementBtn.textContent = '';
                const statementIcon = document.createElement('i');
                statementIcon.className = 'fas fa-file-alt';
                statementIcon.setAttribute('aria-hidden', 'true');
                statementBtn.appendChild(statementIcon);
                const statementText = document.createTextNode(' ' + (translations.statement || 'Statement'));
                statementBtn.appendChild(statementText);
            }
    
            if (hideBtn) {
                // Security: Use textContent for safe text insertion, create icon separately
                hideBtn.textContent = '';
                const hideIcon = document.createElement('i');
                hideIcon.className = 'fas fa-eye-slash';
                hideIcon.setAttribute('aria-hidden', 'true');
                hideBtn.appendChild(hideIcon);
                const hideText = document.createTextNode(' ' + (translations.hideInterface || 'Hide Interface'));
                hideBtn.appendChild(hideText);
            }
    
            
    
            // Also update all elements using a more comprehensive approach
    
            this.updateAllPanelElements(langCode);
    
    
        }
    
        
    
        updateAllPanelElements(langCode) {
    
    
            
    
            // Update all h4 elements (feature titles)
    
            const allTitles = this.shadowRoot.querySelectorAll('.profile-item h4');
    
            allTitles.forEach((title, index) => {
    
                const featureId = this.getFeatureIdFromElement(title);
    
                if (featureId) {
    
                    const translation = this.getTranslation(langCode, featureId, title.textContent);
    
                    if (translation) {
    
                        title.textContent = translation;
    
                    
    
                    }
    
                }
    
            });
    
            
    
            // Update all p elements (feature descriptions)
    
            const allDescriptions = this.shadowRoot.querySelectorAll('.profile-item p:not(.profile-description p)');
    
            allDescriptions.forEach((desc, index) => {
    
                const featureId = this.getFeatureIdFromElement(desc);
    
                if (featureId) {
    
                    const translation = this.getTranslation(langCode, featureId + 'Desc', desc.textContent);
    
                    if (translation) {
    
                        desc.textContent = translation;
    
                     
    
                    }
    
                }
    
            });
    
            
    
            // Also update any small elements with detailed descriptions
    
            const allSmallElements = this.shadowRoot.querySelectorAll('.profile-item small');
    
            allSmallElements.forEach((small, index) => {
    
                const featureId = this.getFeatureIdFromElement(small);
    
                if (featureId) {
    
                    // Check for detailed description keys
    
                    const detailedKey = featureId + 'Detailed';
    
                    const noteKey = featureId + 'Note';
    
                    const detailedTranslation = this.getTranslation(langCode, detailedKey, '');
    
                    const noteTranslation = this.getTranslation(langCode, noteKey, '');
    
                    
    
                    if (detailedTranslation) {
    
                        small.textContent = detailedTranslation;
    
          
    
                    } else if (noteTranslation) {
    
                        small.textContent = noteTranslation;
    
                    
    
                    }
    
                }
    
            });
    
            
    
        }
    
        
    
        getFeatureIdFromElement(element) {
    
            // Find the closest profile item and get its checkbox ID
    
            const profileItem = element.closest('.profile-item');
    
            if (profileItem) {
    
                const checkbox = profileItem.querySelector('input[type="checkbox"]');
    
                if (checkbox) {
    
                    // Convert hyphenated ID to camelCase for translation keys
    
                    const id = checkbox.id;
    
                    return id.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
    
                }
    
            }
    
            return null;
    
        }
    
        
    
        hasCompleteTranslations(langCode) {
    
            const translations = this.translations[langCode];
    
            if (!translations) return false;
    
            
    
            // Check if all essential features have translations
    
            const essentialFeatures = [
    
                'title', 'profilesTitle', 'seizureSafe', 'seizureSafeDesc',
    
                'visionImpaired', 'visionImpairedDesc', 'adhdFriendly', 'adhdFriendlyDesc',
    
                'cognitiveDisability', 'cognitiveDisabilityDesc', 'keyboardNav', 'keyboardNavDesc',
    
                'screenReader', 'screenReaderDesc', 'contentScaling', 'contentScalingDesc',
    
                'readableFont', 'readableFontDesc', 'highlightTitles', 'highlightTitlesDesc',
    
                'highlightLinks', 'highlightLinksDesc', 'textMagnifier', 'textMagnifierDesc',
    
                'fontSizing', 'fontSizingDesc', 'alignCenter', 'alignCenterDesc',
    
                'adjustLineHeight', 'adjustLineHeightDesc', 'adjustLetterSpacing', 'adjustLetterSpacingDesc',
    
                'alignLeft', 'alignLeftDesc', 'alignRight', 'alignRightDesc',
    
                'darkContrast', 'darkContrastDesc', 'lightContrast', 'lightContrastDesc',
    
                'highContrast', 'highContrastDesc', 'highSaturation', 'highSaturationDesc',
    
                'adjustTextColors', 'adjustTextColorsDesc', 'monochrome', 'monochromeDesc',
    
                'adjustTitleColors', 'adjustTitleColorsDesc', 'lowSaturation', 'lowSaturationDesc',
    
                'adjustBgColors', 'adjustBgColorsDesc', 'muteSound', 'muteSoundDesc',
    
                'hideImages', 'hideImagesDesc', 'readMode', 'readModeDesc',
    
                'readingGuide', 'readingGuideDesc', 'usefulLinks', 'usefulLinksDesc',
    
                'stopAnimation', 'stopAnimationDesc', 'readingMask', 'readingMaskDesc',
    
                'highlightHover', 'highlightHoverDesc', 'highlightFocus', 'highlightFocusDesc',
    
                'bigBlackCursor', 'bigBlackCursorDesc', 'bigWhiteCursor', 'bigWhiteCursorDesc',
    
                'resetSettings', 'statement', 'hideInterface', 'accessibilityFeatures',
    
                // Additional detailed descriptions
    
                'keyboardNavDetailed', 'keyboardNavNote', 'screenReaderDetailed', 'screenReaderNote',
    
                'activatesWithScreenReader', 'activatesWithKeyboardNav'
    
            ];
    
            
    
            // Check if at least 80% of essential features have translations
    
            const translatedFeatures = essentialFeatures.filter(feature => translations[feature]);
    
            return translatedFeatures.length >= (essentialFeatures.length * 0.8);
    
        }
    
        
    
        getTranslation(langCode, key, fallback = '') {
    
            // Get translation from current language, fallback to English, then to provided fallback
    
            const translations = this.translations[langCode] || this.translations['en'];
    
            return translations[key] || this.translations['en'][key] || fallback;
    
        }
    
    
    
        getCurrentLanguage() {
            const stored = localStorage.getItem('accessbit-widget-language');
            const current = this.currentLanguage || stored || 'en';
          
            return current;
        }
    
    
    
        initializeLanguageDisplay() {
    
            // Add a small delay to ensure DOM elements are ready
    
            setTimeout(() => {
    
                const currentLangSpan = this.shadowRoot.getElementById('current-language-header');
    
                if (currentLangSpan) {
    
                    const languageNames = {
    
                        'en': 'ENGLISH', 'es': 'ESPAOL', 'de': 'DEUTSCH', 'pt': 'PORTUGUS', 'fr': 'FRANAIS',
    
                        'it': 'ITALIANO', 'he': '', 'tw': '', 'ru': '', 'ar': '',
    
                        'ar-ae': '', 'nl': 'NEDERLANDS', 'zh-cn': '', 'ja': '', 'pl': 'POLSKI', 'tr': 'TRKE',
    
                        'cz': 'ETINA', 'si': 'SLOVENINA', 'no': 'NORSK BOKML', 'fi': 'SUOMI', 'ro': 'ROMN',
    
                        'gr': '', 'ba': 'BOSANSKI', 'lu': 'LTZEBUERGESCH', 'dk': 'DANSK', 'hu': 'MAGYAR',
    
                        'sk': 'SLOVENINA', 'se': 'SVENSKA', 'ua': '', 'ie': 'GAEILGE', 'rs': '',
    
                        'hr': 'HRVATSKI', 'al': 'SHQIP', 'ps': ''
    
                    };
    
                    
    
                    const currentLang = this.getCurrentLanguage();
    
                    currentLangSpan.textContent = languageNames[currentLang] || 'ENGLISH';
    
                    
    
                }
    
            }, 100);
    
        }
    
    
    
        hideInterface() {
    
            
            // Show the confirmation modal instead of hiding immediately
            this.showHideInterfaceModal();
        }
    
    
        handleToggle(feature, enabled) {
    
           
    
            
    
            this.settings[feature] = enabled;
    
            this.saveSettings();
    
            
    
            // Special handling for keyboard navigation and screen reader
    
            if (feature === 'keyboard-nav' || feature === 'screen-reader') {
    
                this.handleAccessibilityProfiles(feature, enabled);
    
            } else {
    
                this.applyFeature(feature, enabled);
    
                
    
                // Announce to screen reader for other features
    
                const featureNames = {
    
                    'seizure-safe': 'Seizure safe mode',
    
                    'reduce-motion': 'Reduce motion mode',
    
                    'vision-impaired': 'Vision impaired mode',
    
                    'adhd-friendly': 'ADHD friendly mode',
    
                    'cognitive-disability': 'Cognitive disability mode',
    
                    'high-contrast': 'High contrast mode',
    
                    'monochrome': 'Monochrome mode',
    
                    'dark-contrast': 'Dark contrast mode',
    
                    'light-contrast': 'Light contrast mode',
    
                    'high-saturation': 'High saturation mode',
    
                    'low-saturation': 'Low saturation mode'
    
                };
    
                
    
                const featureName = featureNames[feature] || feature;
    
                const status = enabled ? 'enabled' : 'disabled';
    
                this.announceToScreenReader(`${featureName} ${status}`);
    
            }
    
            
    
            // Update widget appearance to sync with global features
    
            this.updateWidgetAppearance();
    
        }
    
    
    
        handleAccessibilityProfiles(feature, enabled) {
    
            // Get the toggle elements from Shadow DOM
    
            const keyboardToggle = this.shadowRoot.getElementById('keyboard-nav');
    
            const screenReaderToggle = this.shadowRoot.getElementById('screen-reader');
    
            
    
            if (enabled) {
    
                // When either profile is enabled, enable both
    
                this.settings['keyboard-nav'] = true;
    
                this.settings['screen-reader'] = true;
    
                
    
                // Update both toggles to checked state
    
                if (keyboardToggle) keyboardToggle.checked = true;
    
                if (screenReaderToggle) screenReaderToggle.checked = true;
    
                
    
                // Apply both features
    
                this.applyFeature('keyboard-nav', true);
    
                this.applyFeature('screen-reader', true);
    
                
    
                // Initialize keyboard navigation shortcuts
    
                this.initKeyboardShortcuts();
    
                
    
                // Play activation sound
    
                this.playAccessibilitySound('activate');
    
                
    
                // Save updated settings
    
                this.saveSettings();
    
                
    
            } else {
    
                // When either profile is disabled, disable both
    
                this.settings['keyboard-nav'] = false;
    
                this.settings['screen-reader'] = false;
    
                
    
                // Update both toggles to unchecked state
    
                if (keyboardToggle) keyboardToggle.checked = false;
    
                if (screenReaderToggle) screenReaderToggle.checked = false;
    
                
    
                // Remove both features
    
                this.applyFeature('keyboard-nav', false);
    
                this.applyFeature('screen-reader', false);
    
                
    
                // Remove keyboard shortcuts
    
                this.removeKeyboardShortcuts();
    
                
    
                // Play deactivation sound
    
                this.playAccessibilitySound('deactivate');
    
                
    
                // Save updated settings
    
                this.saveSettings();
    
    
            }
    
        }
    
    
    
    
    
        removeKeyboardShortcuts() {
    
            if (this.keyboardShortcutHandler) {
    
                document.removeEventListener('keydown', this.keyboardShortcutHandler);
    
                this.keyboardShortcutHandler = null;
    
                
            }
    
            if (this.mouseHandler) {
    
                document.removeEventListener('mousedown', this.mouseHandler);
    
                document.removeEventListener('click', this.mouseHandler);
    
                this.mouseHandler = null;
    
                
    
            }
    
            
    
            // Remove all highlighted elements
    
            this.removeAllHighlights();
    
            
    
            // Reset element tracking
    
            this.currentElementIndex = {};
    
        }
    
    
    
        cycleThroughElements(selector, type) {
    
            // Remove previous highlights
    
            this.removeAllHighlights();
    
            
    
            // Get all matching elements
    
            const elements = Array.from(document.querySelectorAll(selector)).filter(element => 
    
                this.isElementVisible(element) && this.isElementFocusable(element)
    
            );
    
            
    
            if (elements.length === 0) {
    
                
    
                return;
    
            }
    
            
    
            // Initialize or increment index for this type
    
            if (!this.currentElementIndex[type]) {
    
                this.currentElementIndex[type] = 0;
    
            } else {
    
                this.currentElementIndex[type] = (this.currentElementIndex[type] + 1) % elements.length;
    
            }
    
            
    
            // Get current element
    
            const currentElement = elements[this.currentElementIndex[type]];
    
            
    
            // Highlight the current element
    
            this.highlightElement(currentElement, type);
    
            
    
            // Focus and scroll to element
    
            currentElement.focus();
    
            currentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
            
    
    
        }
    
    
    
        highlightElement(element, type) {
    
            // Create highlight box
    
            const highlight = document.createElement('div');
    
            highlight.className = 'keyboard-highlight';
    
            highlight.setAttribute('data-type', type);
    
            highlight.style.cssText = `
    
                position: absolute;
    
                border: 3px solid #6366f1;
    
                border-radius: 6px;
    
                background: transparent;
    
                pointer-events: none;
    
                z-index: 2147483645;
    
                box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);
    
                transition: all 0.3s ease;
    
            `;
    
            
    
            // Position the highlight
    
            const rect = element.getBoundingClientRect();
    
            highlight.style.top = (rect.top + window.scrollY - 3) + 'px';
    
            highlight.style.left = (rect.left + window.scrollX - 3) + 'px';
    
            highlight.style.width = (rect.width + 6) + 'px';
    
            highlight.style.height = (rect.height + 6) + 'px';
    
            
    
            // Add to document
    
            document.body.appendChild(highlight);
    
            this.highlightedElements.push(highlight);
    
            
    
            // Add label
    
            const label = document.createElement('div');
    
            label.className = 'keyboard-highlight-label';
    
            label.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} ${this.currentElementIndex[type] + 1}`;
    
            label.style.cssText = `
    
                position: absolute;
    
                top: -30px;
    
                left: 0;
    
                background: #6366f1;
    
                color: white;
    
                padding: 4px 8px;
    
                border-radius: 4px;
    
                font-size: 12px;
    
                font-weight: bold;
    
                white-space: nowrap;
    
                z-index: 1000001;
    
            `;
    
            
    
            highlight.appendChild(label);
    
            
    
            // Auto-remove after 3 seconds
    
            setTimeout(() => {
    
                if (highlight.parentNode) {
    
                    highlight.remove();
    
                    this.highlightedElements = this.highlightedElements.filter(h => h !== highlight);
    
                }
    
            }, 3000);
    
        }
    
    
    
    
    
        focusElement(selector) {
    
            const elements = document.querySelectorAll(selector);
    
            if (elements.length > 0) {
    
                // Find the first visible and focusable element
    
                for (let element of elements) {
    
                    if (this.isElementVisible(element) && this.isElementFocusable(element)) {
    
                        element.focus();
    
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
                        
    
                        // Add temporary highlight
    
                        element.style.outline = '3px solid var(--primary-color)';
    
                        element.style.outlineOffset = '2px';
    
                        
    
                        setTimeout(() => {
    
                            element.style.outline = '';
    
                            element.style.outlineOffset = '';
    
                        }, 2000);
    
                        
    
                        
    
                        return;
    
                    }
    
                }
    
            }
    
          
    
        }
    
    
    
        isElementVisible(element) {
    
            const style = window.getComputedStyle(element);
    
            return style.display !== 'none' && 
    
                   style.visibility !== 'hidden' && 
    
                   element.offsetWidth > 0 && 
    
                   element.offsetHeight > 0;
    
        }
    
    
    
        isElementFocusable(element) {
    
            const tag = element.tagName.toLowerCase();
    
            const type = element.type;
    
            
    
            // Check if element is naturally focusable
    
            if (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'textarea' || tag === 'select') {
    
                return true;
    
            }
    
            
    
            // Check if element has tabindex
    
            if (element.hasAttribute('tabindex') && element.getAttribute('tabindex') !== '-1') {
    
                return true;
    
            }
    
            
    
            // Check if element has role that makes it focusable
    
            const role = element.getAttribute('role');
    
            if (role === 'button' || role === 'link' || role === 'menuitem' || role === 'tab') {
    
                return true;
    
            }
    
            
    
            return false;
    
        }
    
    
    
        playAccessibilitySound(type = 'activate') {
    
            try {
    
                // Create audio context for sound generation
    
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
                const oscillator = audioContext.createOscillator();
    
                const gainNode = audioContext.createGain();
    
                
    
                // Connect nodes
    
                oscillator.connect(gainNode);
    
                gainNode.connect(audioContext.destination);
    
                
    
                // Configure sound based on type
    
                oscillator.type = 'sine';
    
                
    
                if (type === 'activate') {
    
                    // Pleasant ascending sound for activation
    
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime); // 600Hz
    
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.1); // Rise to 800Hz
    
                    oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.2); // Rise to 1000Hz
    
                } else {
    
                    // Pleasant descending sound for deactivation
    
                    oscillator.frequency.setValueAtTime(1000, audioContext.currentTime); // 1000Hz
    
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.1); // Fall to 800Hz
    
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.2); // Fall to 600Hz
    
                }
    
                
    
                // Configure volume envelope
    
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
    
                gainNode.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + 0.05);
    
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
    
                
    
                // Play the sound
    
                oscillator.start(audioContext.currentTime);
    
                oscillator.stop(audioContext.currentTime + 0.4);
    
                
    
    
            } catch (error) {
    
               
    
            }
    
        }
    
    
    
        applyFeature(feature, enabled) {
    
           
    
            
    
            const body = document.body;
    
            
    
            if (enabled) {
    
                body.classList.add(feature);
    
                
    
                // Special handling for specific features
    
                switch(feature) {
    
                    case 'keyboard-nav':
                        // Ensure setting is stored so keyboard shortcuts work
                        this.settings['keyboard-nav'] = true;
                        this.initKeyboardShortcuts();
                        break;
    
                    case 'text-magnifier':
    
                        this.initTextMagnifier(); // Initialize first
    
                        this.enableTextMagnifier();
    
                        break;
    
                    case 'font-sizing':
    
                        // Check if font sizing was actually used before applying
                        const wasFontSizingUsed = localStorage.getItem('font-sizing-used') === 'true';
                        if (!wasFontSizingUsed && this.fontSize === 100) {
                            
                            // Don't apply the feature, just return
                            return;
                        }
                        this.toggleFontSizingControls(true);
                        break;
    
                    case 'content-scaling':
    
                        // Check if content scaling was actually used before applying
                        const wasContentScalingUsed = localStorage.getItem('content-scaling-used') === 'true';
                        if (!wasContentScalingUsed && this.contentScale === 100) {
                           
                            // Don't apply the feature, just return
                            return;
                        }
                        this.toggleContentScalingControls(true);
                        // Apply the saved content scale
                        if (this.contentScale !== 100) {
                            this.updateContentScale();
                        }
                        break;
    
                    case 'adjust-line-height':
    
                        // Check if line height was actually used before applying
                        const wasLineHeightUsed = localStorage.getItem('line-height-used') === 'true';
                        if (!wasLineHeightUsed && this.lineHeight === 100) {
                          
                            // Don't apply the feature, just return
                            return;
                        }
                        this.toggleLineHeightControls(true);
                        break;
    
                    case 'adjust-letter-spacing':
    
                        // Check if letter spacing was actually used before applying
                        const wasLetterSpacingUsed = localStorage.getItem('letter-spacing-used') === 'true';
                        if (!wasLetterSpacingUsed && this.letterSpacing === 100) {
                         
                            // Don't apply the feature, just return
                            return;
                        }
                        this.toggleLetterSpacingControls(true);
                        break;
    
                    case 'highlight-titles':
    
                        this.highlightTitles();
    
                        break;
    
                    case 'highlight-links':
    
                        this.highlightLinks();
    
                        break;
    
                    case 'adjust-text-colors':
    
                        this.showTextColorPicker();
    
                        break;
    
                    case 'adjust-title-colors':
    
                        this.showTitleColorPicker();
    
                        break;
    
                    case 'adjust-bg-colors':
    
                        this.showBackgroundColorPicker();
    
                        break;
    
                    case 'mute-sound':
    
                        this.enableMuteSound();
    
                        break;
    
                    case 'hide-images':
    
                        this.enableHideImages();
    
                        break;
    
                    case 'read-mode':
    
                        this.enableReadMode();
    
                        break;
    
                    case 'reading-guide':
    
                        this.enableReadingGuide();
    
                        break;
    
    
                    case 'reading-mask':
    
                        this.enableReadingMask();
    
                        break;
    
                    case 'useful-links':
    
                        this.enableUsefulLinks();
    
                        break;
    
                    case 'highlight-hover':
    
                        this.enableHighlightHover();
    
                        break;
    
                    case 'highlight-focus':
    
                        this.enableHighlightFocus();
    
                        break;
    
                    case 'adhd-friendly':
    
                        this.enableADHDFriendly();
    
                        break;
    
                    case 'screen-reader':
    
                        this.enhanceScreenReaderSupport();
    
                        break;
    
                    case 'high-contrast':
    
                        this.enableHighContrast();
    
                        break;
    
                    case 'high-saturation':
    
                        this.enableHighSaturation();
    
                        break;
    
                    case 'low-saturation':

                        this.enableLowSaturation();

                        break;

                    case 'monochrome':
    
                        this.enableMonochrome();
    
                        break;
    
                    case 'dark-contrast':
    
                        this.enableDarkContrast();
    
                        break;
    
                    case 'light-contrast':
    
                        this.enableLightContrast();
    
                        break;
    
                    case 'seizure-safe':
    
                        this.enableSeizureSafe();
    
                        break;
    
                    case 'reduce-motion':
    
                        this.enableReduceMotion();
    
                        break;
    
                    case 'stop-animation':
    
                        this.enableStopAnimation();
    
                        break;
    
                    case 'vision-impaired':
    
                        this.enableVisionImpaired();
    
                        break;
    
                    case 'cognitive-disability':
    
                        this.enableCognitiveDisability();
    
                        break;
    
                    case 'readable-font':
    
                        this.enableReadableFont();
    
                        break;
    
                    case 'align-center':
    
                        this.enableAlignCenter();
    
                        break;
    
                    case 'align-left':
    
                        this.enableAlignLeft();
    
                        break;
    
                    case 'align-right':
    
                        this.enableAlignRight();
    
                        break;
    
                    case 'big-black-cursor':
    
                        this.enableBigBlackCursor();
    
                        break;
    
                    case 'big-white-cursor':
    
                        this.enableBigWhiteCursor();
    
                        break;
    
    
                }
    
            } else {
    
                body.classList.remove(feature);
    
                
    
                // Special handling for specific features
    
                switch(feature) {
    
                    case 'keyboard-nav':
                        // Remove setting when disabled
                        this.settings['keyboard-nav'] = false;
                        this.removeKeyboardShortcuts();
                        break;
    
                    case 'text-magnifier':
    
                        this.disableTextMagnifier();
    
                        break;
    
                    case 'font-sizing':
    
                        this.disableFontSizing();
    
                        this.hideFontSizingControls();
    
                        break;
    
                    case 'content-scaling':
    
                        this.hideContentScalingControls();
    
                        this.resetContentScale();
    
                        break;
    
                    case 'adjust-line-height':
    
                        this.hideLineHeightControls();
    
                        this.resetLineHeight();
    
                        break;
    
                    case 'adjust-letter-spacing':
    
                        this.hideLetterSpacingControls();
    
                        this.resetLetterSpacing();
    
                        break;
    
                    case 'highlight-titles':
    
                        this.removeTitleHighlights();
    
                        break;
    
                    case 'highlight-links':
    
                        this.removeLinkHighlights();
    
                        break;
    
                    case 'adhd-friendly':
    
                        this.disableADHDFriendly();
    
                        break;
    
                    case 'screen-reader':
    
                        this.removeScreenReaderEnhancements();
    
                        break;
    
                    case 'high-contrast':
    
                        this.disableHighContrast();
    
                        break;
    
                    case 'high-saturation':
    
                        this.disableHighSaturation();
    
                        break;
    
                    case 'low-saturation':

                        this.disableLowSaturation();

                        break;

                    case 'monochrome':
    
                        this.disableMonochrome();
    
                        break;
    
                    case 'dark-contrast':
    
                        this.disableDarkContrast();
    
                        break;
    
                    case 'light-contrast':
    
                        this.disableLightContrast();
    
                        break;
    
                    case 'seizure-safe':
    
                        this.disableSeizureSafe();
    
                        break;
    
                    case 'reduce-motion':
    
                        this.disableReduceMotion();
    
                        break;
    
                    case 'stop-animation':
    
                        this.disableStopAnimation();
    
                        break;
    
                    case 'vision-impaired':
    
                        this.disableVisionImpaired();
    
                        break;
    
                    case 'cognitive-disability':
    
                        this.disableCognitiveDisability();
    
                        break;
    
                    case 'readable-font':
    
                        this.disableReadableFont();
    
                        break;
    
                    case 'align-center':
    
                        this.disableAlignCenter();
    
                        break;
    
                    case 'align-left':
    
                        this.disableAlignLeft();
    
                        break;
    
                    case 'align-right':
    
                        this.disableAlignRight();
    
                        break;
    
                    case 'big-black-cursor':
    
                        this.disableBigBlackCursor();
    
                        break;
    
                    case 'big-white-cursor':
    
                        this.disableBigWhiteCursor();
    
                        break;
    
    
                    case 'adjust-text-colors':
    
                        this.hideTextColorPicker();
    
                        this.resetTextColors();
    
                        break;
    
                    case 'adjust-title-colors':
    
                        this.hideTitleColorPicker();
    
                        this.resetTitleColors();
    
                        break;
    
                    case 'adjust-bg-colors':
    
                        this.hideBackgroundColorPicker();
    
                        this.resetBackgroundColors();
    
                        break;
    
                    case 'mute-sound':
    
                        this.disableMuteSound();
    
                        break;
    
                    case 'hide-images':
    
                        this.disableHideImages();
    
                        break;
    
                    case 'read-mode':
    
                        this.disableReadMode();
    
                        break;
    
                    case 'reading-guide':
    
                        this.disableReadingGuide();
    
                        break;
    
    
                    case 'reading-mask':
    
                        this.disableReadingMask();
    
                        break;
    
                    case 'useful-links':
    
                        this.disableUsefulLinks();
    
                        break;
    
                    case 'highlight-hover':
    
                        this.disableHighlightHover();
    
                        break;
    
                    case 'highlight-focus':
    
                        this.disableHighlightFocus();
    
                        break;
    
                }
    
            }
    
        }
    
    
    
        enhanceScreenReaderSupport() {
            // CRITICAL: Don't manipulate Designer DOM
            if (this.isDesignerMode()) {
                return;
            }
    
            // Add skip link if it doesn't exist
    
            if (!document.getElementById('skip-link')) {
    
                const skipLink = document.createElement('a');
    
                skipLink.id = 'skip-link';
    
                skipLink.href = '#main-content';
    
                skipLink.textContent = 'Skip to main content';
    
                skipLink.style.cssText = `
    
                    position: absolute;
    
                    top: -40px;
    
                    left: 6px;
    
                    background: var(--primary-color);
    
                    color: white;
    
                    padding: 8px;
    
                    text-decoration: none;
    
                    border-radius: 4px;
    
                    z-index: 2147483645;
    
                    transition: top 0.3s;
    
                `;
    
                skipLink.addEventListener('focus', () => {
    
                    skipLink.style.top = '6px';
    
                });
    
                skipLink.addEventListener('blur', () => {
    
                    skipLink.style.top = '-40px';
    
                });
    
                document.body.insertBefore(skipLink, document.body.firstChild);
    
            }
    
    
    
            // Add ARIA landmarks if they don't exist
    
            this.addAriaLandmarks();
    
            
    
            // Enhance form labels and inputs
    
            this.enhanceFormAccessibility();
    
            
    
            // Add alt text to images without alt
    
            this.addAltTextToImages();
    
            
    
    
        }
    
    
    
        removeScreenReaderEnhancements() {
    
            // Remove skip link
    
            const skipLink = document.getElementById('skip-link');
    
            if (skipLink) {
    
                skipLink.remove();
    
            }
    
            
    
            // Remove added ARIA attributes
    
            this.removeAriaEnhancements();
    
            
 
    
        }
    
    
    
        addAriaLandmarks() {
    
            // Add main landmark if it doesn't exist
    
            const mainContent = document.querySelector('main, [role="main"], #main, .main');
    
            if (mainContent && !mainContent.id) {
    
                mainContent.id = 'main-content';
    
            }
    
            
    
            // Add navigation landmarks
    
            const navs = document.querySelectorAll('nav');
    
            navs.forEach((nav, index) => {
    
                if (!nav.getAttribute('aria-label')) {
    
                    nav.setAttribute('aria-label', `Navigation ${index + 1}`);
    
                }
    
            });
    
            
    
            // Add banner landmark
    
            const header = document.querySelector('header');
    
            if (header && !header.getAttribute('role')) {
    
                header.setAttribute('role', 'banner');
    
            }
    
            
    
            // Add contentinfo landmark
    
            const footer = document.querySelector('footer');
    
            if (footer && !footer.getAttribute('role')) {
    
                footer.setAttribute('role', 'contentinfo');
    
            }
    
        }
    
    
    
        removeAriaEnhancements() {
    
            // Remove added ARIA attributes (be careful not to remove existing ones)
    
            const skipLink = document.getElementById('skip-link');
    
            if (skipLink) {
    
                skipLink.remove();
    
            }
    
        }
    
    
    
        enhanceFormAccessibility() {
    
            // Add labels to inputs without labels
    
            const inputs = document.querySelectorAll('input, textarea, select');
    
            inputs.forEach((input, index) => {
    
                if (!input.id && !input.getAttribute('aria-label')) {
    
                    const label = input.previousElementSibling;
    
                    if (label && label.tagName === 'LABEL') {
    
                        input.id = `input-${index}`;
    
                        label.setAttribute('for', input.id);
    
                    } else {
    
                        input.setAttribute('aria-label', `Input field ${index + 1}`);
    
                    }
    
                }
    
            });
    
        }
    
    
    
        addAltTextToImages() {
    
            const images = document.querySelectorAll('img');
    
            images.forEach((img, index) => {
    
                if (!img.alt && !img.getAttribute('aria-label')) {
    
                    img.setAttribute('alt', `Image ${index + 1}`);
    
                }
    
            });
    
        }
    
    
    
    
    
    
    
        initTextMagnifier() {
    
            // Remove existing magnifier if any
    
            const existingMagnifier = document.getElementById('text-magnifier');
    
            if (existingMagnifier) {
    
                existingMagnifier.remove();
    
            }
    
            
    
            const magnifier = document.createElement('div');
    
            magnifier.className = 'magnifier';
    
            magnifier.id = 'text-magnifier';
    
            magnifier.style.cssText = `
    
                position: fixed;
    
                display: none;
    
                z-index: 2147483645;
    
                pointer-events: none;
    
                font-family: Arial, sans-serif;
    
            `;
    
            document.body.appendChild(magnifier);
    
    
        }
    
    
    
        enableTextMagnifier() {
    
            // Initialize magnifier if not exists
    
            this.initTextMagnifier();
    
            
    
            const magnifier = document.getElementById('text-magnifier');
    
            if (!magnifier) {
    
               
    
                return;
    
            }
    
            
    
            // Add hover effects to ALL text elements and interactive elements - comprehensive coverage
    
            const textElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span, div, a, button, label, li, td, th, img, article, section, aside, main, blockquote, pre, code, em, strong, i, b, u, small, sub, sup, mark, del, ins, cite, abbr, acronym, address, time, data, output, progress, meter, details, summary, figcaption, caption, dt, dd, dl, ol, ul, input, textarea, select, option, optgroup, fieldset, legend, form, table, thead, tbody, tfoot, tr, video, audio, canvas, svg, nav, header, footer, main, section, article, aside, figure, figcaption, blockquote, q, cite, abbr, acronym, address, time, data, output, progress, meter, details, summary, .logo, .nav-logo, .nav-menu li, .navbar, .menu, .nav-item, .nav-link, .btn, .button, .link, .text, .content, .title, .subtitle, .caption, .description, .heading, .subheading, .paragraph, .list-item, .table-cell, .form-label, .form-input, .form-button, .card, .card-title, .card-content, .card-text, .hero, .hero-title, .hero-subtitle, .banner, .banner-text, .sidebar, .sidebar-content, .footer, .footer-content, .header, .header-content, .navigation, .navigation-item, .breadcrumb, .breadcrumb-item, .pagination, .pagination-item, .tab, .tab-content, .accordion, .accordion-content, .modal, .modal-content, .tooltip, .tooltip-content, .dropdown, .dropdown-item, .menu, .menu-item, .submenu, .submenu-item, .widget, .widget-content, .panel, .panel-content, .tile, .tile-content, .grid, .grid-item, .flex, .flex-item, .container, .container-content, .wrapper, .wrapper-content, .box, .box-content, .item, .item-content, .element, .element-content, [role="button"], [role="link"], [role="menuitem"], [role="tab"], [role="option"], [role="checkbox"], [role="radio"], [role="textbox"], [role="combobox"], [role="listbox"], [role="tree"], [role="treeitem"], [role="grid"], [role="gridcell"], [role="columnheader"], [role="rowheader"], [role="row"], [role="cell"], [role="table"], [role="rowgroup"], [role="columnheader"], [role="rowheader"], [role="banner"], [role="navigation"], [role="main"], [role="complementary"], [role="contentinfo"], [role="search"], [role="form"], [role="region"], [role="alert"], [role="alertdialog"], [role="dialog"], [role="log"], [role="marquee"], [role="status"], [role="timer"], [role="tooltip"], [role="tabpanel"], [role="tablist"], [role="menubar"], [role="menu"], [role="menuitem"], [role="menuitemcheckbox"], [role="menuitemradio"], [role="separator"], [role="slider"], [role="spinbutton"], [role="switch"], [role="tab"], [role="tabpanel"], [role="textbox"], [role="tree"], [role="treegrid"], [role="treeitem"], [data-testid], [data-test], [data-cy], [data-qa], [aria-label], [aria-labelledby], [title], [alt], *[class*="text"], *[class*="content"], *[class*="title"], *[class*="heading"], *[class*="label"], *[class*="button"], *[class*="link"], *[class*="item"], *[class*="card"], *[class*="panel"], *[class*="widget"], *[class*="tile"], *[class*="box"], *[class*="element"]');
    
            
    
            textElements.forEach(element => {
    
                // Skip accessibility widget elements (check both shadow DOM and regular DOM)
    
                if (element.closest('.accessbit-widget-panel') || 
    
                    element.closest('#accessbit-widget-icon') ||
    
                    element.closest('accessbit-widget') ||
    
                    element.tagName === 'ACCESSIBILITY-WIDGET' ||
    
                    element.id === 'accessbit-widget-icon' ||
    
                    element.id === 'accessbit-widget-panel') {
    
                    return;
    
                }
    
                
    
                // Create named event handlers that can be removed later
    
                const mouseEnterHandler = (e) => {
    
                    // Show magnified text in semi-transparent black box
    
                    if (magnifier) {
    
                        // Strict text extraction to avoid phantom text on empty spaces
                        const tag = element.tagName;
                        let fullText = '';
                        if (tag === 'IMG') {
                            fullText = element.alt || element.title || element.getAttribute('aria-label') || '';
                        } else if (element.hasAttribute('aria-label')) {
                            fullText = element.getAttribute('aria-label') || '';
                        } else if (element.hasAttribute('aria-labelledby')) {
                            const labelledBy = element.getAttribute('aria-labelledby');
                            const labelElement = labelledBy ? document.getElementById(labelledBy) : null;
                            fullText = labelElement ? (labelElement.textContent || labelElement.innerText || '') : '';
                        } else if (element.hasAttribute('title')) {
                            fullText = element.getAttribute('title') || '';
                        } else if (element.hasAttribute('placeholder')) {
                            fullText = element.getAttribute('placeholder') || '';
                        } else if (element.hasAttribute('value') && (element.tagName === 'INPUT' || element.tagName === 'BUTTON')) {
                            fullText = element.getAttribute('value') || '';
                        } else {
                            // Only consider direct text nodes; avoid pulling nested container text
                            const directText = Array.from(element.childNodes)
                                .filter(n => n.nodeType === Node.TEXT_NODE)
                                .map(n => n.nodeValue)
                                .join(' ');
                            fullText = directText || '';
                            // Allow innerText fallback only for typical text elements
                            if (!fullText && element.matches('h1,h2,h3,h4,h5,h6,p,span,a,button,label,li,td,th,em,strong,small,code,pre,blockquote')) {
                                fullText = element.innerText || element.textContent || '';
                            }
                        }
    
                        
    
                        // Clean up the text (remove extra whitespace and normalize)
    
                        fullText = fullText ? fullText.replace(/\s+/g, ' ').trim() : '';
    
                        
    
                        // Normalize and validate
                        fullText = fullText ? fullText.replace(/\s+/g, ' ').trim() : '';
                        if (!fullText || element.offsetWidth === 0 || element.offsetHeight === 0) {
                            magnifier.style.display = 'none';
                            return;
                        }
    
                        
    
                        // Avoid pulling container text via generic fallbacks
    
                        
    
                        if (fullText) {
    
                            // Calculate position to keep popup within viewport
    
                            const viewportWidth = window.innerWidth;
    
                            const viewportHeight = window.innerHeight;
    
                            
    
                            // Set initial position
    
                            let left = e.clientX + 20;
    
                            let top = e.clientY - 50;
    
                            
    
                            // After setting content, we'll adjust position if needed
    
                            magnifier.style.left = left + 'px';
    
                            magnifier.style.top = top + 'px';
    
                            magnifier.style.fontSize = '24px'; // Increased font size
    
                            magnifier.style.fontWeight = 'bold';
    
                            magnifier.style.background = 'rgba(0, 0, 0, 0.8)';
    
                            magnifier.style.color = 'white';
    
                            magnifier.style.padding = '16px 20px'; // Increased padding
    
                            magnifier.style.borderRadius = '8px';
    
                            magnifier.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.5)';
    
                            magnifier.style.zIndex = '1000000';
    
                            magnifier.style.width = 'auto'; // Auto width based on content
    
                            magnifier.style.maxWidth = '600px'; // Maximum width limit
    
                            magnifier.style.wordWrap = 'break-word';
    
                            magnifier.style.lineHeight = '1.4';
    
                            magnifier.style.whiteSpace = 'normal'; // Allow text to wrap naturally
    
                            magnifier.style.overflow = 'visible'; // No scroll, let it grow
    
                            magnifier.style.height = 'auto'; // Auto height based on content
    
                            magnifier.textContent = fullText; // Show complete text
    
                            magnifier.style.display = 'block';
    
                            
    
                            // Now adjust position based on actual popup size
    
                            setTimeout(() => {
    
                                const popupRect = magnifier.getBoundingClientRect();
    
                                const popupWidth = popupRect.width;
    
                                const popupHeight = popupRect.height;
    
                                
    
                                // Adjust left position if popup goes off right edge
    
                                if (left + popupWidth > viewportWidth) {
    
                                    left = e.clientX - popupWidth - 20; // Show to the left of cursor
    
                                    magnifier.style.left = left + 'px';
    
                                }
    
                                
    
                                // Adjust top position if popup goes off bottom
    
                                if (top + popupHeight > viewportHeight) {
    
                                    top = viewportHeight - popupHeight - 10;
    
                                    magnifier.style.top = top + 'px';
    
                                }
    
                            }, 10);
    
                            
    
                            // Check if popup goes off top edge
    
                            if (top < 10) {
    
                                top = e.clientY + 20; // Show below cursor if too close to top
    
                                magnifier.style.top = top + 'px';
    
                            }
    
    
                        }
    
                    }
    
                };
    
                
    
                const mouseLeaveHandler = (e) => {
    
                    // Hide magnifier
    
                    if (magnifier) {
    
                        magnifier.style.display = 'none';
    
                    }
    
                };
    
                
    
                // Store handlers for later removal
    
                this.textMagnifierHandlers.set(element, {
    
                    mouseenter: mouseEnterHandler,
    
                    mouseleave: mouseLeaveHandler
    
                });
    
                
    
                // Add event listeners
    
                element.addEventListener('mouseenter', mouseEnterHandler);
    
                element.addEventListener('mouseleave', mouseLeaveHandler);
    
            });
    
            
    

    
            
    
            // Add a global mouseover listener as a fallback to catch any elements that might have been missed
    
            const globalMouseOverHandler = (e) => {
    
                const target = e.target;
    
                
    
                // Skip if target is the magnifier itself or accessibility widget
    
                if (target.id === 'text-magnifier' || 
    
                    target.closest('.accessbit-widget-panel') || 
    
                    target.closest('#accessbit-widget-icon') ||
    
                    target.closest('accessbit-widget') ||
    
                    target.tagName === 'ACCESSIBILITY-WIDGET' ||
    
                    target.id === 'accessbit-widget-icon' ||
    
                    target.id === 'accessbit-widget-panel') {
    
                    return;
    
                }
    
                
    
                // Check if this element already has a magnifier handler
    
                if (this.textMagnifierHandlers.has(target)) {
    
                    return; // Already handled
    
                }
    
                
    
                // Only add magnifier to elements that have text content or are interactive
    
                const hasText = target.textContent && target.textContent.trim();
    
                const isInteractive = target.tagName === 'A' || target.tagName === 'BUTTON' || 
    
                                    target.tagName === 'INPUT' || target.tagName === 'SELECT' || 
    
                                    target.tagName === 'TEXTAREA' || target.hasAttribute('role') ||
    
                                    target.hasAttribute('onclick') || target.hasAttribute('onmouseover');
    
                const hasAriaLabel = target.hasAttribute('aria-label') || target.hasAttribute('aria-labelledby');
    
                const hasTitle = target.hasAttribute('title');
    
                const hasAlt = target.tagName === 'IMG' && target.hasAttribute('alt');
    
                
    
                if (hasText || isInteractive || hasAriaLabel || hasTitle || hasAlt) {
    
                    // Add magnifier to this element
    
                    const mouseEnterHandler = (e) => {
    
                        if (magnifier) {
    
                            let fullText = '';
    
                            
    
                            // Use the same comprehensive text extraction logic
    
                            if (target.tagName === 'IMG') {
    
                                fullText = target.alt || target.title || target.getAttribute('aria-label') || 'Image';
    
                            } else if (target.hasAttribute('aria-label')) {
    
                                fullText = target.getAttribute('aria-label');
    
                            } else if (target.hasAttribute('aria-labelledby')) {
    
                                const labelledBy = target.getAttribute('aria-labelledby');
    
                                const labelElement = document.getElementById(labelledBy);
    
                                if (labelElement) {
    
                                    fullText = labelElement.textContent || labelElement.innerText;
    
                                }
    
                            } else if (target.hasAttribute('title')) {
    
                                fullText = target.getAttribute('title');
    
                            } else if (target.hasAttribute('placeholder')) {
    
                                fullText = target.getAttribute('placeholder');
    
                            } else if (target.hasAttribute('value') && (target.tagName === 'INPUT' || target.tagName === 'BUTTON')) {
    
                                fullText = target.getAttribute('value');
    
                            } else {
    
                                fullText = target.innerText || target.textContent;
    
                            }
    
                            
    
                            fullText = fullText ? fullText.replace(/\s+/g, ' ').trim() : '';
    
                            
    
                            if (fullText) {
    
                                // Use the same positioning and styling logic
    
                                const viewportWidth = window.innerWidth;
    
                                const viewportHeight = window.innerHeight;
    
                                let left = e.clientX + 20;
    
                                let top = e.clientY - 50;
    
                                
    
                                magnifier.style.left = left + 'px';
    
                                magnifier.style.top = top + 'px';
    
                                magnifier.style.fontSize = '24px';
    
                                magnifier.style.fontWeight = 'bold';
    
                                magnifier.style.background = 'rgba(0, 0, 0, 0.8)';
    
                                magnifier.style.color = 'white';
    
                                magnifier.style.padding = '16px 20px';
    
                                magnifier.style.borderRadius = '8px';
    
                                magnifier.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.5)';
    
                                magnifier.style.zIndex = '1000000';
    
                                magnifier.style.width = 'auto';
    
                                magnifier.style.maxWidth = '600px';
    
                                magnifier.style.wordWrap = 'break-word';
    
                                magnifier.style.lineHeight = '1.4';
    
                                magnifier.style.whiteSpace = 'normal';
    
                                magnifier.style.overflow = 'visible';
    
                                magnifier.style.height = 'auto';
    
                                magnifier.textContent = fullText;
    
                                magnifier.style.display = 'block';
    
                                
    
                                // Adjust position if needed
    
                                setTimeout(() => {
    
                                    const popupRect = magnifier.getBoundingClientRect();
    
                                    const popupWidth = popupRect.width;
    
                                    const popupHeight = popupRect.height;
    
                                    
    
                                    if (left + popupWidth > viewportWidth) {
    
                                        left = e.clientX - popupWidth - 20;
    
                                        magnifier.style.left = left + 'px';
    
                                    }
    
                                    
    
                                    if (top + popupHeight > viewportHeight) {
    
                                        top = viewportHeight - popupHeight - 10;
    
                                        magnifier.style.top = top + 'px';
    
                                    }
    
                                }, 10);
    
                                
    
                                if (top < 10) {
    
                                    top = e.clientY + 20;
    
                                    magnifier.style.top = top + 'px';
    
                                }
    
                            }
    
                        }
    
                    };
    
                    
    
                    const mouseLeaveHandler = (e) => {
    
                        if (magnifier) {
    
                            magnifier.style.display = 'none';
    
                        }
    
                    };
    
                    
    
                    // Store handlers for later removal
    
                    this.textMagnifierHandlers.set(target, {
    
                        mouseenter: mouseEnterHandler,
    
                        mouseleave: mouseLeaveHandler
    
                    });
    
                    
    
                    // Add event listeners
    
                    target.addEventListener('mouseenter', mouseEnterHandler);
    
                    target.addEventListener('mouseleave', mouseLeaveHandler);
    
                }
    
            };
    
            
    
            // Add global mouseover listener
    
            document.addEventListener('mouseover', globalMouseOverHandler);
    
            
    
            // Store the global handler for cleanup
    
            this.globalMouseOverHandler = globalMouseOverHandler;
    
        }
    
    
    
        disableTextMagnifier() {
  
    
            const magnifier = document.getElementById('text-magnifier');
    
            if (magnifier) {
    
                magnifier.style.display = 'none';
    
            }
    
            
    
            // Check if accessibility widget is still visible
    
            const widgetContainer = document.getElementById('accessbit-widget-container');
    
            const widgetIcon = document.getElementById('accessbit-widget-icon');
    
            
    
            if (widgetContainer) {
    
                
    
            }
    
            
    
            // Remove hover effects from ALL text elements and interactive elements - comprehensive coverage
    
            const textElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span, div, a, button, label, li, td, th, img, article, section, aside, main, blockquote, pre, code, em, strong, i, b, u, small, sub, sup, mark, del, ins, cite, abbr, acronym, address, time, data, output, progress, meter, details, summary, figcaption, caption, dt, dd, dl, ol, ul, input, textarea, select, option, optgroup, fieldset, legend, form, table, thead, tbody, tfoot, tr, video, audio, canvas, svg, nav, header, footer, main, section, article, aside, figure, figcaption, blockquote, q, cite, abbr, acronym, address, time, data, output, progress, meter, details, summary, .logo, .nav-logo, .nav-menu li, .navbar, .menu, .nav-item, .nav-link, .btn, .button, .link, .text, .content, .title, .subtitle, .caption, .description, .heading, .subheading, .paragraph, .list-item, .table-cell, .form-label, .form-input, .form-button, .card, .card-title, .card-content, .card-text, .hero, .hero-title, .hero-subtitle, .banner, .banner-text, .sidebar, .sidebar-content, .footer, .footer-content, .header, .header-content, .navigation, .navigation-item, .breadcrumb, .breadcrumb-item, .pagination, .pagination-item, .tab, .tab-content, .accordion, .accordion-content, .modal, .modal-content, .tooltip, .tooltip-content, .dropdown, .dropdown-item, .menu, .menu-item, .submenu, .submenu-item, .widget, .widget-content, .panel, .panel-content, .tile, .tile-content, .grid, .grid-item, .flex, .flex-item, .container, .container-content, .wrapper, .wrapper-content, .box, .box-content, .item, .item-content, .element, .element-content, [role="button"], [role="link"], [role="menuitem"], [role="tab"], [role="option"], [role="checkbox"], [role="radio"], [role="textbox"], [role="combobox"], [role="listbox"], [role="tree"], [role="treeitem"], [role="grid"], [role="gridcell"], [role="columnheader"], [role="rowheader"], [role="row"], [role="cell"], [role="table"], [role="rowgroup"], [role="columnheader"], [role="rowheader"], [role="banner"], [role="navigation"], [role="main"], [role="complementary"], [role="contentinfo"], [role="search"], [role="form"], [role="region"], [role="alert"], [role="alertdialog"], [role="dialog"], [role="log"], [role="marquee"], [role="status"], [role="timer"], [role="tooltip"], [role="tabpanel"], [role="tablist"], [role="menubar"], [role="menu"], [role="menuitem"], [role="menuitemcheckbox"], [role="menuitemradio"], [role="separator"], [role="slider"], [role="spinbutton"], [role="switch"], [role="tab"], [role="tabpanel"], [role="textbox"], [role="tree"], [role="treegrid"], [role="treeitem"], [data-testid], [data-test], [data-cy], [data-qa], [aria-label], [aria-labelledby], [title], [alt], *[class*="text"], *[class*="content"], *[class*="title"], *[class*="heading"], *[class*="label"], *[class*="button"], *[class*="link"], *[class*="item"], *[class*="card"], *[class*="panel"], *[class*="widget"], *[class*="tile"], *[class*="box"], *[class*="element"]');
    
            
    
            textElements.forEach(element => {
    
                // Skip accessibility widget elements (check both shadow DOM and regular DOM)
    
                if (element.closest('.accessbit-widget-panel') || 
    
                    element.closest('#accessbit-widget-icon') ||
    
                    element.closest('accessbit-widget') ||
    
                    element.tagName === 'ACCESSIBILITY-WIDGET' ||
    
                    element.id === 'accessbit-widget-icon' ||
    
                    element.id === 'accessbit-widget-panel') {
    
                    return;
    
                }
    
                
    
                // Remove highlight effects
    
                element.style.background = '';
    
                element.style.border = '';
    
                element.style.borderRadius = '';
    
                element.style.padding = '';
    
                element.style.boxShadow = '';
    
                element.style.transform = '';
    
                element.style.transition = '';
    
                
    
                // Remove event listeners using stored handlers
    
                const handlers = this.textMagnifierHandlers.get(element);
    
                if (handlers) {
    
                    element.removeEventListener('mouseenter', handlers.mouseenter);
    
                    element.removeEventListener('mouseleave', handlers.mouseleave);
    
                    this.textMagnifierHandlers.delete(element);
    
                }
    
            });
    
            
    
            // Remove global mouseover listener if it exists
    
            if (this.globalMouseOverHandler) {
    
                document.removeEventListener('mouseover', this.globalMouseOverHandler);
    
                this.globalMouseOverHandler = null;
    
            }
    
            
    
            // Check widget visibility again after cleanup
    
            if (widgetContainer) {
    
               
            }
    
            
        }
    
    
    
        enableFontSizing() {
    
            // Use the inline controls instead of creating separate panel
    
            this.showFontSizingControls();
    
          
    
            
    
            // Test if controls exist
    
            const controls = this.shadowRoot.getElementById('font-sizing-controls');
    
            if (controls) {
    
           
    
            } else {
    
             
            }
    
        }
    
    
    
        disableFontSizing() {
    
            // Reset font size to normal when disabling
    
            this.fontSize = 100;
    
            this.resetFontSize();
    
            
    
            // Hide the controls
    
            const controls = this.shadowRoot.getElementById('font-sizing-controls');
    
            if (controls) {
    
                controls.style.display = 'none';
    
            }
    
            
    
        }
    
    
    
        changeFontSize(factor) {
    
            const currentSize = parseFloat(getComputedStyle(document.body).fontSize);
    
            document.body.style.fontSize = (currentSize * factor) + 'px';
    
        }
    
    
    
        resetFontSize() {
    
            // Reset body font size
    
            document.body.style.fontSize = '';
    
            
    
            // Remove any inline font-size styles that were applied to individual elements
    
            const elements = document.querySelectorAll('*');
    
            let resetCount = 0;
    
            elements.forEach(element => {
    
                if (element.style.fontSize) {
    
                    element.style.fontSize = '';
    
                    resetCount++;
    
                }
    
            });
    
            
    
            // Clear stored original font sizes
    
            this.originalFontSizes.clear();
    
            
    
            // Reset the internal value
    
            this.fontSize = 100;
    
            this.settings['font-size'] = 100; // Save to settings
    
            
    
            // Force update the display
    
            this.updateFontSizeDisplay();
    
            this.saveSettings(); // Persist the reset
    
    
            
    
            // Additional safety: ensure no font-size styles remain
    
            setTimeout(() => {
    
                const remainingElements = document.querySelectorAll('[style*="font-size"]');
    
                if (remainingElements.length > 0) {
    
    
                    remainingElements.forEach(element => {
    
                        element.style.fontSize = '';
    
                    });
    
                }
    
            }, 100);
    
        }
    
    
    
    
    
        // Content Scaling Methods
    
        increaseContentScale() {
            
            this.contentScale = Math.min(this.contentScale + 2, 120); // 2% increment, max 120%
            this.settings['content-scale'] = this.contentScale;
            
            // Mark content scaling as used
            localStorage.setItem('content-scaling-used', 'true');
            
            
            this.updateContentScale();
            this.updateContentScaleDisplay();
            this.saveSettings();
        }
        
        decreaseContentScale() {
          
            this.contentScale = Math.max(this.contentScale - 2, 50); // 2% decrement, minimum 50%
            this.settings['content-scale'] = this.contentScale;
            
            // Mark content scaling as used
            localStorage.setItem('content-scaling-used', 'true');
            
  
            this.updateContentScale();
            this.updateContentScaleDisplay();
            this.saveSettings();
        }
        
        updateContentScale() {
            const body = document.body;
            
            // If content scale is 100%, reset to normal
            if (this.contentScale === 100) {
                // Remove any existing content scaling CSS
                const existingStyle = document.getElementById('content-scaling-styles');
                if (existingStyle) {
                    existingStyle.remove();
                }
                
                // Reset widget elements to normal size
                this.resetWidgetScale();
                
                return;
            }
            
            // Create or update CSS that scales content without breaking layouts
            let style = document.getElementById('content-scaling-styles');
            if (!style) {
                style = document.createElement('style');
                style.id = 'content-scaling-styles';
                document.head.appendChild(style);
            }
            
            const scale = this.contentScale / 100;
            const inverseScale = 1 / scale;
            
            style.textContent = `
                /* Content scaling using zoom - works in Chrome, Safari, Edge, Firefox 110+ */
                html {
                    zoom: ${scale} !important;
                }
                
                /* Ensure body and html can scroll properly */
                html, body {
                    overflow-x: hidden !important;
                    overflow-y: auto !important;
                }
            `;
            
            // Counter-scale widget elements directly via JavaScript (Shadow DOM can't be targeted by CSS)
            this.applyWidgetCounterScale(inverseScale);
        }
        
        // Apply counter-scaling to widget elements to maintain fixed size
        applyWidgetCounterScale(inverseScale) {
            if (!this.shadowRoot) return;
            
            // Inject counter-scaling styles into Shadow DOM
            let counterStyle = this.shadowRoot.getElementById('content-scaling-counter');
            if (!counterStyle) {
                counterStyle = document.createElement('style');
                counterStyle.id = 'content-scaling-counter';
                this.shadowRoot.appendChild(counterStyle);
            }
            
            // Use zoom to counter the html zoom - maintains original visual size
            counterStyle.textContent = `
                /* Counter-scale widget elements to maintain fixed size */
                #accessbit-widget-panel,
                #accessbit-widget-icon {
                    zoom: ${inverseScale} !important;
                }
                
                /* Ensure panel maintains its height regardless of zoom */
                #accessbit-widget-panel {
                    min-height: auto !important;
                    height: auto !important;
                }
            `;
        }
        
        // Reset widget scale when content scaling is disabled
        resetWidgetScale() {
            if (!this.shadowRoot) return;
            
            // Remove counter-scaling styles
            const counterStyle = this.shadowRoot.getElementById('content-scaling-counter');
            if (counterStyle) {
                counterStyle.remove();
            }
        }
        
        updateContentScaleDisplay() {
            const display = this.shadowRoot.getElementById('content-scale-value');
            if (display) {
                display.textContent = this.contentScale + '%';
           
            }
        }
        
        toggleContentScalingControls(enabled) {
            const controls = this.shadowRoot.getElementById('content-scaling-controls');
            if (controls) {
                controls.style.display = enabled ? 'block' : 'none';
            }
            
            if (enabled) {
                this.updateContentScaleDisplay();
                if (this.contentScale !== 100) {
                    this.updateContentScale();
                }
            } else {
                // Reset content scale when disabled
                this.contentScale = 100;
                this.settings['content-scale'] = 100;
                this.updateContentScale();
                this.saveSettings();
            }
        }
    
    
    
        toggleFontSizingControls(enabled) {
    
           
    
            const controls = this.shadowRoot.getElementById('font-sizing-controls');
    
    
            if (controls) {
    
                controls.style.display = enabled ? 'block' : 'none';
    
               
    
                // Force the display with !important
                if (enabled) {
                    controls.style.setProperty('display', 'block', 'important');
             
                } else {
                    controls.style.setProperty('display', 'none', 'important');
                    
                }
    
            }
    
            
    
            if (enabled) {
                // Check if font sizing was actually used (not just toggled on)
                const wasFontSizingUsed = localStorage.getItem('font-sizing-used') === 'true';
                
                if (!wasFontSizingUsed && this.fontSize === 100) {
                  
                    return;
                }
            }
    
            // Save the toggle state
    
            this.settings['font-sizing'] = enabled;
    
            this.saveSettings();
    
            
    
            if (enabled) {
    
        
    
                // Always update display to show current percentage
                this.updateFontSizeDisplay();
    
                // Show the current percentage in the display
                const fontSizeDisplay = this.shadowRoot.getElementById('font-size-display');
                if (fontSizeDisplay) {
                    fontSizeDisplay.textContent = `${this.fontSize}%`;
                }
    
                // Only process font sizes if font size is not 100%
                if (this.fontSize !== 100) {
                
                    this.storeOriginalFontSizes();
    
                    this.updateFontSizeEnhanced();
    
                } else {
    
                  
               
    
                }
    
            } else {
    
                // Reset font size when disabled
    
                this.fontSize = 100;
    
                this.settings['font-size'] = 100;
    
                this.resetFontSize();
    
                this.saveSettings();
    
            }
    
        }
    
    
    
        toggleLineHeightControls(enabled) {
    
            
    
            const controls = this.shadowRoot.getElementById('line-height-controls');
    
         
            if (controls) {
    
                controls.style.display = enabled ? 'block' : 'none';
    
             
    
                // Force the display with !important
                if (enabled) {
                    controls.style.setProperty('display', 'block', 'important');
           
                } else {
                    controls.style.setProperty('display', 'none', 'important');
          
                }
    
            }
    
            
    
            if (enabled) {
               
                // Bind the line height events when controls are enabled
                this.bindLineHeightEvents();
                
                // Only save the toggle state if line height is actually not 100%
                // This prevents the toggle from staying on when user just toggles it without using it
                if (this.lineHeight === 100) {
                  
                    return;
                }
            }
    
            // Save the toggle state
    
            this.settings['adjust-line-height'] = enabled;
    
            this.saveSettings();
    
            
    
            if (enabled) {
    
                // Show controls and restore current line height value
                this.updateLineHeightDisplay();
                
                // Show the current percentage in the display
                const lineHeightDisplay = this.shadowRoot.getElementById('line-height-display');
                if (lineHeightDisplay) {
                    lineHeightDisplay.textContent = `${this.lineHeight}%`;
                }
    
                
    
          
                
    
                // Bind events to the line height buttons when they become visible
    
                this.bindLineHeightEvents();
                this.bindLineHeightEventsDirect();
                
                // Test the functionality
                setTimeout(() => {
                    this.testLineHeight();
                }, 1000);
    
            
    
            } else {
    
                // Reset line height when disabled
    
                this.lineHeight = 100;
    
                this.settings['line-height'] = 100;
    
                this.resetLineHeight();
    
                this.saveSettings();
    
               
    
            }
    
        }
    
    
    
        showLineHeightControls() {
    
            const controls = this.shadowRoot.getElementById('line-height-controls');
    
            if (controls) {
    
                controls.style.display = 'block';
                
                // Bind events when controls are shown
                this.bindLineHeightEvents();
                this.bindLineHeightEventsDirect();
    
            }
    
        }
    
    
    
        hideLineHeightControls() {
    
            const controls = this.shadowRoot.getElementById('line-height-controls');
    
            if (controls) {
    
                controls.style.display = 'none';
    
            }
    
        }
    
    
    
        bindLineHeightEvents() {
    
        
            // Prevent duplicate event binding
            if (this.lineHeightEventsBound) {
             
                return;
            }
    
            
    
            // Wait a bit for the DOM to be ready
    
            setTimeout(() => {
    
                // Check if controls are visible first
                const controls = this.shadowRoot.getElementById('line-height-controls');
              
                if (!controls) {
                   
                    setTimeout(() => this.bindLineHeightEvents(), 200);
                    return;
                }
                
                // Force controls to be visible if they exist
                if (controls.style.display === 'none') {
                    controls.style.display = 'block';
                 
                }
    
                // Line height control buttons - using Shadow DOM
    
                const decreaseLineHeightBtn = this.shadowRoot.getElementById('decrease-line-height-btn');
    
             
                if (decreaseLineHeightBtn) {
    
    
                    
    
                    // Create a bound handler
    
                    this.decreaseLineHeightHandler = (e) => {
    
                        e.preventDefault();
    
                        e.stopPropagation();
    
                        
    
                        this.decreaseLineHeight();
    
                    };
    
                    
    
                    // Add event listener
    
                    decreaseLineHeightBtn.addEventListener('click', this.decreaseLineHeightHandler);
    
                    // Add keyboard support
                    decreaseLineHeightBtn.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            e.stopPropagation();
                         
                            this.decreaseLineHeight();
                        } else if (e.key === 'ArrowDown') {
                            // Down arrow decreases
                            e.preventDefault();
                            e.stopPropagation();
                            this.decreaseLineHeight();
                        } else if (e.key === 'ArrowUp') {
                            // Up arrow increases
                            e.preventDefault();
                            e.stopPropagation();
                            this.increaseLineHeight();
                        }
                    });
    
      
    
                } else {
    
    
                }
    
    
    
                const increaseLineHeightBtn = this.shadowRoot.getElementById('increase-line-height-btn');
    
                
    
                if (increaseLineHeightBtn) {
    
    
                    
    
                    // Create a bound handler
    
                    this.increaseLineHeightHandler = (e) => {
    
                        e.preventDefault();
    
                        e.stopPropagation();
    
                      
    
                        this.increaseLineHeight();
    
                    };
    
                    
    
                    // Add event listener
    
                    increaseLineHeightBtn.addEventListener('click', this.increaseLineHeightHandler);
    
                    // Add keyboard support
                    increaseLineHeightBtn.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            e.stopPropagation();
                         
                            this.increaseLineHeight();
                        } else if (e.key === 'ArrowDown') {
                            // Down arrow decreases
                            e.preventDefault();
                            e.stopPropagation();
                            this.decreaseLineHeight();
                        } else if (e.key === 'ArrowUp') {
                            // Up arrow increases
                            e.preventDefault();
                            e.stopPropagation();
                            this.increaseLineHeight();
                        }
                    });
    
                    
    
                } else {
    
               
    
                }
                
                // Mark events as bound
                this.lineHeightEventsBound = true;
    
            }, 500); // Increased delay to ensure DOM is ready and controls are visible
    
        }
        
        // Alternative method to bind line height events directly
        bindLineHeightEventsDirect() {
           
            
            const decreaseBtn = this.shadowRoot.getElementById('decrease-line-height-btn');
            const increaseBtn = this.shadowRoot.getElementById('increase-line-height-btn');
           
            if (decreaseBtn) {
               
                decreaseBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                 
                    this.decreaseLineHeight();
                };
               
            } else {
            
            }
            
            if (increaseBtn) {
              
                increaseBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                   
                    this.increaseLineHeight();
                };
          
            } else {
            
            }
        }
        
        // Test method to verify line height functionality
        testLineHeight() {

            
            const decreaseBtn = this.shadowRoot.getElementById('decrease-line-height-btn');
            const increaseBtn = this.shadowRoot.getElementById('increase-line-height-btn');
            const controls = this.shadowRoot.getElementById('line-height-controls');
            

            
            if (controls) {
                controls.style.display = 'block';
            
            }
            
         
            this.increaseLineHeight();
            

            this.decreaseLineHeight();
            
            // Test clicking the buttons programmatically
            if (increaseBtn) {
               
                increaseBtn.click();
            }
            
            if (decreaseBtn) {

                decreaseBtn.click();
            }
        }
    
    
    
        // Line Height Methods
    
        updateLineHeight() {
            // Adjust line-height per element, based on its own original value,
            // so big headings don't collapse and spacing changes are proportional.
            const factor = this.lineHeight / 100; // 100 = original, 110 = +10%, etc.
            
            // Clean up any old global CSS rule from previous versions
            const existingStyle = document.getElementById('line-height-css');
            if (existingStyle) {
                existingStyle.textContent = '';
            }
            
            const selector = 'p, span, li, td, th, label, small, em, strong, i, b,' +
                             'h1, h2, h3, h4, h5, h6,' +
                             'a, button, input, textarea, select';
            const elements = document.querySelectorAll(selector);
            
            elements.forEach(el => {
                try {
                    // Skip anything inside the accessibility widget UI
                    if (el.closest('.accessbit-widget, #accessbit-widget, .accessbit-widget-panel, .accessbit-widget-icon')) {
                        return;
                    }
                    
                    // Get or cache this element's original line-height
                    let base = this.originalLineHeights.get(el);
                    if (!base) {
                        const cs = window.getComputedStyle(el);
                        let lh = parseFloat(cs.lineHeight);
                        if (isNaN(lh)) {
                            const fs = parseFloat(cs.fontSize) || 16;
                            lh = fs * 1.4; // reasonable default ratio
                        }
                        base = lh;
                        this.originalLineHeights.set(el, base);
                    }
                    
                    const newValue = (base * factor).toFixed(3);
                    el.style.lineHeight = `${newValue}px`;
                } catch (_) {
                    // Ignore per-element failures
                }
            });
        }
    
    
    
        increaseLineHeight() {
    
         
            const oldLineHeight = this.lineHeight;
    
            this.lineHeight = Math.min(this.lineHeight + 10, 200); // Visual +10%; real mapping is subtle
    
            this.settings['line-height'] = this.lineHeight; // Save to settings
    
            // Mark line height feature as used
            localStorage.setItem('line-height-used', 'true');
    
            this.updateLineHeight();
    
       
            this.updateLineHeightDisplay();
    

            this.saveSettings(); // Persist to localStorage
    
    
        }
    
    
    
        decreaseLineHeight() {
    
          
            const oldLineHeight = this.lineHeight;
    
            this.lineHeight = Math.max(this.lineHeight - 10, 50); // Visual -10%; real mapping is subtle
    
            this.settings['line-height'] = this.lineHeight; // Save to settings
    
          
    
           
            this.updateLineHeight();
    
            this.updateLineHeightDisplay();
    
            this.saveSettings(); // Persist to localStorage
    
            
        }
    
    
    
        updateLineHeightDisplay() {
    
    
            const display = this.shadowRoot.getElementById('line-height-value');
           
    
            if (display) {
               
                display.textContent = this.lineHeight + '%';
               
    
            } else {
    
              
    
                // Try to find it in the main document as fallback
    
                const fallbackDisplay = document.getElementById('line-height-value');
    
                if (fallbackDisplay) {
    
                    fallbackDisplay.textContent = this.lineHeight + '%';
    
    
                } else {
    
                 
    
                }
    
            }
    
        }
    
    
    
        resetLineHeight() {
    
            
            // Remove CSS rules for line height
            const existingStyle = document.getElementById('line-height-css');
            if (existingStyle) {
                existingStyle.remove();
            }
    
            // Reset line height back to original website styling
            document.body.style.removeProperty('line-height');
            document.documentElement.style.removeProperty('line-height');
    
            
    
            // Remove any inline line-height styles that might have been added
    
            const elements = document.querySelectorAll('*');
    
            let resetCount = 0;
    
            elements.forEach(element => {
    
                if (element.style.lineHeight) {
    
                    element.style.lineHeight = '';
    
                    resetCount++;
    
                }
    
            });
    
            
    
            // Reset the internal value
    
            this.lineHeight = 100;
    
            this.settings['line-height'] = 100; // Save to settings
    
            // Clear the line-height-used flag since we're resetting to default
            localStorage.removeItem('line-height-used');
    
            // Force update the display
    
            this.updateLineHeightDisplay();
    
            this.saveSettings(); // Persist the reset

            
    
        }
    
    
    
        toggleLetterSpacingControls(enabled) {
    
           
    
            const controls = this.shadowRoot.getElementById('letter-spacing-controls');
       
    
            if (controls) {
    
                controls.style.display = enabled ? 'block' : 'none';
    
                
    
                // Force the display with !important
                if (enabled) {
                    controls.style.setProperty('display', 'block', 'important');
             
                } else {
                    controls.style.setProperty('display', 'none', 'important');
                  
                }
    
            }
    
            
    
            if (enabled) {
                // Check if letter spacing was actually used (not just toggled on)
                const wasLetterSpacingUsed = localStorage.getItem('letter-spacing-used') === 'true';
                
                if (!wasLetterSpacingUsed && this.letterSpacing === 100) {

                    return;
                }
            }
    
            // Save the toggle state
    
            this.settings['adjust-letter-spacing'] = enabled;
    
            this.saveSettings();
    
            
    
            if (enabled) {
    
    
                this.updateLetterSpacingDisplay();
    
            } else {
    
              
    
                // Reset letter spacing when disabled
    
                this.letterSpacing = 100;
    
                this.settings['letter-spacing'] = 100;
    
                this.resetLetterSpacing();
    
                this.saveSettings();
    
            }
    
        }
    
    
    
    
    
    
    
    
    
    
    
    
    
        increaseFontSize() {
    
       
    
            // Increase visual percentage by 5, but actual applied change will be subtle
            this.fontSize = Math.min(this.fontSize + 5, 200);
    
            this.settings['font-size'] = this.fontSize; // Save to settings
    
            // Mark that font sizing was actually used
            localStorage.setItem('font-sizing-used', 'true');
    
            this.updateFontSizeEnhanced();
    
            this.updateFontSizeDisplay();
    
            this.saveSettings(); // Persist to localStorage
    
    
        }
    
    
    
        decreaseFontSize() {
    
       
    
            // Decrease visual percentage by 5, but actual applied change will be subtle
            this.fontSize = Math.max(this.fontSize - 5, 50);
    
            this.settings['font-size'] = this.fontSize; // Save to settings
    
            // Mark that font sizing was actually used
            localStorage.setItem('font-sizing-used', 'true');
    
            this.updateFontSizeEnhanced();
    
            this.updateFontSizeDisplay();
    
            this.saveSettings(); // Persist to localStorage
    
          
        }
    
    
    
        updateFontSizeDisplay() {
    
         
            
    
            const display = this.shadowRoot.getElementById('font-size-value');
    
         
    
            
    
            if (display) {
    
                display.textContent = this.fontSize + '%';
    
               
    
            } else {
    
    
                // Try to find it in the main document as fallback
    
                const fallbackDisplay = document.getElementById('font-size-value');
    
                if (fallbackDisplay) {
    
                    fallbackDisplay.textContent = this.fontSize + '%';
    
                 
    
                } else {
    
                
    
                }
    
            }
    
        }
    
    
    
        // Letter Spacing Methods
    
        increaseLetterSpacing() {
    
    
            this.letterSpacing = Math.min(this.letterSpacing + 10, 200);
    
            this.settings['letter-spacing'] = this.letterSpacing; // Save to settings
    
            // Mark letter spacing feature as used
            localStorage.setItem('letter-spacing-used', 'true');
    
            this.updateLetterSpacing();
    
            this.updateLetterSpacingDisplay();
    
            this.saveSettings(); // Persist to localStorage
    
           
    
        }
    
    
    
        decreaseLetterSpacing() {
    
          
    
            this.letterSpacing = Math.max(this.letterSpacing - 10, 50);
    
            this.settings['letter-spacing'] = this.letterSpacing; // Save to settings
    
            // Mark letter spacing feature as used
            localStorage.setItem('letter-spacing-used', 'true');
    
            this.updateLetterSpacing();
    
            this.updateLetterSpacingDisplay();
    
            this.saveSettings(); // Persist to localStorage
    
          
    
        }
    
    
    
        updateLetterSpacing() {
    

    
            
    
            // If letter spacing is 100%, reset to normal and don't apply any changes
    
            if (this.letterSpacing === 100) {
    
                document.body.style.letterSpacing = '';
    
                return;
    
            }
    
            
    
            const scale = this.letterSpacing / 100;
    
            // At 100%, letter spacing should be 0px (no change)
    
            // At 150%, letter spacing should be 0.5px
    
            // At 200%, letter spacing should be 1px
    
            const letterSpacingValue = `${(scale - 1) * 0.5}px`;
    
            
    
            
    
            // Apply to all text elements except accessibility panel and icon/symbol elements
            const textElements = document.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b, h1, h2, h3, h4, h5, h6, a, button, input, textarea, select');
    
            
    
            textElements.forEach(element => {
    
                // Skip if element is inside accessibility panel
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
                    // Exclude icon fonts and ligature-based icons (prevents turning symbols into text)
                    const isIcon = element.matches('svg, i, .icon, [class*="icon"], [class*="fa-"], [class*="material-icons"], [data-icon], [class*="glyph"], [class*="chevron"], [class*="arrow"], [class*="ion-"], [class*="feather"], [class*="lucide"], [class*="heroicon"]');
                    if (isIcon) {
                        return;
                    }
                    element.style.letterSpacing = letterSpacingValue;
                }
    
            });
    
        
    
        }
    
    
    
        // Store original font sizes to prevent compounding
    
        storeOriginalFontSizes() {
    
            // Only store original sizes if we haven't done it before
    
            if (this.originalFontSizes.size > 0) {
    
                return; // Already stored
    
            }
    
            
    
            // If font size is 100%, don't store anything to avoid any side effects
    
            if (this.fontSize === 100) {
    

    
                return;
    
            }
    
            
    
            const textElements = document.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b, h1, h2, h3, h4, h5, h6, a, button, input, textarea, select');
    
            
    
            textElements.forEach(element => {
    
                // Skip if element is inside accessibility panel
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    // Get the current computed size without modifying any styles
    
                    const currentSize = parseFloat(window.getComputedStyle(element).fontSize);
    
                    
    
                    if (currentSize && !isNaN(currentSize)) {
    
                        this.originalFontSizes.set(element, currentSize);
    
                    }
    
                }
    
            });
    
            
    
            // Store body current font size
    
            const bodySize = parseFloat(window.getComputedStyle(document.body).fontSize);
    
            if (bodySize && !isNaN(bodySize)) {
    
                this.originalFontSizes.set(document.body, bodySize);
    
            }
    
            
    
    
        }
    
    
    
        // Enhanced font size method
    
        updateFontSizeEnhanced() {
    
            // Apply a gentler scaling curve so visual 5% steps only slightly change real size
            // Map [50..200]% to an effective factor around baseline using a mild intensity
            const intensity = 0.35; // lower = subtler effect
            const scale = 1 + ((this.fontSize - 100) / 100) * intensity;
    
            
    
            // If font size is 100%, just clear any existing font-size styles and don't apply scaling
    
            if (this.fontSize === 100) {
    
                const elements = document.querySelectorAll('*');
    
                elements.forEach(element => {
    
                    if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                        element.style.fontSize = '';
    
                    }
    
                });
    
    
                return;
    
            }
            
            // If vision-impaired mode is active, be more aggressive about preserving font sizes
            const isVisionImpaired = document.body.classList.contains('vision-impaired');
            if (isVisionImpaired) {
                
            }
    
            
    
            // Store original font sizes if not already stored
    
            this.storeOriginalFontSizes();
    
            
    
            // Clear all existing font-size styles first
    
            const elements = document.querySelectorAll('*');
    
            elements.forEach(element => {
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.fontSize = '';
    
                }
    
            });
    
            
    
            try {
                if (this.shadowRoot && this.shadowRoot.host) {
                    const host = this.shadowRoot.host;
                    const hostOriginal = this.originalFontSizes.get(host) || parseFloat(getComputedStyle(host).fontSize) || 14;
                    host.style.setProperty('font-size', `${hostOriginal}px`, 'important');
                    // Also explicitly keep the numeric display stable if present
                    const valueEl = this.shadowRoot.getElementById('font-size-value');
                    if (valueEl) {
                        const valOriginal = this.originalFontSizes.get(valueEl) || parseFloat(getComputedStyle(valueEl).fontSize) || hostOriginal;
                        valueEl.style.setProperty('font-size', `${valOriginal}px`, 'important');
                    }
                }
                // Fallback: plain DOM panel containers
                const panel = document.querySelector('.accessbit-widget-panel, #accessbit-widget');
                if (panel) {
                    const panelOriginal = this.originalFontSizes.get(panel) || parseFloat(getComputedStyle(panel).fontSize) || 14;
                    panel.style.setProperty('font-size', `${panelOriginal}px`, 'important');
                    const display = panel.querySelector('#font-size-value');
                    if (display) {
                        const dispOriginal = this.originalFontSizes.get(display) || parseFloat(getComputedStyle(display).fontSize) || panelOriginal;
                        display.style.setProperty('font-size', `${dispOriginal}px`, 'important');
                    }
                }
            } catch (_) {}
    
            
    
            // Apply to all text elements using their original sizes
    
            const textElements = document.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b, h1, h2, h3, h4, h5, h6, a, button, input, textarea, select');
    
            
    
            textElements.forEach(element => {
    
                // Skip if element is inside accessibility panel
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon, #accessbit-widget')) {
    
                    const originalSize = this.originalFontSizes.get(element);
    
                    if (originalSize && !isNaN(originalSize)) {
    
                        // Apply the scale to the original size
                        const newFontSize = `${originalSize * scale}px`;
                        element.style.setProperty('font-size', newFontSize);
    
                        // If vision-impaired mode is active, also set it with !important to override any CSS
                        if (isVisionImpaired) {
                            element.style.setProperty('font-size', newFontSize, 'important');
                        }
    
                    }
    
                }
    
            });
    
            
    
    
        }
    
    
    
        updateLetterSpacingDisplay() {
    
            
    
            const display = this.shadowRoot.getElementById('letter-spacing-value');
    
            
    
            
    
            if (display) {
    
                display.textContent = this.letterSpacing + '%';
    
    
            } else {
    
             
    
                // Try to find it in the main document as fallback
    
                const fallbackDisplay = document.getElementById('letter-spacing-value');
    
                if (fallbackDisplay) {
    
                    fallbackDisplay.textContent = this.letterSpacing + '%';
    
                
    
                } else {
    
                  
    
                }
    
            }
    
        }
    
    
    
        resetLetterSpacing() {
    
          
    
            
    
            // Reset the letter spacing value to 100%
    
            this.letterSpacing = 100;
    
            this.settings['letter-spacing'] = 100; // Save to settings
    
            
    
            // Reset letter spacing back to original website styling
    
            document.body.style.removeProperty('letter-spacing');
    
            
    
            // Remove any inline letter-spacing styles that might have been added
    
            const elements = document.querySelectorAll('*');
    
            let resetCount = 0;
    
            elements.forEach(element => {
    
                if (element.style.letterSpacing) {
    
                    element.style.removeProperty('letter-spacing');
    
                    resetCount++;
    
                }
    
            });
    
            
    
            // Update the display to show 100%
    
            this.updateLetterSpacingDisplay();
    
            this.saveSettings(); // Persist the reset
    
        
    
        }
    
    
    
    
    
        // Control Show/Hide Methods
    
        showContentScalingControls() {
    
            const controls = this.shadowRoot.getElementById('content-scaling-controls');
    
            if (controls) {
    
                controls.style.display = 'block';
    
            }
    
        }
    
    
    
        hideContentScalingControls() {
    
            const controls = this.shadowRoot.getElementById('content-scaling-controls');
    
            if (controls) {
    
                controls.style.display = 'none';
    
            }
    
        }
    
    
    
        showFontSizingControls() {
    
            const controls = this.shadowRoot.getElementById('font-sizing-controls');
    
            if (controls) {
    
                controls.style.display = 'block';
    
            }
    
        }
    
    
    
        hideFontSizingControls() {
    
            const controls = this.shadowRoot.getElementById('font-sizing-controls');
    
            if (controls) {
    
                controls.style.display = 'none';
    
            }
    
        }
    
    
    
    
    
    
    
        // Reset Methods
    
        resetContentScale() {
            this.contentScale = 100; // Reset to 100% (normal size)
            this.settings['content-scale'] = 100; // Save to settings
            
            // Remove content scaling CSS
            const existingStyle = document.getElementById('content-scaling-styles');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            // Reset any body styles
            const body = document.body;
            body.style.fontSize = '';
            
            this.updateContentScaleDisplay();
            this.saveSettings(); // Persist the reset
      
        }
    
    
    
        // Highlight Methods
    
        highlightTitles() {
    
            // Only target actual heading tags
            const headings = document.querySelectorAll(
                'h1, h2, h3, h4, h5, h6'
            );
    
            headings.forEach(heading => {
    
                // Skip if heading is inside accessibility panel
                if (heading.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
                    return;
                }
    
                // Avoid double-highlighting if cognitive boxes already wrap it
                if (heading.dataset.cognitiveBoxed) {
                    return;
                }
    
                // Basic guards to avoid false positives
                const text = (heading.textContent || '').trim();
                if (!text) return; // skip empty nodes
                if (heading.offsetParent === null) return; // skip hidden
                
                // Apply non-intrusive highlight directly on the heading (no wrapper)
                if (!heading.dataset.highlighted) {
                    heading.classList.add('aw-highlight-title');
                    heading.style.outline = '2px solid #6366f1';
                    heading.style.outlineOffset = '2px';
                    heading.style.borderRadius = '6px';
                    heading.style.boxShadow = '0 2px 8px rgba(99, 102, 241, 0.3)';
                    // Do NOT change display or alignment; preserve layout
                    heading.dataset.highlighted = 'true';
                }
    
            });
    
        }
    
    
    
        removeTitleHighlights() {
    
            // Use the same selector as highlightTitles to ensure all highlighted elements are found
            const headings = document.querySelectorAll(
                'h1, h2, h3, h4, h5, h6'
            );
    
            headings.forEach(heading => {
                if (heading.dataset.highlighted) {
                    heading.classList.remove('aw-highlight-title');
                    // Clear only the styles we added
                    heading.style.outline = '';
                    heading.style.outlineOffset = '';
                    heading.style.borderRadius = '';
                    heading.style.boxShadow = '';
                    delete heading.dataset.highlighted;
                }
            });
    
        }
    
    
    
        highlightLinks() {
    
            const links = document.querySelectorAll(
                [
                    'a',
                    'nav a', '.nav a', '.navbar a', '.nav-menu a',
                    '.menu a', '.dropdown a', '.dropdown-menu a',
                    '.breadcrumb a', '.pagination a',
                    '.menu-item a', '.submenu a',
                    '[role="link"]', '[role="menuitem"]', '[role="menuitemcheckbox"]', '[role="menuitemradio"]',
                    'button[role="menuitem"]', 'button[aria-haspopup]', 'button[aria-expanded]',
                    '[aria-haspopup="menu"]', '[aria-haspopup="true"]', '[aria-expanded]',
                    '.dropdown-item', '.menu-item', '.submenu-item', '.nav-link', '.nav-item > a', '.nav-item > button'
                ].join(', ')
            );
    
            links.forEach(link => {
                // Skip if link is inside accessibility panel
                if (link.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
                    return;
                }
    
                // Avoid double-highlighting if cognitive boxes already wrap it
                if (link.dataset.cognitiveBoxed) {
                    return;
                }
    
                // Non-intrusive highlight directly on the link (no wrapper, no alignment changes)
                if (!link.dataset.highlighted) {
                    link.classList.add('aw-highlight-link');
                    link.style.outline = '2px solid #6366f1';
                    link.style.outlineOffset = '2px';
                    // Preserve original button/link shape; no borderRadius override
                    link.style.boxShadow = '0 2px 6px rgba(99, 102, 241, 0.3)';
                    link.dataset.highlighted = 'true';
                }

            });

            // Observe dynamically added menu items (e.g., dropdowns opening later)
            if (!this.highlightLinksObserver) {
                let scheduled = null;
                const reapply = () => {
                    scheduled = null;
                    try { this.highlightLinks(); } catch (_) {}
                };
                this.highlightLinksObserver = new MutationObserver((mutations) => {
                    for (const m of mutations) {
                        if (m.type === 'childList' && (m.addedNodes && m.addedNodes.length)) {
                            if (!scheduled) {
                                scheduled = setTimeout(reapply, 100);
                            }
                            break;
                        }
                    }
                });
                this.highlightLinksObserver.observe(document.body, { childList: true, subtree: true });
            }

        }
    
    
    
        removeLinkHighlights() {
    
            const links = document.querySelectorAll('a');
    
            links.forEach(link => {
                if (link.dataset.highlighted) {
                    link.classList.remove('aw-highlight-link');
                    // Clear only the styles we added
                    link.style.outline = '';
                    link.style.outlineOffset = '';
                    link.style.borderRadius = '';
                    link.style.boxShadow = '';
                    delete link.dataset.highlighted;
                }
            });

            // Disconnect observer if present
            if (this.highlightLinksObserver) {
                try { this.highlightLinksObserver.disconnect(); } catch (_) {}
                this.highlightLinksObserver = null;
            }

            // Force a quick refresh to fully restore original styles/layout after un-highlighting
            try {
                setTimeout(() => {
                    try { window.location.reload(); } catch (_) {}
                }, 50);
            } catch (_) {}
    
        }
    
    
    
        showColorPicker(type) {
    
            const color = prompt(`Enter ${type} color (hex code):`, '#000000');
    
            if (color) {
    
                document.documentElement.style.setProperty(`--custom-${type}-color`, color);
    
                document.body.classList.add(`custom-${type}-color`);
    
            }
    
        }
    
    
    
        // Useful Links Methods
    
        enableUsefulLinks() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#useful-links');
    
            if (toggle) {
    
                toggle.checked = true;
    
            }
    
            
    
            this.createUsefulLinksDropdown();
    
            
    
        }
    
    
    
        disableUsefulLinks() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#useful-links');
    
            if (toggle) {
    
                toggle.checked = false;
    
            }
    
            
    
            this.removeUsefulLinksDropdown();
    

    
        }
    
    
    
        createUsefulLinksDropdown() {
    
            // Remove existing dropdown if any
    
            this.removeUsefulLinksDropdown();
    
            
    
            // Find the useful-links module in the panel
    
            const usefulLinksToggle = this.shadowRoot.querySelector('#useful-links');
    
          
    
            
    
            if (!usefulLinksToggle) {
    
               
    
                return;
    
            }
    
            
    
            const usefulLinksModule = usefulLinksToggle.closest('.profile-item');
    
            
    
            
    
            if (usefulLinksModule) {
    
                // Create dropdown content
    
                const dropdownContainer = document.createElement('div');
    
                dropdownContainer.id = 'useful-links-dropdown';
    
                dropdownContainer.className = 'useful-links-dropdown';
    
                
    
                // Create dropdown content
    
                // Clear container
                while (dropdownContainer.firstChild) {
                    dropdownContainer.removeChild(dropdownContainer.firstChild);
                }
                
                const content = document.createElement('div');
                content.className = 'useful-links-content';
                
                const usefulLinksSelect = document.createElement('select');
                usefulLinksSelect.id = 'useful-links-select';
                
                const options = [
                    { value: '', text: 'Select an option' },
                    { value: 'home', text: 'Home' },
                    { value: 'header', text: 'Header' },
                    { value: 'footer', text: 'Footer' },
                    { value: 'main-content', text: 'Main content' },
                    { value: 'about-us', text: 'About us' }
                ];
                
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value;
                    option.textContent = opt.text;
                    usefulLinksSelect.appendChild(option);
                });
                
                content.appendChild(usefulLinksSelect);
                dropdownContainer.appendChild(content);
                
                
    
                // Insert the dropdown INSIDE the profile-item, after the profile-info
    
                const profileInfo = usefulLinksModule.querySelector('.profile-info');
    
                const toggleSwitch = usefulLinksModule.querySelector('.toggle-switch');
    
                
    
                // Add class to profile-item to indicate dropdown is present
    
                usefulLinksModule.classList.add('has-dropdown');
                
    
                // Insert dropdown after the entire profile-item to avoid flex layout issues
                usefulLinksModule.parentNode.insertBefore(dropdownContainer, usefulLinksModule.nextSibling);
    
                
    
                // Add event listener to select
                
                const select = dropdownContainer.querySelector('#useful-links-select');
                
                if (select) {
                    select.addEventListener('change', (e) => {
                        const value = e.target.value;
                        if (value) {
                            this.navigateToSection(value);
                            // Keep the selected value visible instead of resetting
                            // This shows the user what they selected
                        }
                    });
                }
    
                
    
         
    
            } else {
    
                
    
            }
    
        }
    
    
    
        removeUsefulLinksDropdown() {
    
            const dropdown = this.shadowRoot.querySelector('#useful-links-dropdown');
    
            if (dropdown) {
    
                dropdown.remove();
    
                
    
                // Restore original structure
    
                const usefulLinksModule = this.shadowRoot.querySelector('#useful-links').closest('.profile-item');
    
                if (usefulLinksModule) {
    
                    usefulLinksModule.classList.remove('has-dropdown');
    
                    
    
                    // Clear inline styles to restore original CSS
    
                    usefulLinksModule.style.display = '';
    
                    usefulLinksModule.style.flexDirection = '';
    
                    usefulLinksModule.style.alignItems = '';
    
                    usefulLinksModule.style.justifyContent = '';
    
                    usefulLinksModule.style.flexWrap = '';
    
                    usefulLinksModule.style.flexFlow = '';
    
                    usefulLinksModule.style.flex = '';
    
                    
    
                    // Move toggle back to its original position
    
                    const profileInfo = usefulLinksModule.querySelector('.profile-info');
    
                    const toggleSwitch = profileInfo.querySelector('.toggle-switch');
    
                    if (toggleSwitch) {
    
                        // Remove toggle from profile-info
    
                        toggleSwitch.remove();
    
                        // Add toggle back to profile-item
    
                        usefulLinksModule.appendChild(toggleSwitch);
    
                    }
    
                }
    
           
    
            }
    
        }
    
    
    
        navigateToSection(section) {
    
      
    
            
    
            switch(section) {
    
                case 'home':
                    // Try to find home link or navigate to root
                    const homeLink = document.querySelector('a[href="/"], a[href*="home"], a[href*="index"], nav a[href="/"]');
                    if (homeLink && homeLink.href) {
                        window.location.href = homeLink.href;
                    } else {
                        // Navigate to root page
                        const baseUrl = window.location.origin;
                        window.location.href = baseUrl + '/';
                    }
                    break;
    
                case 'header':
                    // Find header on current page - try multiple common selectors in order of priority
                    let headerElement = document.querySelector('header[role="banner"], header, [role="banner"]');
                    
                    if (!headerElement) {
                        headerElement = document.querySelector('.header, .site-header, .main-header, .page-header');
                    }
                    
                    if (!headerElement) {
                        headerElement = document.querySelector('#header, #site-header, #main-header');
                    }
                    
                    if (!headerElement) {
                        headerElement = document.querySelector('[class*="header"]:not([class*="subheader"]):not([class*="sub-header"])');
                    }
                    
                    if (!headerElement) {
                        headerElement = document.querySelector('nav.navbar, nav.main-nav, nav[role="navigation"]');
                    }
                    
                    if (headerElement) {
                        // Get header position
                        const rect = headerElement.getBoundingClientRect();
                        const headerTop = window.pageYOffset + rect.top;
                        
                        // Check if header is fixed or sticky
                        const style = window.getComputedStyle(headerElement);
                        const isFixed = style.position === 'fixed' || style.position === 'sticky';
                        
                        if (isFixed) {
                            // For fixed/sticky headers, just scroll to top
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                            // Fallback if smooth scroll is disabled
                            setTimeout(() => {
                                if (window.pageYOffset > 5) {
                                    window.scrollTo({ top: 0, behavior: 'auto' });
                                }
                            }, 100);
                        } else {
                            // For normal headers, scroll to header position
                            try {
                                headerElement.scrollIntoView({ 
                                    behavior: 'smooth', 
                                    block: 'start',
                                    inline: 'nearest'
                                });
                                // Fallback if scrollIntoView doesn't work
                                setTimeout(() => {
                                    const currentPos = window.pageYOffset || window.scrollY || document.documentElement.scrollTop;
                                    if (Math.abs(currentPos - headerTop) > 20) {
                                        window.scrollTo({ top: Math.max(0, headerTop - 10), behavior: 'auto' });
                                    }
                                }, 150);
                            } catch (e) {
                                // Direct scroll if scrollIntoView fails
                                window.scrollTo({ top: Math.max(0, headerTop - 10), behavior: 'auto' });
                            }
                        }
                    } else {
                        // If no header found, scroll to top
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        setTimeout(() => {
                            if (window.pageYOffset > 5) {
                                window.scrollTo({ top: 0, behavior: 'auto' });
                            }
                        }, 100);
                    }
                    break;
    
                case 'footer':
                    // Find footer on current page - try multiple common selectors
                    const footerElement = document.querySelector('footer, .footer, [class*="footer"], [id*="footer"], [role="contentinfo"]');
                    if (footerElement) {
                        footerElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'end',
                            inline: 'nearest'
                        });
                    } else {
                        // If no footer found, scroll to bottom
                        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                    }
                    break;
    
                case 'main-content':
                    // Find main content on current page - try multiple common selectors
                    const mainContentElement = document.querySelector('main, .main, .content, .container, [class*="main"], [class*="content"], [id*="main"], [id*="content"], [role="main"]');
                    if (mainContentElement) {
                        mainContentElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    } else {
                        // If no main content found, scroll to top
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }
                    break;
    
                case 'about-us':
                    // First try to find about link in navigation (prioritize navigation over page sections)
                    // Search more broadly for about links - check all links on the page, not just nav
                    let aboutLink = document.querySelector('a[href*="about"], nav a[href*="about"], .nav a[href*="about"], [class*="nav"] a[href*="about"], [class*="menu"] a[href*="about"], [class*="header"] a[href*="about"], footer a[href*="about"], .footer a[href*="about"]');
                    
                    // If not found in nav, try to find any link with "about" in href or text
                    if (!aboutLink) {
                        const allLinks = document.querySelectorAll('a');
                        for (const link of allLinks) {
                            const href = (link.getAttribute('href') || '').toLowerCase();
                            const text = (link.textContent || '').toLowerCase();
                            if (href.includes('about') || (text.includes('about') && (href.startsWith('/') || href.startsWith('http') || !href.includes('#')))) {
                                aboutLink = link;
                                break;
                            }
                        }
                    }
                    
                    if (aboutLink && aboutLink.href) {
                        window.location.href = aboutLink.href;
                    } else {
                        // If no navigation link found, try to find about section on current page
                        const aboutElement = this.findElementBySelector('[id*="about"], [class*="about"], h1:contains("About"), h2:contains("About")');
                        if (aboutElement) {
                            this.scrollToElement('[id*="about"], [class*="about"], h1:contains("About"), h2:contains("About")');
                        } else {
                            // If no link or section found, scroll to top
                            // We don't navigate to guessed paths to avoid 404 errors
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        }
                    }
                    break;
    
                case 'portfolio':
                    // First try to find portfolio section on current page
                    const portfolioElement = this.findElementBySelector('[id*="portfolio"], [class*="portfolio"], h1:contains("Portfolio"), h2:contains("Portfolio")');
                    if (portfolioElement) {
                        this.scrollToElement('[id*="portfolio"], [class*="portfolio"], h1:contains("Portfolio"), h2:contains("Portfolio")');
                    } else {
                        // Try to find portfolio link in navigation
                        const portfolioLink = document.querySelector('a[href*="portfolio"], nav a[href*="portfolio"], .nav a[href*="portfolio"]');
                        if (portfolioLink && portfolioLink.href) {
                            window.location.href = portfolioLink.href;
                        } else {
                            // Don't navigate to non-existent paths - just scroll to top or show message
                            // This prevents 404 errors
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        }
                    }
                    break;
    
                default:
    
                  
    
            }
    
        }
        
        findElementBySelector(selector) {
            // Try multiple selectors
            const selectors = selector.split(', ');
            let element = null;
            
            for (const sel of selectors) {
                if (sel.includes(':contains')) {
                    // Handle text content search
                    const text = sel.match(/:contains\("([^"]+)"\)/)[1];
                    element = this.findElementByText(text);
                } else {
                    element = document.querySelector(sel);
                }
                
                if (element) break;
            }
            
            return element;
        }
    
    
    
        scrollToElement(selector) {
    
            // Try multiple selectors
    
            const selectors = selector.split(', ');
    
            let element = null;
    
            
    
            for (const sel of selectors) {
    
                if (sel.includes(':contains')) {
    
                    // Handle text content search
    
                    const text = sel.match(/:contains\("([^"]+)"\)/)[1];
    
                    element = this.findElementByText(text);
    
                } else {
    
                    element = document.querySelector(sel);
    
                }
    
                
    
                if (element) break;
    
            }
    
            
    
            if (element) {
    
                element.scrollIntoView({ 
    
                    behavior: 'smooth', 
    
                    block: 'start',
    
                    inline: 'nearest'
    
                });
    
    
            } else {
    
    
            }
    
        }
    
    
    
        findElementByText(text) {
    
            // Search for elements containing the text
    
            const elements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, p, div, section, article');
    
            for (const element of elements) {
    
                if (element.textContent.toLowerCase().includes(text.toLowerCase())) {
    
                    return element;
    
                }
    
            }
    
            return null;
    
        }
    
    
    
        // Reading Mask Methods
    
        enableReadingMask() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#reading-mask');
    
            if (toggle) {
    
                toggle.checked = true;
    
            }
    
            
    
            document.body.classList.add('reading-mask');
    
            this.createReadingMaskOverlay();
    
            this.createReadingMaskSpotlight();
    
    
        }
    
    
    
        disableReadingMask() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#reading-mask');
    
            if (toggle) {
    
                toggle.checked = false;
    
            }
    
            
    
            // Remove reading-mask class from body and html
    
            document.body.classList.remove('reading-mask');
    
            document.documentElement.classList.remove('reading-mask');
    
    
            
    
            // Remove overlay element
    
            this.removeReadingMaskOverlay();
    
            
    
            // Remove spotlight
    
            this.removeReadingMaskSpotlight();
    
            
    
            // Force remove any remaining reading-mask elements (updated for new approach)
    
            const spotlight = document.getElementById('reading-mask-spotlight');
    
            if (spotlight) {
    
                spotlight.remove();
    
              
            }
    
            
    
            // Force remove any remaining spotlight elements
    
            const remainingSpotlight = document.getElementById('reading-mask-spotlight');
    
            if (remainingSpotlight) {
    
                remainingSpotlight.remove();
    
               
    
            }
    
            
    
            // Force remove any inline styles that might be causing issues
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(element => {
    
                if (element.style.filter && element.style.filter.includes('brightness')) {
    
                    element.style.filter = '';
    
                }
    
                if (element.style.backdropFilter && element.style.backdropFilter.includes('brightness')) {
    
                    element.style.backdropFilter = '';
    
                }
    
            });
    
            
    
    
        }
    
    
    
        createReadingMaskOverlay() {
    
            // Remove existing overlay if any
    
            this.removeReadingMaskOverlay();
    
            
    
            // Create overlay element
    
            const overlay = document.createElement('div');
    
            overlay.id = 'reading-mask-overlay';
    
            overlay.className = 'reading-mask-overlay';
    
            
    
            // Add overlay to body
    
            document.body.appendChild(overlay);
    
  
    
        }
    
    
    
        removeReadingMaskOverlay() {
    
            const overlay = document.getElementById('reading-mask-overlay');
    
            if (overlay) {
    
                overlay.remove();
    
         
    
            }
    
        }
    
    
    
        // Additional method to force remove reading mask overlay (can be called externally if needed)
    
        forceRemoveReadingMaskOverlay() {
    
         
    
            
    
            // Remove classes from both body and html
    
            document.body.classList.remove('reading-mask');
    
            document.documentElement.classList.remove('reading-mask');
    
            
    
            // Remove all reading mask related elements
    
            const elements = [
    
                'reading-mask-overlay',
    
                'reading-mask-spotlight',
    
                'reading-mask-spotlight-container'
    
            ];
    
            
    
            elements.forEach(id => {
    
                const element = document.getElementById(id);
    
                if (element) {
    
                    element.remove();
    
             
    
                }
    
            });
    
          
    
        }
    
    
    
        createReadingMaskSpotlight() {
    
            // Remove existing spotlight if any
    
            this.removeReadingMaskSpotlight();
    
            
    
            // Create full-screen dark overlay with rectangular spotlight cutout
            // Using two overlay elements: top and bottom
    
            const spotlight = document.createElement('div');
            spotlight.id = 'reading-mask-spotlight';
            spotlight.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
                z-index: 2147483647 !important;
                background: transparent;
            `;
    
            // Create top overlay
            const topOverlay = document.createElement('div');
            topOverlay.id = 'reading-mask-top';
            topOverlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 50%;
                background: rgba(0, 0, 0, 0.5);
                transition: all 0.1s ease;
            `;
    
            // Create bottom overlay
            const bottomOverlay = document.createElement('div');
            bottomOverlay.id = 'reading-mask-bottom';
            bottomOverlay.style.cssText = `
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 50%;
                background: rgba(0, 0, 0, 0.5);
                transition: all 0.1s ease;
            `;
    
            spotlight.appendChild(topOverlay);
            spotlight.appendChild(bottomOverlay);
            document.body.appendChild(spotlight);
    
    
    
            // Spotlight should be above widget panel, so we don't need to lower widget z-index
    
            
    
            // Add mouse move event listener for rectangular spotlight
    
            this.readingMaskMouseMoveHandler = (e) => {
    
                const y = e.clientY;
                
                // Calculate spotlight dimensions (full width, fixed height)
                const spotlightHeight = 200; // Fixed height for the rectangle
                const spotlightTop = y - spotlightHeight / 2;
                const spotlightBottom = y + spotlightHeight / 2;
    
                // Update top overlay (from top of screen to top of spotlight)
                topOverlay.style.height = Math.max(0, spotlightTop) + 'px';
    
                // Update bottom overlay (from bottom of spotlight to bottom of screen)
                bottomOverlay.style.top = Math.min(window.innerHeight, spotlightBottom) + 'px';
                bottomOverlay.style.height = Math.max(0, window.innerHeight - spotlightBottom) + 'px';
    
            };
    
            
    
            document.addEventListener('mousemove', this.readingMaskMouseMoveHandler);
    
            
    
        }
    
    
    
        removeReadingMaskSpotlight() {
    
            // Remove spotlight element (new approach - direct element removal)
    
            const spotlight = document.getElementById('reading-mask-spotlight');
    
            if (spotlight) {

                spotlight.remove();
    
            }
    
            
    
            // Remove mouse move event listener
    
            if (this.readingMaskMouseMoveHandler) {
    
                document.removeEventListener('mousemove', this.readingMaskMouseMoveHandler);
    
                this.readingMaskMouseMoveHandler = null;
    
            }
    
            
    
        }
    
    
    
        // Highlight Hover Methods
    
        enableHighlightHover() {
            this.settings['highlight-hover'] = true;
            document.body.classList.add('highlight-hover');
            
            // Add CSS rules for highlight hover if not already added
            if (!document.getElementById('highlight-hover-css')) {
                const style = document.createElement('style');
                style.id = 'highlight-hover-css';
                style.textContent = `
                    .highlight-hover *:hover {
                        outline: 2px solid #0066ff !important;
                        outline-offset: 2px !important;
                    }
                    
                    .highlight-hover a:hover {
                        outline: 2px solid #0066ff !important;
                        outline-offset: 2px !important;
                    }
                    
                    .highlight-hover button:hover,
                    .highlight-hover input:hover,
                    .highlight-hover select:hover,
                    .highlight-hover textarea:hover {
                        outline: 2px solid #0066ff !important;
                        outline-offset: 2px !important;
                    }
                    
                    .highlight-hover img:hover {
                        outline: 3px solid #0066ff !important;
                        outline-offset: 3px !important;
                    }
                `;
                document.head.appendChild(style);
            }
            
            this.saveSettings();

        }
    
    
    
        disableHighlightHover() {
            this.settings['highlight-hover'] = false;
            document.body.classList.remove('highlight-hover');
            
            // Remove CSS rules for highlight hover
            const existingStyle = document.getElementById('highlight-hover-css');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            this.saveSettings();
           
        }
    
    
    
        // Highlight Focus Methods
    
        enableHighlightFocus() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#highlight-focus');
    
            if (toggle) {
    
                toggle.checked = true;
    
            }
    
            
    
            document.body.classList.add('highlight-focus');
            
            // Inject CSS rules for highlight focus to ensure it works reliably
            if (!document.getElementById('highlight-focus-css')) {
                const style = document.createElement('style');
                style.id = 'highlight-focus-css';
                style.textContent = `
                    /* Highlight Focus - Show prominent focus indicators */
                    body.highlight-focus *:focus,
                    body.highlight-focus *:focus-visible {
                        outline: 3px solid #6366f1 !important;
                        outline-offset: 2px !important;
                        background: rgba(99, 102, 241, 0.1) !important;
                        border-radius: 4px !important;
                        transition: outline 0.2s ease, background 0.2s ease !important;
                    }
                    
                    body.highlight-focus a:focus,
                    body.highlight-focus a:focus-visible,
                    body.highlight-focus button:focus,
                    body.highlight-focus button:focus-visible,
                    body.highlight-focus input:focus,
                    body.highlight-focus input:focus-visible,
                    body.highlight-focus select:focus,
                    body.highlight-focus select:focus-visible,
                    body.highlight-focus textarea:focus,
                    body.highlight-focus textarea:focus-visible,
                    body.highlight-focus [tabindex]:focus,
                    body.highlight-focus [tabindex]:focus-visible,
                    body.highlight-focus [role="button"]:focus,
                    body.highlight-focus [role="button"]:focus-visible,
                    body.highlight-focus [role="link"]:focus,
                    body.highlight-focus [role="link"]:focus-visible,
                    body.highlight-focus [contenteditable="true"]:focus,
                    body.highlight-focus [contenteditable="true"]:focus-visible {
                        outline: 3px solid #6366f1 !important;
                        outline-offset: 2px !important;
                        background: rgba(99, 102, 241, 0.1) !important;
                        border-radius: 4px !important;
                        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3) !important;
                        transition: outline 0.2s ease, background 0.2s ease, box-shadow 0.2s ease !important;
                    }
                    
                    /* Exclude accessibility widget from highlight focus */
                    body.highlight-focus .accessbit-widget-panel *:focus,
                    body.highlight-focus .accessbit-widget-icon:focus {
                        outline: inherit !important;
                        outline-offset: inherit !important;
                        background: inherit !important;
                        border-radius: inherit !important;
                        box-shadow: inherit !important;
                    }
                `;
                document.head.appendChild(style);
            }
    
        
    
            
    
            // Apply focus styles to currently focused element if any
    
            const activeElement = document.activeElement;
    
            if (activeElement && activeElement !== document.body && activeElement !== document.documentElement) {
    
                // Only apply to interactive elements
    
                const isInteractiveElement = activeElement.tagName === 'A' || 
    
                                          activeElement.tagName === 'BUTTON' || 
    
                                          activeElement.tagName === 'INPUT' || 
    
                                          activeElement.tagName === 'SELECT' || 
    
                                          activeElement.tagName === 'TEXTAREA' ||
    
                                          activeElement.hasAttribute('tabindex') ||
    
                                          activeElement.hasAttribute('role') ||
    
                                          activeElement.isContentEditable;
    
                
    
                // Apply to interactive elements not inside the panel (allow the icon itself)
    
                if (!activeElement.closest('.accessbit-widget-panel') && 
    
                    isInteractiveElement) {
    
                  
    
                    activeElement.style.outline = '3px solid #6366f1';
    
                    activeElement.style.outlineOffset = '2px';
    
                    activeElement.style.background = 'rgba(99, 102, 241, 0.1)';
    
                    activeElement.style.borderRadius = '4px';
    
                    activeElement.style.transition = 'outline 0.2s ease, background 0.2s ease';
    
                    
    
                    // Track the currently focused element
    
                    this.currentlyFocusedElement = activeElement;
    
                }
    
            }
    
            
    
            // Add a global focus event listener to ensure immediate application of styles
    
            this.highlightFocusHandler = (e) => {
    
            
                
                // Special debugging for accessibility icon
                if (e.target.classList && e.target.classList.contains('accessbit-widget-icon')) {
                   
                    
                    // Always apply focus styles to accessibility icon when focused
                    e.target.style.outline = '3px solid #6366f1';
                    e.target.style.outlineOffset = '2px';
                    e.target.style.background = 'rgba(99, 102, 241, 0.1)';
                    e.target.style.borderRadius = '4px';
                    e.target.style.transition = 'outline 0.2s ease, background 0.2s ease';
                    e.target.style.boxShadow = '0 0 0 3px rgba(99, 102, 241, 0.3)';
                    return; // Exit early to prevent other focus handling
                }
    
                if (document.body.classList.contains('highlight-focus')) {
    
                    const focusedElement = e.target;
    
                    
    
                    // Only apply to interactive elements that can actually receive focus
    
                    const isInteractiveElement = focusedElement.tagName === 'A' || 
    
                                              focusedElement.tagName === 'BUTTON' || 
    
                                              focusedElement.tagName === 'INPUT' || 
    
                                              focusedElement.tagName === 'SELECT' || 
    
                                              focusedElement.tagName === 'TEXTAREA' ||
    
                                              focusedElement.hasAttribute('tabindex') ||
    
                                              focusedElement.hasAttribute('role') ||
    
                                              focusedElement.isContentEditable;
    
                    
    
                    // Skip if element is not interactive or is part of accessibility panel (but allow accessibility icon)
    
                    if (focusedElement === document.body || 
    
                        focusedElement === document.documentElement ||
    
                        focusedElement.closest('.accessbit-widget-panel') ||
    
                        !isInteractiveElement) {
    
                        return;
    
                    }
    
                    
    
                    // Remove focus styles from previously focused element
    
                    if (this.currentlyFocusedElement && this.currentlyFocusedElement !== focusedElement) {
    
                       
    
                        this.currentlyFocusedElement.style.outline = '';
    
                        this.currentlyFocusedElement.style.outlineOffset = '';
    
                        this.currentlyFocusedElement.style.background = '';
    
                        this.currentlyFocusedElement.style.borderRadius = '';
    
                        this.currentlyFocusedElement.style.transition = '';
    
                    }
    
                    
    
               
    
                    focusedElement.style.outline = '3px solid #6366f1';
    
                    focusedElement.style.outlineOffset = '2px';
    
                    focusedElement.style.background = 'rgba(99, 102, 241, 0.1)';
    
                    focusedElement.style.borderRadius = '4px';
    
                    focusedElement.style.transition = 'outline 0.2s ease, background 0.2s ease';
    
                    
    
                    // Track the currently focused element
    
                    this.currentlyFocusedElement = focusedElement;
    
                }
    
            };
    
            
    
            // Add the focus event listener
    
            document.addEventListener('focusin', this.highlightFocusHandler, true);
            
            // Add focusout handler to clean up accessibility icon styles
            this.highlightFocusOutHandler = (e) => {
                if (e.target.classList && e.target.classList.contains('accessbit-widget-icon')) {
         
                    e.target.style.outline = '';
                    e.target.style.outlineOffset = '';
                    e.target.style.background = '';
                    e.target.style.borderRadius = '';
                    e.target.style.transition = '';
                }
            };
            
            document.addEventListener('focusout', this.highlightFocusOutHandler, true);
    
            
    
            
    
            // Test if the feature is working by checking if we can find focusable elements
    
            const focusableElements = document.querySelectorAll('a, button, input, select, textarea, [tabindex], [role]');
    
    
            
    
            // Force a test focus on the first focusable element if any
    
            if (focusableElements.length > 0) {
    
    
            }
    
        }
    
    
    
        disableHighlightFocus() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#highlight-focus');
    
            if (toggle) {
    
                toggle.checked = false;
    
            }
    
            
    
            document.body.classList.remove('highlight-focus');
            
            // Remove the CSS rules for highlight focus
            const existingStyle = document.getElementById('highlight-focus-css');
            if (existingStyle) {
                existingStyle.remove();
            }
    
            
    
            // Remove focus styles from the currently tracked focused element
    
            if (this.currentlyFocusedElement) {
    
    
                this.currentlyFocusedElement.style.outline = '';
    
                this.currentlyFocusedElement.style.outlineOffset = '';
    
                this.currentlyFocusedElement.style.background = '';
    
                this.currentlyFocusedElement.style.borderRadius = '';
    
                this.currentlyFocusedElement.style.transition = '';
    
                this.currentlyFocusedElement = null;
    
            }
    
            
    
            // Also remove any remaining focus styles from all elements as a safety measure
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(element => {
    
                // Skip accessibility widget elements
    
                if (element.closest('.accessbit-widget-panel') || element.closest('#accessbit-widget-icon')) {
    
                    return;
    
                }
    
                
    
                // Remove focus-related inline styles
    
                if (element.style.outline && element.style.outline.includes('6366f1')) {
    
                   
    
                    element.style.outline = '';
    
                    element.style.outlineOffset = '';
    
                    element.style.background = '';
    
                    element.style.borderRadius = '';
    
                    element.style.transition = '';
    
                }
    
            });
    
            
    
            // Remove the focus event listener
    
            if (this.highlightFocusHandler) {
    
                document.removeEventListener('focusin', this.highlightFocusHandler, true);
    
                this.highlightFocusHandler = null;
    
            }
            
            // Remove the focusout handler
            if (this.highlightFocusOutHandler) {
                document.removeEventListener('focusout', this.highlightFocusOutHandler, true);
                this.highlightFocusOutHandler = null;
            }
    
            
    
            // Also remove the CSS class from body to ensure complete cleanup
    
            document.body.classList.remove('highlight-focus');
    
        }
    
    
    
        showStatement() {
            // Check if we have a custom accessibility statement link
            if (this.customizationData && this.customizationData.accessibilityStatementLink) {
                // Validate the link before opening
                const link = this.customizationData.accessibilityStatementLink.trim();
                if (link !== '') {
                    window.open(link, '_blank');
                    return;
                }
            }
            
            // Default statement if no link is provided
            alert('This website is committed to providing an accessible experience for all users. We follow WCAG 2.1 guidelines and continuously work to improve accessibility.');
        }
    
    
    
        resetSettings() {
    
    
            this.settings = {};
    
            this.saveSettings();
    
            this.applySettings();
    
            // Clear usage tracking flags for toggleable features
            localStorage.removeItem('content-scaling-used');
            localStorage.removeItem('font-sizing-used');
            localStorage.removeItem('line-height-used');
            localStorage.removeItem('letter-spacing-used');
            
            // Clear vision-impaired localStorage
            localStorage.removeItem('accessbit-widget-vision-impaired');

            
            // Reset language to English
            this.applyLanguage('en');
           
            
    
            // Remove only accessibility-related classes
    
            const body = document.body;
    
            const accessibilityClasses = [
    
                'seizure-safe', 'vision-impaired', 'adhd-friendly', 'cognitive-disability',
    
                'keyboard-nav', 'screen-reader', 'high-contrast', 'monochrome',
    
                'dark-contrast', 'light-contrast', 'high-saturation', 'low-saturation',
    
                'readable-font', 'align-center', 'align-left', 'align-right',
    
                'big-black-cursor', 'big-white-cursor',
    
                'content-scaling', 'font-sizing', 'adjust-line-height', 'adjust-letter-spacing',
    
                'highlight-titles', 'highlight-links', 'adjust-text-colors', 'adjust-title-colors',
    
                'adjust-bg-colors', 'mute-sound', 'read-mode', 'reading-guide',
    
                'reading-mask', 'useful-links', 'highlight-hover', 'highlight-focus',
    
                'text-magnifier', 'hide-images'
    
            ];
    
            
    
            const currentClasses = body.className.split(' ');
    
            const filteredClasses = currentClasses.filter(cls => 
    
                !accessibilityClasses.includes(cls)
    
            );
    
            body.className = filteredClasses.join(' ');
    
            
    
            // Reset scaling values
    
            this.contentScale = 100; // Reset to 100% (normal size)
    
            this.fontSize = 100;
    
            this.lineHeight = 100;
    
            this.letterSpacing = 100;
    
            
    
            // Reset font size
    
            this.resetFontSize();
    
            
    
            // Reset content scale
    
            this.resetContentScale();
    
            
    
            // Reset line height
    
            this.resetLineHeight();
    
            
    
    
    
            
    
            // Reset letter spacing
    
            this.resetLetterSpacing();
    
            
    
            // Disable text magnifier
    
            this.disableTextMagnifier();
    
            
    
            // Remove font size controls
    
            this.disableFontSizing();
    
            
    
                    // Hide all scaling controls
    
            this.hideContentScalingControls();
    
            this.hideFontSizingControls();
    
            this.hideLineHeightControls();
    
            this.hideLetterSpacingControls();
    
            
    
            // Remove highlights
    
            this.removeTitleHighlights();
    
            this.removeLinkHighlights();
    
            
    
            // Disable high contrast and saturation
    
            this.disableHighContrast();
    
            this.disableHighSaturation();
    
            this.disableDarkContrast();
    
            this.disableLightContrast();
    
            
    
            // Reset text colors
    
            this.resetTextColors();
    
            this.hideTextColorPicker();
    
            this.resetTitleColors();
    
            this.hideTitleColorPicker();
    
            this.resetBackgroundColors();
    
            this.hideBackgroundColorPicker();
    
            
    
            // Disable all profiles
            
            this.disableSeizureSafe();
            
            this.disableVisionImpaired();
            
            // Explicitly update vision-impaired toggle switch to off
            this.updateToggleSwitch('vision-impaired', false);
            
            this.disableADHDFriendly();
            
            this.disableCognitiveDisability();
            
            this.disableReadableFont();
    
            
    
            // Disable cursor features
    
            this.disableBigBlackCursor();
    
            this.disableBigWhiteCursor();
    
            
    
            // Reset cursor styles on Shadow DOM
    
            this.resetBigBlackCursor();
    
            this.resetBigWhiteCursor();
    
            
    
    
            
    
            // Remove cognitive boxes
    
            this.removeCognitiveBoxes();
    
            
    
            // Remove ADHD spotlight
    
            this.removeADHDSpotlight();
    
            
    
            // Disable read mode (remove read mode layer)
    
            this.disableReadMode();
    
            
    
            // Disable reading guide (remove horizontal bar)
    
            this.disableReadingGuide();
    
            
    
            // Disable reading mask (remove overlay and spotlight)
    
            this.disableReadingMask();
    
            
    
            // Force remove any remaining reading mask overlay
    
            this.forceRemoveReadingMaskOverlay();
    
            
    
            // Disable useful links (remove dropdown)
    
            this.disableUsefulLinks();
    
            
    
            // Reset custom colors
    
            document.documentElement.style.removeProperty('--custom-text-color');
    
            document.documentElement.style.removeProperty('--custom-title-color');
    
            document.documentElement.style.removeProperty('--custom-bg-color');
    
            
    
            // Reset all toggles in Shadow DOM
    
            const toggles = this.shadowRoot.querySelectorAll('.toggle-switch input');
    
            toggles.forEach(toggle => {
    
                toggle.checked = false;
    
            });
    
            
    
            // Update widget appearance after reset
    
            this.updateWidgetAppearance();
            
            // Ensure widget remains visible after reset - ADD THIS PROTECTION
            setTimeout(() => {
             
                const widgetContainer = document.getElementById('accessbit-widget-container');
                const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
                const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
                
                if (!widgetContainer) {
                
                    this.createWidget();
                    return;
                }
                
                if (!icon) {
                  
                } else {
                    // Force icon to be visible
                    icon.style.setProperty('display', 'flex', 'important');
                    icon.style.setProperty('visibility', 'visible', 'important');
                    icon.style.setProperty('opacity', '1', 'important');
              
                }
                
                if (!panel) {
                   
                } else {
                    // Ensure panel is properly hidden but not removed
                    panel.style.setProperty('display', 'none', 'important');
                    panel.style.setProperty('visibility', 'hidden', 'important');
               
                }
                
              
            }, 100);
    
        }
    
    
    
        loadSettings() {
    
            const saved = localStorage.getItem('accessibility-settings');
    
            if (saved) {
                // Security: Add error handling for JSON parsing to prevent prototype pollution
                try {
                    this.settings = JSON.parse(saved);
                    // Validate that settings is an object and not null
                    if (typeof this.settings !== 'object' || this.settings === null || Array.isArray(this.settings)) {
                        this.settings = {};
                    }
                } catch (e) {
                    console.warn('Failed to parse saved settings, using defaults:', e);
                    this.settings = {};
                }
            }
    
            
    
            // Set default settings for keyboard navigation if not already set
    
            if (this.settings['keyboard-nav'] === undefined) {
    
                this.settings['keyboard-nav'] = false; // Disabled by default
    
    
            }
    
            
    
            // Load content scale from settings
    
            if (this.settings['content-scale'] !== undefined) {
    
                this.contentScale = this.settings['content-scale'];
    
          
    
            } else {
    
                this.contentScale = 100; // Default to 100%
    
                this.settings['content-scale'] = 100;
    
    
            }
    
            
    
            // Set content scaling toggle state based on whether content scale is not 100%
    
            if (this.contentScale !== 100) {
    
                this.settings['content-scaling'] = true;
    
        
    
            } else if (this.settings['content-scaling'] === undefined) {
    
                this.settings['content-scaling'] = false;
    
            
    
            }
    
            
    
            // Load font size from settings
    
            if (this.settings['font-size'] !== undefined) {
    
                this.fontSize = this.settings['font-size'];
    
    
            } else {
    
                this.fontSize = 100; // Default to 100%
    
                this.settings['font-size'] = 100;
    
           
    
            }
    
            
    
            // Set font sizing toggle state based on whether font size is not 100%
    
            if (this.fontSize !== 100) {
    
                this.settings['font-sizing'] = true;
    
                
    
            } else if (this.settings['font-sizing'] === undefined) {
    
                this.settings['font-sizing'] = false;
    
             
    
            }
    
            
    
            // Load line height from settings
    
            if (this.settings['line-height'] !== undefined) {
    
                this.lineHeight = this.settings['line-height'];
    
           
    
            } else {
    
                this.lineHeight = 100; // Default to 100%
    
                this.settings['line-height'] = 100;
    
    
            }
    
            
    
            // Set line height toggle state based on whether line height is not 100%
            // Only enable toggle if line height is actually changed from default (100%)
            if (this.lineHeight !== 100) {
                this.settings['adjust-line-height'] = true;
 
            } else if (this.settings['adjust-line-height'] === undefined) {
                this.settings['adjust-line-height'] = false;
        
            }
    
            
    
            // Always update the line-height display to reflect the saved value across pages
            try {
                this.updateLineHeightDisplay();
                setTimeout(() => { try { this.updateLineHeightDisplay(); } catch (_) {} }, 50);
            } catch (_) {}

            // Apply line height CSS if it's not the default value
            if (this.lineHeight !== 100) {
              
                this.updateLineHeight();
            }
    
            
    
            // Load letter spacing from settings
    
            if (this.settings['letter-spacing'] !== undefined) {
    
                this.letterSpacing = this.settings['letter-spacing'];
    
              
    
            } else {
    
                this.letterSpacing = 100; // Default to 100%
    
                this.settings['letter-spacing'] = 100;
    
      
    
            }
    
            
    
            // Set letter spacing toggle state based on whether letter spacing is not 100%
    
            if (this.letterSpacing !== 100) {
    
                this.settings['adjust-letter-spacing'] = true;
    
         
    
            } else if (this.settings['adjust-letter-spacing'] === undefined) {
    
                this.settings['adjust-letter-spacing'] = false;
    
        
    
            }
    
            
    
            // Always update the letter-spacing display to reflect the saved value across pages
            try {
                this.updateLetterSpacingDisplay();
                setTimeout(() => { try { this.updateLetterSpacingDisplay(); } catch (_) {} }, 50);
            } catch (_) {}

            // Apply letter spacing CSS if it's not the default value
            if (this.letterSpacing !== 100) {
                this.updateLetterSpacing();
            }
    
            // Load text color from settings
    
            if (this.settings['text-color'] !== undefined && this.settings['text-color'] !== null) {
    
          
    
                // Apply the saved text color
    
                this.applyTextColor(this.settings['text-color']);
    
            }
    
            
    
            // Load title color from settings
    
            if (this.settings['title-color'] !== undefined && this.settings['title-color'] !== null) {
    
            
    
                // Apply the saved title color
    
                this.applyTitleColor(this.settings['title-color']);
    
            }
    
            
    
            // Load background color from settings
    
            if (this.settings['bg-color'] !== undefined && this.settings['bg-color'] !== null) {
    
                
    
                // Apply the saved background color
    
                this.applyBackgroundColor(this.settings['bg-color']);
    
            }
    
    
        }
    
    
    
        saveSettings() {
            // Save to localStorage (existing functionality)
            localStorage.setItem('accessibility-settings', JSON.stringify(this.settings));
            
            // Also save to KV storage for persistence across devices
            this.saveSettingsToKV();
        }
        
        // Save settings to KV storage
        async saveSettingsToKV() {
         
            
            try {
                // Get siteId first
                const siteId = await this.getSiteId();
                if (!siteId) {
                   
                    return;
                }
                
                if (!this.kvApiUrl) {
                    
                    return;
                }
                
                // Security: Validate siteId format
                if (typeof siteId !== 'string' || siteId.length > 100 || !/^[a-zA-Z0-9_-]+$/.test(siteId)) {
                    console.warn('Invalid siteId format, skipping KV save');
                    return;
                }
                
                // Security: Sanitize URL to remove sensitive query parameters
                let sanitizedUrl = window.location.href;
                try {
                    const url = new URL(window.location.href);
                    // Remove potentially sensitive query parameters
                    const sensitiveParams = ['token', 'password', 'secret', 'key', 'auth', 'session', 'sid'];
                    sensitiveParams.forEach(param => {
                        url.searchParams.delete(param);
                    });
                    sanitizedUrl = url.toString();
                } catch {
                    // If URL parsing fails, use origin only
                    sanitizedUrl = window.location.origin + window.location.pathname;
                }
                
                // Prepare settings data for KV
                const settingsData = {
                    siteId: siteId,
                    settings: this.settings,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent ? navigator.userAgent.substring(0, 500) : '', // Limit length
                    url: sanitizedUrl
                };
       
                
                const response = await this.isolatedFetch(`${this.kvApiUrl}/api/accessibility/save-settings`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settingsData)
                });
                
            
                
                if (!response.ok) {
                    const errorText = await response.text();
                 
                    return;
                }
                
                // Attempt JSON parse only if response is JSON
                const ctSave = response.headers.get('content-type') || '';
                if (ctSave.includes('application/json')) {
                    const result = await response.json();
                 
                } else {
                    const text = await response.text();
                
                }
                
            } catch (error) {
                         }
        }
        
        // Load user settings from KV storage
        async loadSettingsFromKV() {
       
            
            try {
                // First check payment status before loading settings
                const paymentValid = await this.checkPaymentStatus();
                if (!paymentValid) {
             
                    this.disableWidget();
                    return;
                }
                
                // Get siteId first
                const siteId = await this.getSiteId();
                if (!siteId) {
                 
                    return;
                }
                
                if (!this.kvApiUrl) {
                   
                    return;
                }

                
                const response = await this.isolatedFetch(`${this.kvApiUrl}/api/accessibility/user-settings?siteId=${siteId}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
              
                
                if (!response.ok) {
                    
                    return;
                }
                
                // Safely parse JSON only when Content-Type is JSON
                const ct = response.headers.get('content-type') || '';
                let data = null;
                if (ct.includes('application/json')) {
                    try {
                        data = await response.json();
                    } catch (parseErr) {
                        const raw = await response.text();
                  
                        return;
                    }
                } else {
                    const raw = await response.text();
                 
                    return;
                }
     
                
                if (data && typeof data === 'object' && data.settings && typeof data.settings === 'object') {
                    // Merge KV settings with existing settings (KV takes precedence)
                    const kvSettings = data.settings;
                    
                    
                    // Update settings object
                    Object.keys(kvSettings).forEach(key => {
                        this.settings[key] = kvSettings[key];
                    });
                    
                    // Save merged settings back to localStorage
            localStorage.setItem('accessibility-settings', JSON.stringify(this.settings));
    
                } else {
                 
                }
                
            } catch (error) {
             
            }
        }
    
    
    
        applySettings() {

    
            
    
            Object.entries(this.settings).forEach(([feature, enabled]) => {
    

    
                if (enabled) {
    
                    // Check usage tracking for special features before applying
                    let shouldApply = true;
                    
                    if (feature === 'content-scaling') {
                        const wasContentScalingUsed = localStorage.getItem('content-scaling-used') === 'true';
                        if (!wasContentScalingUsed && this.contentScale === 100) {
                    
                            shouldApply = false;
                        }
                    } else if (feature === 'font-sizing') {
                        const wasFontSizingUsed = localStorage.getItem('font-sizing-used') === 'true';
                        if (!wasFontSizingUsed && this.fontSize === 100) {
                      
                            shouldApply = false;
                        }
                    } else if (feature === 'adjust-line-height') {
                        const wasLineHeightUsed = localStorage.getItem('line-height-used') === 'true';
                        if (!wasLineHeightUsed && this.lineHeight === 100) {
                    
                            shouldApply = false;
                        }
                    } else if (feature === 'adjust-letter-spacing') {
                        const wasLetterSpacingUsed = localStorage.getItem('letter-spacing-used') === 'true';
                        if (!wasLetterSpacingUsed && this.letterSpacing === 100) {
                       
                            shouldApply = false;
                        }
                    }
    
                    if (shouldApply) {
                    this.applyFeature(feature, true);
    
                    // Update displays for numeric features
                    if (feature === 'adjust-line-height') {
                        this.updateLineHeightDisplay();
                    }
    
                    const toggle = this.shadowRoot.getElementById(feature);
    
                    if (toggle) toggle.checked = true;
                    } else {
                        // Remove the setting from localStorage since it wasn't actually used
                        delete this.settings[feature];
                        this.saveSettings();
                    }
    
                }
    
            });
    
            
    
            // Apply content scale if it's not 100% AND was actually used
    
            if (this.contentScale !== 100) {
    
                const wasContentScalingUsed = localStorage.getItem('content-scaling-used') === 'true';
                
                if (wasContentScalingUsed) {
         
    
                this.updateContentScale();
    
                this.updateContentScaleDisplay(); // Update the display value
    
                
    
                // Show content scaling controls if content scale is not 100%
    
                const controls = this.shadowRoot.getElementById('content-scaling-controls');
    
                if (controls) {
    
                    controls.style.display = 'block';
    
                }
    
                
    
                // Update the toggle switch to show it's enabled
    
                const toggle = this.shadowRoot.getElementById('content-scaling');
    
                if (toggle) {
    
                    toggle.checked = true;
    
                    }
                } else {
                   
                    this.contentScale = 100;
                    this.settings['content-scale'] = 100;
                    this.saveSettings();
                }
    
            }
    
            
    
            // Apply font size if it's not 100% AND was actually used
    
            if (this.fontSize !== 100) {
    
                const wasFontSizingUsed = localStorage.getItem('font-sizing-used') === 'true';
                
                if (wasFontSizingUsed) {
         
    
                this.updateFontSizeEnhanced();
    
                this.updateFontSizeDisplay(); // Update the display value immediately
    
                
    
                // Show font sizing controls if font size is not 100%
    
                const fontControls = this.shadowRoot.getElementById('font-sizing-controls');
    
                if (fontControls) {
    
                    fontControls.style.display = 'block';
    
                }
    
                
    
                // Update the toggle switch to show it's enabled
    
                const fontToggle = this.shadowRoot.getElementById('font-sizing');
    
                if (fontToggle) {
    
                    fontToggle.checked = true;
    
                    }
                } else {
                   
                    this.fontSize = 100;
                    this.settings['font-size'] = 100;
                    this.saveSettings();
                }
    
                
    
                // Update the display with a small delay to ensure Shadow DOM is ready
    
                setTimeout(() => {
    
                    this.updateFontSizeDisplay();
    
                }, 50);
    
            }
    
            
    
            // Apply line height if it's not 100% AND was actually used
    
            if (this.lineHeight !== 100) {
    
                const wasLineHeightUsed = localStorage.getItem('line-height-used') === 'true';
                
                if (wasLineHeightUsed) {
           
    
                this.updateLineHeight();
    
                
    
                // Show line height controls if line height is not 100%
    
                const lineHeightControls = this.shadowRoot.getElementById('line-height-controls');
    
                if (lineHeightControls) {
    
                    lineHeightControls.style.display = 'block';
                    
                    // Bind events when controls are shown
                    this.bindLineHeightEvents();
                    this.bindLineHeightEventsDirect();
    
                }
    
                
    
                // Update the toggle switch to show it's enabled
    
                const lineHeightToggle = this.shadowRoot.getElementById('adjust-line-height');
    
                if (lineHeightToggle) {
    
                    lineHeightToggle.checked = true;
    
                    }
                } else {
                    // Persist the previously used custom line-height across pages
                    localStorage.setItem('line-height-used', 'true');
                }
    
                
    
                // Bind events to the line height buttons when controls are shown
    
                this.bindLineHeightEvents();
    
                
    
                // Update the display immediately and with a small delay to ensure Shadow DOM is ready
    
                this.updateLineHeightDisplay();
    
                setTimeout(() => {
    
                    this.updateLineHeightDisplay();
    
                }, 50);
    
            }
    
            
    
            // Apply letter spacing if it's not 100% AND was actually used
    
            if (this.letterSpacing !== 100) {
    
                const wasLetterSpacingUsed = localStorage.getItem('letter-spacing-used') === 'true';
                
                if (wasLetterSpacingUsed) {
               
    
                this.updateLetterSpacing();
    
                
    
                // Show letter spacing controls if letter spacing is not 100%
    
                const letterSpacingControls = this.shadowRoot.getElementById('letter-spacing-controls');
    
                if (letterSpacingControls) {
    
                    letterSpacingControls.style.display = 'block';
    
                }
    
                
    
                // Update the toggle switch to show it's enabled
    
                const letterSpacingToggle = this.shadowRoot.getElementById('adjust-letter-spacing');
    
                if (letterSpacingToggle) {
    
                    letterSpacingToggle.checked = true;
    
                    }
                } else {
                   
                    this.letterSpacing = 100;
                    this.settings['letter-spacing'] = 100;
                    this.saveSettings();
                }
    
                
    
                // Update the display with a small delay to ensure Shadow DOM is ready
    
                setTimeout(() => {
    
                    this.updateLetterSpacingDisplay();
    
                }, 50);
    
            }
    
            
    
            // Apply text color if it's set
    
            if (this.settings['text-color'] !== undefined && this.settings['text-color'] !== null) {
    
               
    
                this.applyTextColor(this.settings['text-color']);
    
                
    
                // Show color picker controls
    
                this.showTextColorPicker();
    
                
    
                // Update the toggle switch to show it's enabled
    
                const textColorToggle = this.shadowRoot.getElementById('adjust-text-colors');
    
                if (textColorToggle) {
    
                    textColorToggle.checked = true;
    
                }
    
            }
    
            
    
            // Apply title color if it's set
    
            if (this.settings['title-color'] !== undefined && this.settings['title-color'] !== null) {
    
    
                this.applyTitleColor(this.settings['title-color']);
    
                
    
                // Show color picker controls
    
                this.showTitleColorPicker();
    
                
    
                // Update the toggle switch to show it's enabled
    
                const titleColorToggle = this.shadowRoot.getElementById('adjust-title-colors');
    
                if (titleColorToggle) {
    
                    titleColorToggle.checked = true;
    
                }
    
            }
    
            
    
            // Apply background color if it's set
    
            if (this.settings['bg-color'] !== undefined && this.settings['bg-color'] !== null) {
    
               
    
                this.applyBackgroundColor(this.settings['bg-color']);
    
                
    
                // Show color picker controls
    
                this.showBackgroundColorPicker();
    
                
    
                // Update the toggle switch to show it's enabled
    
                const bgColorToggle = this.shadowRoot.getElementById('adjust-bg-colors');
    
                if (bgColorToggle) {
    
                    bgColorToggle.checked = true;
    
                }
    
            }
    
            
    
            // Initialize keyboard shortcuts if keyboard navigation is enabled
    
            if (this.settings['keyboard-nav']) {
    
              
    
                this.initKeyboardShortcuts();
    
            } else {
    
            
    
            }
    
            
    
            // Update widget appearance to sync with loaded settings
    
            this.updateWidgetAppearance();
    
        }
    
    
    
        // Add missing letter spacing control methods
    
        showLetterSpacingControls() {
    
       
    
            const controls = this.shadowRoot.getElementById('letter-spacing-controls');
    
            if (controls) {
    
                controls.style.display = 'block';
    
                
    
            } else {
    
                
    
            }
    
        }
    
    
    
        hideLetterSpacingControls() {
    
            const controls = this.shadowRoot.getElementById('letter-spacing-controls');
    
            if (controls) {
    
                controls.style.display = 'none';
    
          
    
            } else {
    
             
    
            }
    
        }
    
    
    
        // High Contrast Methods
    
        enableHighContrast() {
    
     
    
            document.body.classList.add('high-contrast');
    
            // Apply comprehensive high contrast styles that preserve positioning
            this.applyHighContrastStyles();
    
            // Start monitoring for dynamically added navbar elements
            this.observeNavbarChanges();
    
            
    
        }
    
    
    
        disableHighContrast() {
    
            document.body.classList.remove('high-contrast');
    
            // Remove high contrast styles
            this.removeHighContrastStyles();
    
            // Stop monitoring navbar changes
            this.stopObservingNavbarChanges();
    
           
    
        }
    
        // Apply comprehensive high contrast styles that preserve positioning
        applyHighContrastStyles() {
            // Remove any existing high contrast styles first
            this.removeHighContrastStyles();
    
            const style = document.createElement('style');
            style.id = 'accessbit-high-contrast-fix';
            style.textContent = `
                /* Simple High Contrast Mode - Only increase contrast, preserve everything else */
                /* CRITICAL: Apply filters ONLY to media inside main content areas - NEVER to nav/header or their ancestors */
                /* Dark/Light contrast work because they use color/background properties, NOT filters */
                /* Filters create stacking contexts that break sticky positioning - so we avoid them on nav ancestors */
                
                /* Apply filter ONLY to media elements inside main content areas (main, section, article) */
                /* These are guaranteed to not contain nav elements, preventing stacking context issues */
                body.high-contrast main img,
                body.high-contrast main video,
                body.high-contrast main picture,
                body.high-contrast main canvas,
                body.high-contrast main svg,
                body.high-contrast section img,
                body.high-contrast section video,
                body.high-contrast section picture,
                body.high-contrast section canvas,
                body.high-contrast section svg,
                body.high-contrast article img,
                body.high-contrast article video,
                body.high-contrast article picture,
                body.high-contrast article canvas,
                body.high-contrast article svg {
                    filter: contrast(1.1) brightness(1.05) !important;
                    -webkit-filter: contrast(1.1) brightness(1.05) !important;
                }
                
                /* CRITICAL: Ensure navigation elements and their children NEVER get filters */
                body.high-contrast nav,
                body.high-contrast nav *,
                body.high-contrast header,
                body.high-contrast header *,
                body.high-contrast .navbar,
                body.high-contrast .navbar *,
                body.high-contrast [role="navigation"],
                body.high-contrast [role="navigation"] *,
                body.high-contrast [class*="nav"],
                body.high-contrast [class*="nav"] *,
                body.high-contrast [class*="header"],
                body.high-contrast [class*="header"] *,
                body.high-contrast [class*="navbar"],
                body.high-contrast [class*="navbar"] *,
                body.high-contrast [data-sticky],
                body.high-contrast [data-sticky] *,
                body.high-contrast [data-fixed],
                body.high-contrast [data-fixed] *,
                body.high-contrast [style*="position: sticky"],
                body.high-contrast [style*="position: sticky"] *,
                body.high-contrast [style*="position:fixed"],
                body.high-contrast [style*="position:fixed"] *,
                body.high-contrast [style*="position: fixed"],
                body.high-contrast [style*="position: fixed"] * {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Preserve accessibility widget from contrast filters */
                body.high-contrast .accessbit-widget,
                body.high-contrast .accessbit-widget *,
                body.high-contrast .accessbit-widget-panel,
                body.high-contrast .accessbit-widget-panel *,
                body.high-contrast .accessbit-widget-icon,
                body.high-contrast .accessbit-widget-icon *,
                body.high-contrast #accessbit-widget,
                body.high-contrast #accessbit-widget *,
                body.high-contrast #accessbit-widget-panel,
                body.high-contrast #accessbit-widget-panel *,
                body.high-contrast #accessbit-widget-icon,
                body.high-contrast #accessbit-widget-icon *,
                body.high-contrast [data-ck-widget],
                body.high-contrast [data-ck-widget] *,
                body.high-contrast [class*="accessbit"],
                body.high-contrast [class*="accessbit"] * {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
            `;
    
            document.head.appendChild(style);
          
        }
    
        // Fix existing navbar elements that might have lost their positioning
        fixExistingNavbars() {
            // Find all potential navbar elements
            const navbarSelectors = [
                'nav', 'header', '.navbar', '.nav-bar', '.navigation', 
                '.header', '.top-bar', '.menu-bar', '.main-navigation',
                '.site-header', '.site-navigation', '.primary-menu',
                '.menu-primary', '.main-menu', '.mobile-nav', '.mobile-menu',
                '.mobile-header', '.responsive-nav', '.sticky-header',
                '.sticky-nav', '.sticky-top-bar'
            ];
    
            navbarSelectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    // Check if element has fixed or sticky positioning
                    const computedStyle = window.getComputedStyle(element);
                    const position = computedStyle.position;
                    
                    if (position === 'fixed' || position === 'sticky') {
                        // Ensure the element maintains its positioning
                        element.style.setProperty('position', position, 'important');
                        element.style.setProperty('z-index', '9999', 'important');
                        element.style.setProperty('filter', 'none', 'important');
                    }
                });
            });
        }
    
        // Remove high contrast styles
        removeHighContrastStyles() {
            const existingStyle = document.getElementById('accessbit-high-contrast-fix');
            if (existingStyle) {
                existingStyle.remove();

            }
        }
    
        // Monitor for dynamically added navbar elements
        observeNavbarChanges() {
            if (this.navbarObserver) {
                this.navbarObserver.disconnect();
            }
    
            this.navbarObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // Check if the added node or its children are navbar elements
                                const navbarElements = node.querySelectorAll ? 
                                    node.querySelectorAll('nav, header, .navbar, .nav-bar, .navigation, .header, .top-bar, .menu-bar') :
                                    [];
                                
                                // Also check if the node itself is a navbar element
                                const isNavbarElement = node.matches && node.matches('nav, header, .navbar, .nav-bar, .navigation, .header, .top-bar, .menu-bar');
                                
                                if (isNavbarElement || navbarElements.length > 0) {
                                    // Apply fixes to newly added navbar elements
                                    setTimeout(() => {
                                        this.fixExistingNavbars();
                                    }, 100);
                                }
                            }
                        });
                    }
                });
            });
    
            // Start observing
            this.navbarObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
            
         
        }
    
        stopObservingNavbarChanges() {
            if (this.navbarObserver) {
                this.navbarObserver.disconnect();
                this.navbarObserver = null;

            }
        }
    
        // High Saturation Methods
    
        enableHighSaturation() {
    
            document.body.classList.add('high-saturation');

            // Apply high saturation styles that preserve positioning
            this.applyHighSaturationStyles();
    
           
    
        }
    
    
    
        disableHighSaturation() {
    
            document.body.classList.remove('high-saturation');

            // Remove high saturation styles
            this.removeHighSaturationStyles();
    

        }

        // Low Saturation Methods

        enableLowSaturation() {
            this.settings['low-saturation'] = true;
            document.body.classList.add('low-saturation');
            
            // Apply low saturation styles that preserve positioning
            this.applyLowSaturationStyles();
            
            this.saveSettings();
        }
    
        // Fix existing navbar elements that might have lost their positioning
        fixExistingNavbars() {
            // Find all potential navbar elements
            const navbarSelectors = [
                'nav', 'header', '.navbar', '.nav-bar', '.navigation', 
                '.header', '.top-bar', '.menu-bar', '.main-navigation',
                '.site-header', '.site-navigation', '.primary-menu',
                '.menu-primary', '.main-menu', '.mobile-nav', '.mobile-menu',
                '.mobile-header', '.responsive-nav', '.sticky-header',
                '.sticky-nav', '.sticky-top-bar'
            ];
    
            navbarSelectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    // Check if element has fixed or sticky positioning
                    const computedStyle = window.getComputedStyle(element);
                    const position = computedStyle.position;
                    
                    if (position === 'fixed' || position === 'sticky') {
                        // Ensure the element maintains its positioning
                        element.style.setProperty('position', position, 'important');
                        element.style.setProperty('z-index', '9999', 'important');
                        element.style.setProperty('filter', 'none', 'important');
                        element.style.setProperty('-webkit-filter', 'none', 'important');
                        element.style.setProperty('transform', 'none', 'important');
                        element.style.setProperty('will-change', 'auto', 'important');
                        
                        // Apply high contrast colors
                        element.style.setProperty('background-color', '#000000', 'important');
                        element.style.setProperty('color', '#ffffff', 'important');
                        element.style.setProperty('border-color', '#ffffff', 'important');
                        
                     
                    }
                });
            });
    
            // Also check for elements with inline styles that might be affected
            const elementsWithInlinePosition = document.querySelectorAll('[style*="position: fixed"], [style*="position:fixed"], [style*="position: sticky"], [style*="position:sticky"]');
            elementsWithInlinePosition.forEach(element => {
                element.style.setProperty('filter', 'none', 'important');
                element.style.setProperty('-webkit-filter', 'none', 'important');
                element.style.setProperty('transform', 'none', 'important');
                element.style.setProperty('will-change', 'auto', 'important');

            });
        }
    
        // Remove high contrast styles
        removeHighContrastStyles() {
            const existingStyle = document.getElementById('accessbit-high-contrast-fix');
            if (existingStyle) {
                existingStyle.remove();
              
            }
        }
    
        // Monitor for dynamically added navbar elements
        observeNavbarChanges() {
            if (this.navbarObserver) {
                this.navbarObserver.disconnect();
            }
    
            this.navbarObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // Check if the added node or its children are navbar elements
                                const navbarElements = node.querySelectorAll ? 
                                    node.querySelectorAll('nav, header, .navbar, .nav-bar, .navigation, .header, .top-bar, .menu-bar') :
                                    [];
                                
                                // Also check if the node itself is a navbar element
                                const isNavbarElement = node.matches && node.matches('nav, header, .navbar, .nav-bar, .navigation, .header, .top-bar, .menu-bar');
                                
                                if (isNavbarElement || navbarElements.length > 0) {
                                    // Apply fixes to newly added navbar elements
                                    setTimeout(() => {
                                        this.fixExistingNavbars();
                                    }, 100);
                                }
                            }
                        });
                    }
                });
            });
    
            // Start observing
            this.navbarObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
    
           
        }
    
        // Stop monitoring navbar changes
        stopObservingNavbarChanges() {
            // Find all potential navbar elements
            const navbarSelectors = [
                'nav', 'header', '.navbar', '.nav-bar', '.navigation', 
                '.header', '.top-bar', '.menu-bar', '.main-navigation',
                '.site-header', '.site-navigation', '.primary-menu',
                '.menu-primary', '.main-menu', '.mobile-nav', '.mobile-menu',
                '.mobile-header', '.responsive-nav', '.sticky-header',
                '.sticky-nav', '.sticky-top-bar'
            ];
    
            navbarSelectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    // Check if element has fixed or sticky positioning
                    const computedStyle = window.getComputedStyle(element);
                    const position = computedStyle.position;
                    
                    if (position === 'fixed' || position === 'sticky') {
                        // Ensure the element maintains its positioning
                        element.style.setProperty('position', position, 'important');
                        element.style.setProperty('z-index', '9999', 'important');
                        element.style.setProperty('filter', 'none', 'important');
                        element.style.setProperty('-webkit-filter', 'none', 'important');
                        element.style.setProperty('transform', 'none', 'important');
                        element.style.setProperty('will-change', 'auto', 'important');
                        
                        // Apply high contrast colors
                        element.style.setProperty('background-color', '#000000', 'important');
                        element.style.setProperty('color', '#ffffff', 'important');
                        element.style.setProperty('border-color', '#ffffff', 'important');
                        
                     
                    }
                });
            });
    
            // Also check for elements with inline styles that might be affected
            const elementsWithInlinePosition = document.querySelectorAll('[style*="position: fixed"], [style*="position:fixed"], [style*="position: sticky"], [style*="position:sticky"]');
            elementsWithInlinePosition.forEach(element => {
                element.style.setProperty('filter', 'none', 'important');
                element.style.setProperty('-webkit-filter', 'none', 'important');
                element.style.setProperty('transform', 'none', 'important');
                element.style.setProperty('will-change', 'auto', 'important');

            });
        }
    
    
    
        // High Saturation Methods
    
        enableHighSaturation() {
    
            document.body.classList.add('high-saturation');

            // Apply high saturation styles that preserve positioning
            this.applyHighSaturationStyles();
    
    
        }
    
    
    
        disableHighSaturation() {
    
            document.body.classList.remove('high-saturation');

            // Remove high saturation styles
            this.removeHighSaturationStyles();
    
    
        }
    
        // Low Saturation Methods

        enableLowSaturation() {

            document.body.classList.add('low-saturation');

            // Apply low saturation styles that preserve positioning
            this.applyLowSaturationStyles();

           

        }

        disableLowSaturation() {

            document.body.classList.remove('low-saturation');

            // Remove low saturation styles
            this.removeLowSaturationStyles();

           

        }

        // High Saturation CSS Methods
        applyHighSaturationStyles() {
            // Remove any existing high saturation styles first
            this.removeHighSaturationStyles();

            const style = document.createElement('style');
            style.id = 'accessbit-high-saturation-css';
            style.textContent = `
                /* Simple High Saturation Mode - Only increase saturation, preserve everything else */
                /* CRITICAL: Apply filters ONLY to media inside main content areas - NEVER to nav/header or their ancestors */
                /* Dark/Light contrast work because they use color/background properties, NOT filters */
                /* Filters create stacking contexts that break sticky positioning - so we avoid them on nav ancestors */
                
                /* Apply filter ONLY to media elements inside main content areas (main, section, article) */
                /* These are guaranteed to not contain nav elements, preventing stacking context issues */
                body.high-saturation main img,
                body.high-saturation main video,
                body.high-saturation main picture,
                body.high-saturation main canvas,
                body.high-saturation main svg,
                body.high-saturation section img,
                body.high-saturation section video,
                body.high-saturation section picture,
                body.high-saturation section canvas,
                body.high-saturation section svg,
                body.high-saturation article img,
                body.high-saturation article video,
                body.high-saturation article picture,
                body.high-saturation article canvas,
                body.high-saturation article svg {
                    filter: saturate(1.2) !important;
                    -webkit-filter: saturate(1.2) !important;
                }
                
                /* CRITICAL: Ensure navigation elements and their children NEVER get filters */
                body.high-saturation nav,
                body.high-saturation nav *,
                body.high-saturation header,
                body.high-saturation header *,
                body.high-saturation .navbar,
                body.high-saturation .navbar *,
                body.high-saturation [role="navigation"],
                body.high-saturation [role="navigation"] *,
                body.high-saturation [class*="nav"],
                body.high-saturation [class*="nav"] *,
                body.high-saturation [class*="header"],
                body.high-saturation [class*="header"] *,
                body.high-saturation [class*="navbar"],
                body.high-saturation [class*="navbar"] *,
                body.high-saturation [data-sticky],
                body.high-saturation [data-sticky] *,
                body.high-saturation [data-fixed],
                body.high-saturation [data-fixed] *,
                body.high-saturation [style*="position: sticky"],
                body.high-saturation [style*="position: sticky"] *,
                body.high-saturation [style*="position:fixed"],
                body.high-saturation [style*="position:fixed"] *,
                body.high-saturation [style*="position: fixed"],
                body.high-saturation [style*="position: fixed"] * {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Preserve accessibility widget from saturation filters */
                body.high-saturation .accessbit-widget,
                body.high-saturation .accessbit-widget *,
                body.high-saturation .accessbit-widget-panel,
                body.high-saturation .accessbit-widget-panel *,
                body.high-saturation .accessbit-widget-icon,
                body.high-saturation .accessbit-widget-icon *,
                body.high-saturation #accessbit-widget,
                body.high-saturation #accessbit-widget *,
                body.high-saturation #accessbit-widget-panel,
                body.high-saturation #accessbit-widget-panel *,
                body.high-saturation #accessbit-widget-icon,
                body.high-saturation #accessbit-widget-icon *,
                body.high-saturation [data-ck-widget],
                body.high-saturation [data-ck-widget] *,
                body.high-saturation [class*="accessbit"],
                body.high-saturation [class*="accessbit"] * {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
            `;
            document.head.appendChild(style);
           
        }

        removeHighSaturationStyles() {
            const existingStyle = document.getElementById('accessbit-high-saturation-css');
            if (existingStyle) {
                existingStyle.remove();
            }
        }

        // Low Saturation CSS Methods
        applyLowSaturationStyles() {
            // Remove any existing low saturation styles first
            this.removeLowSaturationStyles();

            const style = document.createElement('style');
            style.id = 'accessbit-low-saturation-css';
            style.textContent = `
                /* Low Saturation Mode - Simple filter overlay approach */
                body.low-saturation {
                    filter: saturate(0.6) !important;
                    -webkit-filter: saturate(0.6) !important;
                }
                
                /* CRITICAL: Exclude navigation elements from filter to preserve sticky/fixed positioning */
                body.low-saturation nav,
                body.low-saturation header,
                body.low-saturation .navbar,
                body.low-saturation [role="navigation"],
                body.low-saturation [class*="nav"],
                body.low-saturation [class*="header"],
                body.low-saturation [class*="navbar"],
                body.low-saturation [data-sticky],
                body.low-saturation [data-fixed],
                body.low-saturation [style*="position: sticky"],
                body.low-saturation [style*="position:fixed"],
                body.low-saturation [style*="position: fixed"] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Preserve accessibility widget from low saturation filters */
                body.low-saturation .accessbit-widget,
                body.low-saturation .accessbit-widget-panel,
                body.low-saturation .accessbit-widget-icon,
                body.low-saturation #accessbit-widget,
                body.low-saturation #accessbit-widget-panel,
                body.low-saturation #accessbit-widget-icon,
                body.low-saturation [data-ck-widget],
                body.low-saturation [class*="accessbit"] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
            `;
            document.head.appendChild(style);
        }

        removeLowSaturationStyles() {
            const existingStyle = document.getElementById('accessbit-low-saturation-css');
            if (existingStyle) {
                existingStyle.remove();
            }
        }
    
    
    
        // Monochrome Methods
    
        enableMonochrome() {
    
            this.settings['monochrome'] = true;
    
            document.body.classList.add('monochrome');
    
            
    
            // Apply grayscale filter to all page content
    
            const style = document.createElement('style');
    
            style.id = 'accessbit-monochrome-styles';
    
            style.textContent = `
                /* Monochrome effect - Simple filter overlay approach */
                body.monochrome {
                    filter: grayscale(100%) !important;
                    -webkit-filter: grayscale(100%) !important;
                }
                
                /* CRITICAL: Exclude navigation elements from filter to preserve sticky/fixed positioning */
                body.monochrome nav,
                body.monochrome header,
                body.monochrome .navbar,
                body.monochrome [role="navigation"],
                body.monochrome [class*="nav"],
                body.monochrome [class*="header"],
                body.monochrome [class*="navbar"],
                body.monochrome [data-sticky],
                body.monochrome [data-fixed],
                body.monochrome [style*="position: sticky"],
                body.monochrome [style*="position:fixed"],
                body.monochrome [style*="position: fixed"] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Preserve accessibility widget from monochrome filters */
                body.monochrome .accessbit-widget,
                body.monochrome .accessbit-widget-panel,
                body.monochrome .accessbit-widget-icon,
                body.monochrome #accessbit-widget,
                body.monochrome #accessbit-widget-panel,
                body.monochrome #accessbit-widget-icon,
                body.monochrome [data-ck-widget],
                body.monochrome [class*="accessbit"] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
            `;
    
            document.head.appendChild(style);
    
            
    
            this.saveSettings();
    
    
        }
    
    
    
        disableMonochrome() {
    
            this.settings['monochrome'] = false;
    
            document.body.classList.remove('monochrome');
    
            
    
            // Remove monochrome styles
    
            const style = document.getElementById('accessbit-monochrome-styles');
    
            if (style) {
    
                style.remove();
    
            }
    
            
    
            this.saveSettings();
    
 
    
        }
    
    
    
        // Dark Contrast Methods
    
        enableDarkContrast() {
    
          
    
            // Disable light contrast if active (mutually exclusive)
            if (this.settings['light-contrast']) {
                this.settings['light-contrast'] = false;
                document.body.classList.remove('light-contrast');
                this.removeLightContrastCSS();
                this.stopLightContrastMonitoring();
                // Update toggle switch
                this.updateToggleSwitch('light-contrast', false);
            }

            // Add dark contrast class
            document.body.classList.add('dark-contrast');
            this.settings['dark-contrast'] = true;

            // Inject dark contrast CSS
            this.injectDarkContrastCSS();
            
            // Save settings
            this.saveSettings();
    
    
        }
    
    
    
        disableDarkContrast() {
    
            document.body.classList.remove('dark-contrast');
            this.settings['dark-contrast'] = false;

            // Remove dark contrast CSS
            this.removeDarkContrastCSS();
            
            // Save settings
            this.saveSettings();
    
           
    
        }
    
    
    
        // Light Contrast Methods
    
        enableLightContrast() {
    
    
            // Disable dark contrast if active (mutually exclusive)
            if (this.settings['dark-contrast']) {
                this.settings['dark-contrast'] = false;
                document.body.classList.remove('dark-contrast');
                this.removeDarkContrastCSS();
                // Update toggle switch
                this.updateToggleSwitch('dark-contrast', false);
            }

            // Add light contrast class
            document.body.classList.add('light-contrast');
            this.settings['light-contrast'] = true;

            // Inject light contrast CSS
            this.injectLightContrastCSS();
            
            // Start monitoring for dynamically added dark elements
            this.startLightContrastMonitoring();
            
            // Save settings
            this.saveSettings();
    
      
    
        }
    
    
    
        disableLightContrast() {
    
            document.body.classList.remove('light-contrast');
            this.settings['light-contrast'] = false;

            // Remove light contrast CSS
            this.removeLightContrastCSS();
            
            // Stop monitoring for dynamically added elements
            this.stopLightContrastMonitoring();
            
            // Save settings
            this.saveSettings();
    
            
            // Refresh the page to ensure all elements return to their original state
            setTimeout(() => {
                window.location.reload();
            }, 100);
    
        }
    
        // Dark Contrast CSS Injection
        injectDarkContrastCSS() {
            // Remove any existing dark contrast CSS first
            this.removeDarkContrastCSS();

            const style = document.createElement('style');
            style.id = 'accessbit-dark-contrast-css';
            style.textContent = `
                /* Contrast Modes */
                body.dark-contrast {
                    background: #000000 !important;
                    color: #ffffff !important;
                }

                /* Apply dark contrast to text elements only - no background changes */
                body.dark-contrast p,
                body.dark-contrast h1,
                body.dark-contrast h2,
                body.dark-contrast h3,
                body.dark-contrast h4,
                body.dark-contrast h5,
                body.dark-contrast h6,
                body.dark-contrast span,
                body.dark-contrast li,
                body.dark-contrast td,
                body.dark-contrast th,
                body.dark-contrast label,
                body.dark-contrast small,
                body.dark-contrast em,
                body.dark-contrast strong,
                body.dark-contrast i,
                body.dark-contrast b,
                body.dark-contrast a {
                    color: #ffffff !important;
                }

                /* Apply dark background to main content areas only */
                body.dark-contrast main,
                body.dark-contrast section,
                body.dark-contrast article {
                    background: #000000 !important;
                }

                /* Exclude layout containers and Webflow classes from dark backgrounds */
                body.dark-contrast .container,
                body.dark-contrast .wrapper,
                body.dark-contrast .content,
                body.dark-contrast .page-wrapper,
                body.dark-contrast .smooth-content,
                body.dark-contrast .smooth-wrapper,
                body.dark-contrast .padding-global,
                body.dark-contrast .container-large,
                body.dark-contrast .section-hero,
                body.dark-contrast .portfolio-hero,
                body.dark-contrast .nav_component,
                body.dark-contrast .nav_container,
                body.dark-contrast .footer,
                body.dark-contrast .header,
                body.dark-contrast .navbar,
                body.dark-contrast .navigation,
                body.dark-contrast .w-nav,
                body.dark-contrast .w-dropdown,
                body.dark-contrast .w-button,
                body.dark-contrast .w-embed,
                body.dark-contrast .w-background-video,
                body.dark-contrast .w-slider,
                body.dark-contrast .w-tabs,
                body.dark-contrast .w-accordion,
                body.dark-contrast .w-lightbox,
                body.dark-contrast .w-richtext,
                body.dark-contrast .w-form,
                body.dark-contrast .w-input,
                body.dark-contrast .w-select,
                body.dark-contrast .w-textarea,
                body.dark-contrast .w-checkbox,
                body.dark-contrast .w-radio {
                    background: inherit !important;
                    color: inherit !important;
                }

                /* Prevent all divs from getting black backgrounds by default */
                body.dark-contrast div {
                    background: transparent !important;
                }

                /* Only apply dark backgrounds to specific content divs */
                body.dark-contrast div[class*="text"],
                body.dark-contrast div[class*="content"],
                body.dark-contrast div[class*="description"],
                body.dark-contrast div[class*="paragraph"],
                body.dark-contrast div[class*="heading"],
                body.dark-contrast div[class*="title"],
                body.dark-contrast div[class*="subtitle"],
                body.dark-contrast div[class*="caption"],
                body.dark-contrast div[class*="label"] {
                    background: #000000 !important;
                    color: #ffffff !important;
                }

                /* Style ONLY actual service cards and specific content boxes in dark contrast */
                body.dark-contrast .service-card,
                body.dark-contrast .color-box,
                body.dark-contrast .test-block {
                    background: #000000 !important;
                    border: 2px solid #ffffff !important;
                    color: #ffffff !important;
                }

                /* Ensure text inside specific cards is white */
                body.dark-contrast .service-card *,
                body.dark-contrast .color-box *,
                body.dark-contrast .test-block * {
                    background: #000000 !important;
                    color: #ffffff !important;
                }

                /* Style form elements for dark contrast */
                body.dark-contrast input,
                body.dark-contrast textarea,
                body.dark-contrast select,
                body.dark-contrast button,
                body.dark-contrast .btn,
                body.dark-contrast .button,
                body.dark-contrast .form-control {
                    background: #000000 !important;
                    color: #ffffff !important;
                    border: 1px solid #ffffff !important;
                }

                /* Style form placeholders for dark contrast */
                body.dark-contrast input::placeholder,
                body.dark-contrast textarea::placeholder {
                    color: #cccccc !important;
                }

                /* Style form groups and containers for dark contrast */
                body.dark-contrast .form-group,
                body.dark-contrast .contact-form,
                body.dark-contrast .test-form {
                    background: #000000 !important;
                    color: #ffffff !important;
                }

                /* Exclude UI elements from dark contrast text changes */
                body.dark-contrast header,
                body.dark-contrast nav,
                body.dark-contrast .header,
                body.dark-contrast .navbar,
                body.dark-contrast .navigation,
                body.dark-contrast .logo,
                body.dark-contrast .menu,
                body.dark-contrast .nav-menu,
                body.dark-contrast .card,
                body.dark-contrast .modal,
                body.dark-contrast .dropdown,
                body.dark-contrast .tooltip,
                body.dark-contrast .badge,
                body.dark-contrast .alert { color: inherit !important; background: inherit !important; }
                
                /* Exclude card flip animations and their content */
                body.dark-contrast [class*="flip"],
                body.dark-contrast [class*="card-flip"],
                body.dark-contrast [class*="flip-card"],
                body.dark-contrast [class*="flip-container"],
                body.dark-contrast [class*="flip-inner"],
                body.dark-contrast [class*="flip-front"],
                body.dark-contrast [class*="flip-back"],
                body.dark-contrast [class*="flip-hover"],
                body.dark-contrast [class*="card-hover"],
                body.dark-contrast [class*="hover-flip"],
                body.dark-contrast [class*="rotate"],
                body.dark-contrast [class*="transform"],
                body.dark-contrast [class*="perspective"],
                body.dark-contrast [class*="3d"],
                body.dark-contrast [class*="three-d"],
                body.dark-contrast .logo,
                body.dark-contrast [class*="logo"],
                body.dark-contrast .brand,
                body.dark-contrast [class*="brand"],
                body.dark-contrast .emoji,
                body.dark-contrast [class*="emoji"],
                body.dark-contrast .symbol,
                body.dark-contrast [class*="symbol"],
                body.dark-contrast .glyph,
                body.dark-contrast [class*="glyph"],
                body.dark-contrast .pictogram,
                body.dark-contrast [class*="pictogram"],
                body.dark-contrast .decoration,
                body.dark-contrast [class*="decoration"],
                body.dark-contrast .ornament,
                body.dark-contrast [class*="ornament"],
                body.dark-contrast .pattern,
                body.dark-contrast [class*="pattern"],
                body.dark-contrast .texture,
                body.dark-contrast [class*="texture"],
                body.dark-contrast .overlay,
                body.dark-contrast [class*="overlay"],
                body.dark-contrast .background,
                body.dark-contrast [class*="background"],
                body.dark-contrast .hero,
                body.dark-contrast [class*="hero"],
                body.dark-contrast .banner,
                body.dark-contrast [class*="banner"],
                body.dark-contrast .visual,
                body.dark-contrast [class*="visual"],
                body.dark-contrast .graphic,
                body.dark-contrast [class*="graphic"],
                body.dark-contrast .illustration,
                body.dark-contrast [class*="illustration"],
                body.dark-contrast .photo,
                body.dark-contrast [class*="photo"],
                body.dark-contrast .picture,
                body.dark-contrast [class*="picture"],
                body.dark-contrast .media,
                body.dark-contrast [class*="media"],
                body.dark-contrast .asset,
                body.dark-contrast [class*="asset"],
                body.dark-contrast .element,
                body.dark-contrast [class*="element"],
                body.dark-contrast .component,
                body.dark-contrast [class*="component"],
                body.dark-contrast .widget,
                body.dark-contrast [class*="widget"],
                body.dark-contrast .module,
                body.dark-contrast [class*="module"],
                body.dark-contrast .block,
                body.dark-contrast [class*="block"],
                body.dark-contrast .section,
                body.dark-contrast [class*="section"],
                body.dark-contrast .area,
                body.dark-contrast [class*="area"],
                body.dark-contrast .zone,
                body.dark-contrast [class*="zone"],
                body.dark-contrast .region,
                body.dark-contrast [class*="region"],
                body.dark-contrast .space,
                body.dark-contrast [class*="space"],
                body.dark-contrast .container,
                body.dark-contrast [class*="container"],
                body.dark-contrast .wrapper,
                body.dark-contrast [class*="wrapper"],
                body.dark-contrast .holder,
                body.dark-contrast [class*="holder"],
                body.dark-contrast .box,
                body.dark-contrast [class*="box"],
                body.dark-contrast .panel,
                body.dark-contrast [class*="panel"],
                body.dark-contrast .frame,
                body.dark-contrast [class*="frame"],
                body.dark-contrast .border,
                body.dark-contrast [class*="border"],
                body.dark-contrast .outline,
                body.dark-contrast [class*="outline"],
                body.dark-contrast .stroke,
                body.dark-contrast [class*="stroke"],
                body.dark-contrast .line,
                body.dark-contrast [class*="line"],
                body.dark-contrast .divider,
                body.dark-contrast [class*="divider"],
                body.dark-contrast .separator,
                body.dark-contrast [class*="separator"],
                body.dark-contrast .spacer,
                body.dark-contrast [class*="spacer"],
                body.dark-contrast .gap,
                body.dark-contrast [class*="gap"],
                body.dark-contrast .margin,
                body.dark-contrast [class*="margin"],
                body.dark-contrast .padding,
                body.dark-contrast [class*="padding"],
                body.dark-contrast .spacing,
                body.dark-contrast [class*="spacing"],
                body.dark-contrast .layout,
                body.dark-contrast [class*="layout"],
                body.dark-contrast .grid,
                body.dark-contrast [class*="grid"],
                body.dark-contrast .flex,
                body.dark-contrast [class*="flex"],
                body.dark-contrast .row,
                body.dark-contrast [class*="row"],
                body.dark-contrast .col,
                body.dark-contrast [class*="col"],
                body.dark-contrast .column,
                body.dark-contrast [class*="column"],
                body.dark-contrast .cell,
                body.dark-contrast [class*="cell"],
                body.dark-contrast .item,
                body.dark-contrast [class*="item"],
                body.dark-contrast .entry,
                body.dark-contrast [class*="entry"],
                body.dark-contrast .node,
                body.dark-contrast [class*="node"],
                body.dark-contrast .leaf,
                body.dark-contrast [class*="leaf"],
                body.dark-contrast .branch,
                body.dark-contrast [class*="branch"],
                body.dark-contrast .root,
                body.dark-contrast [class*="root"],
                body.dark-contrast .parent,
                body.dark-contrast [class*="parent"],
                body.dark-contrast .child,
                body.dark-contrast [class*="child"],
                body.dark-contrast .sibling,
                body.dark-contrast [class*="sibling"],
                body.dark-contrast .ancestor,
                body.dark-contrast [class*="ancestor"],
                body.dark-contrast .descendant,
                body.dark-contrast [class*="descendant"],
                body.dark-contrast .relative,
                body.dark-contrast [class*="relative"],
                body.dark-contrast .absolute,
                body.dark-contrast [class*="absolute"],
                body.dark-contrast .fixed,
                body.dark-contrast [class*="fixed"],
                body.dark-contrast .sticky,
                body.dark-contrast [class*="sticky"],
                body.dark-contrast .static,
                body.dark-contrast [class*="static"],
                body.dark-contrast .relative,
                body.dark-contrast [class*="relative"],
                body.dark-contrast .absolute,
                body.dark-contrast [class*="absolute"],
                body.dark-contrast .fixed,
                body.dark-contrast [class*="fixed"],
                body.dark-contrast .sticky,
                body.dark-contrast [class*="sticky"],
                body.dark-contrast .static,
                body.dark-contrast [class*="static"] {
                    color: inherit !important;
                    background: inherit !important;
                }
                
                body.dark-contrast .modal,
                body.dark-contrast .dropdown,
                body.dark-contrast .tooltip,
                body.dark-contrast .badge,
                body.dark-contrast .alert {
                    color: inherit !important;
                    background: inherit !important;
                }
                
                /* Special styling for card flip animations to ensure text visibility */
                body.dark-contrast [class*="flip"] *,
                body.dark-contrast [class*="card-flip"] *,
                body.dark-contrast [class*="flip-card"] *,
                body.dark-contrast [class*="flip-container"] *,
                body.dark-contrast [class*="flip-inner"] *,
                body.dark-contrast [class*="flip-front"] *,
                body.dark-contrast [class*="flip-back"] *,
                body.dark-contrast [class*="flip-hover"] *,
                body.dark-contrast [class*="card-hover"] *,
                body.dark-contrast [class*="hover-flip"] * {
                    color: #ffffff !important;
                    background: transparent !important;
                }
                
                /* Ensure card flip containers maintain their original styling */
                body.dark-contrast [class*="flip"],
                body.dark-contrast [class*="card-flip"],
                body.dark-contrast [class*="flip-card"],
                body.dark-contrast [class*="flip-container"],
                body.dark-contrast [class*="flip-inner"] {
                    background: inherit !important;
                    color: inherit !important;
                }

                /* Style accessibility widget for dark contrast */
                .dark-contrast .accessbit-widget-panel,
                .dark-contrast .accessbit-widget-icon,
                .dark-contrast #accessbit-widget-panel,
                .dark-contrast #accessbit-widget-icon {
                    background: #1a1a1a !important;
                    color: #ffffff !important;
                    border: 2px solid #ffffff !important;
                }

                .dark-contrast .accessbit-widget-panel *,
                .dark-contrast .accessbit-widget-icon *,
                .dark-contrast #accessbit-widget-panel *,
                .dark-contrast #accessbit-widget-icon * {
                    background: inherit !important;
                    color: inherit !important;
                }

                /* Override text color for accessibility widget elements */
                .dark-contrast .accessbit-widget-panel p,
                .dark-contrast .accessbit-widget-panel h1,
                .dark-contrast .accessbit-widget-panel h2,
                .dark-contrast .accessbit-widget-panel h3,
                .dark-contrast .accessbit-widget-panel h4,
                .dark-contrast .accessbit-widget-panel h5,
                .dark-contrast .accessbit-widget-panel h6,
                .dark-contrast .accessbit-widget-panel span,
                .dark-contrast .accessbit-widget-panel div,
                .dark-contrast .accessbit-widget-panel li,
                .dark-contrast .accessbit-widget-panel td,
                .dark-contrast .accessbit-widget-panel th,
                .dark-contrast .accessbit-widget-panel label,
                .dark-contrast .accessbit-widget-panel small,
                .dark-contrast .accessbit-widget-panel em,
                .dark-contrast .accessbit-widget-panel strong,
                .dark-contrast .accessbit-widget-panel i,
                .dark-contrast .accessbit-widget-panel b,
                .dark-contrast .accessbit-widget-panel a {
                    color: #ffffff !important;
                }

                /* Style accessibility panel header for dark contrast */
                .dark-contrast .accessbit-widget-panel .panel-header {
                    background: #2a2a2a !important;
                    color: #ffffff !important;
                    border-bottom: 1px solid #ffffff !important;
                }

                /* Style accessibility panel buttons for dark contrast */
                .dark-contrast .accessbit-widget-panel .action-btn {
                    background: #2a2a2a !important;
                    color: #ffffff !important;
                    border: 1px solid #ffffff !important;
                }

                .dark-contrast .accessbit-widget-panel .action-btn:hover {
                    background: #3a3a3a !important;
                    color: #ffffff !important;
                }

                /* Style accessibility panel footer for dark contrast */
                .dark-contrast .accessbit-widget-panel .panel-footer {
                    background: #2a2a2a !important;
                    color: #ffffff !important;
                    border-top: 1px solid #ffffff !important;
                }

                /* Style toggle switches for dark contrast */
                .dark-contrast .accessbit-widget-panel .toggle-switch {
                    background: #2a2a2a !important;
                    border: 1px solid #ffffff !important;
                }

                .dark-contrast .accessbit-widget-panel .toggle-switch .slider {
                    background: #ffffff !important;
                }

                .dark-contrast .accessbit-widget-panel .toggle-switch input:checked + .slider {
                    background: #6366f1 !important;
                }

                /* Style profile items for dark contrast */
                .dark-contrast .accessbit-widget-panel .profile-item {
                    background: #2a2a2a !important;
                    color: #ffffff !important;
                    border: 1px solid #ffffff !important;
                    margin: 5px 0 !important;
                }

                .dark-contrast .accessbit-widget-panel .profile-item:hover {
                    background: #3a3a3a !important;
                }
            `;
            document.head.appendChild(style);
        }

        removeDarkContrastCSS() {
            const existingStyle = document.getElementById('accessbit-dark-contrast-css');
            if (existingStyle) {
                existingStyle.remove();
            }
        }

        // Light Contrast CSS Injection
        injectLightContrastCSS() {
            // Remove any existing light contrast CSS first
            this.removeLightContrastCSS();

            const style = document.createElement('style');
            style.id = 'accessbit-light-contrast-css';
            style.textContent = `
                body.light-contrast {
                    background: #ffffff !important;
                    color: #000000 !important;
                }

                /* Apply light contrast to all text elements - comprehensive coverage */
                body.light-contrast p,
                body.light-contrast h1,
                body.light-contrast h2,
                body.light-contrast h3,
                body.light-contrast h4,
                body.light-contrast h5,
                body.light-contrast h6,
                body.light-contrast span,
                body.light-contrast div,
                body.light-contrast li,
                body.light-contrast td,
                body.light-contrast th,
                body.light-contrast label,
                body.light-contrast small,
                body.light-contrast em,
                body.light-contrast strong,
                body.light-contrast i,
                body.light-contrast b,
                body.light-contrast a {
                    color: #000000 !important;
                }
                
                /* Comprehensive coverage for dynamically loaded dark elements */
                body.light-contrast *[style*="background-color: #000"],
                body.light-contrast *[style*="background-color:#000"],
                body.light-contrast *[style*="background-color: #000000"],
                body.light-contrast *[style*="background-color:#000000"],
                body.light-contrast *[style*="background: #000"],
                body.light-contrast *[style*="background:#000"],
                body.light-contrast *[style*="background: #000000"],
                body.light-contrast *[style*="background:#000000"],
                body.light-contrast *[style*="color: #000"],
                body.light-contrast *[style*="color:#000"],
                body.light-contrast *[style*="color: #000000"],
                body.light-contrast *[style*="color:#000000"] {
                    background: #ffffff !important;
                    color: #000000 !important;
                }
                
                /* Target common dark theme classes that might be added dynamically */
                body.light-contrast .dark,
                body.light-contrast .dark-theme,
                body.light-contrast .dark-mode,
                body.light-contrast .night-mode,
                body.light-contrast .black,
                body.light-contrast .bg-dark,
                body.light-contrast .bg-black,
                body.light-contrast [class*="dark"],
                body.light-contrast [class*="black"],
                body.light-contrast [class*="night"] {
                    background: #ffffff !important;
                    color: #000000 !important;
                }
                
                /* Target dynamically loaded content containers */
                body.light-contrast .content,
                body.light-contrast .container,
                body.light-contrast .wrapper,
                body.light-contrast .section,
                body.light-contrast .article,
                body.light-contrast .main,
                body.light-contrast .page,
                body.light-contrast .body,
                body.light-contrast .app,
                body.light-contrast .root {
                    background: #ffffff !important;
                }

                /* Apply light background to main content areas only */
                body.light-contrast main,
                body.light-contrast section,
                body.light-contrast article,
                body.light-contrast .content,
                body.light-contrast .container,
                body.light-contrast .wrapper {
                    background: #ffffff !important;
                }

                /* Style ONLY actual service cards and specific content boxes in light contrast */
                body.light-contrast .service-card,
                body.light-contrast .color-box,
                body.light-contrast .test-block {
                    background: #ffffff !important;
                    border: 2px solid #000000 !important;
                    color: #000000 !important;
                }

                /* Ensure text inside specific cards is black */
                body.light-contrast .service-card *,
                body.light-contrast .color-box *,
                body.light-contrast .test-block * {
                    color: #000000 !important;
                }

                /* Force all cards and elements with background colors to white */
                body.light-contrast .card,
                body.light-contrast .service-card,
                body.light-contrast .color-box,
                body.light-contrast .test-block,
                body.light-contrast .bg-blue,
                body.light-contrast .bg-red,
                body.light-contrast .bg-green,
                body.light-contrast .bg-yellow,
                body.light-contrast .bg-purple,
                body.light-contrast .bg-orange,
                body.light-contrast .bg-pink,
                body.light-contrast .bg-gray,
                body.light-contrast .bg-dark,
                body.light-contrast .bg-light,
                body.light-contrast [class*="bg-"],
                body.light-contrast [class*="background"],
                body.light-contrast [class*="color-"],
                body.light-contrast [style*="background-color"],
                body.light-contrast [style*="background:"] {
                    background: #ffffff !important;
                    color: #000000 !important;
                }

                /* Force all text inside cards to be black */
                body.light-contrast .card *,
                body.light-contrast .service-card *,
                body.light-contrast .color-box *,
                body.light-contrast .test-block *,
                body.light-contrast .bg-blue *,
                body.light-contrast .bg-red *,
                body.light-contrast .bg-green *,
                body.light-contrast .bg-yellow *,
                body.light-contrast .bg-purple *,
                body.light-contrast .bg-orange *,
                body.light-contrast .bg-pink *,
                body.light-contrast .bg-gray *,
                body.light-contrast .bg-dark *,
                body.light-contrast .bg-light *,
                body.light-contrast [class*="bg-"] *,
                body.light-contrast [class*="background"] *,
                body.light-contrast [class*="color-"] *,
                body.light-contrast [style*="background-color"] *,
                body.light-contrast [style*="background:"] * {
                    color: #000000 !important;
                }

                /* Exclude UI elements and accessibility widget from light contrast text changes */
                body.light-contrast header,
                body.light-contrast nav,
                body.light-contrast .header,
                body.light-contrast .navbar,
                body.light-contrast .navigation,
                body.light-contrast .logo,
                body.light-contrast [class*="logo"],
                body.light-contrast [id*="logo"],
                body.light-contrast [data-logo],
                body.light-contrast .menu,
                body.light-contrast .nav-menu,
                body.light-contrast button,
                body.light-contrast .button,
                body.light-contrast .btn,
                body.light-contrast input,
                body.light-contrast textarea,
                body.light-contrast select,
                body.light-contrast .form-control,
                body.light-contrast .modal,
                body.light-contrast .dropdown,
                body.light-contrast .tooltip,
                body.light-contrast .badge,
                body.light-contrast .alert,
                body.light-contrast .accessbit-widget-panel,
                body.light-contrast .accessbit-widget-icon,
                body.light-contrast #accessbit-widget-panel,
                body.light-contrast #accessbit-widget-icon,
                body.light-contrast #accessbit-widget-container,
                body.light-contrast .accessbit-widget-container {
                    color: inherit !important;
                    background: inherit !important;
                }
                
                /* CRITICAL: Preserve logo container backgrounds (like black boxes with white logos) */
                body.light-contrast .logo,
                body.light-contrast [class*="logo"],
                body.light-contrast [id*="logo"],
                body.light-contrast [data-logo],
                body.light-contrast div:has(.logo),
                body.light-contrast div:has([class*="logo"]),
                body.light-contrast div:has([id*="logo"]),
                body.light-contrast header .logo,
                body.light-contrast nav .logo,
                body.light-contrast .header .logo,
                body.light-contrast .navbar .logo {
                    background: inherit !important;
                    background-color: inherit !important;
                    background-image: inherit !important;
                }

                /* Completely exclude accessibility widget from light contrast effects */
                .light-contrast .accessbit-widget-panel,
                .light-contrast .accessbit-widget-icon,
                .light-contrast #accessbit-widget-panel,
                .light-contrast #accessbit-widget-icon,
                .light-contrast .accessbit-widget-panel *,
                .light-contrast .accessbit-widget-icon *,
                .light-contrast #accessbit-widget-panel *,
                .light-contrast #accessbit-widget-icon * {
                    filter: none !important;
                    -webkit-filter: none !important;
                    background: inherit !important;
                    color: inherit !important;
                    border: inherit !important;
                    box-shadow: inherit !important;
                }
                
                /* Ensure logos are visible on white backgrounds - add border/shadow for white logos */
                body.light-contrast .logo,
                body.light-contrast [class*="logo"],
                body.light-contrast [id*="logo"],
                body.light-contrast [data-logo],
                body.light-contrast img.logo,
                body.light-contrast svg.logo,
                body.light-contrast .logo img,
                body.light-contrast .logo svg,
                body.light-contrast [class*="logo"] img,
                body.light-contrast [class*="logo"] svg,
                body.light-contrast div[class*="logo"],
                body.light-contrast div[id*="logo"],
                body.light-contrast a[class*="logo"],
                body.light-contrast a[id*="logo"] {
                    /* Add a border to make white logos visible on white backgrounds */
                    border: 2px solid #000000 !important;
                    box-shadow: 0 0 4px rgba(0, 0, 0, 0.3) !important;
                    filter: none !important;
                    -webkit-filter: none !important;
                    background: inherit !important;
                }
                
                /* Preserve navigation images but ensure they're visible */
                body.light-contrast header img,
                body.light-contrast nav img,
                body.light-contrast .header img,
                body.light-contrast .navbar img,
                body.light-contrast [role="navigation"] img {
                    background: inherit !important;
                    filter: none !important;
                    -webkit-filter: none !important;
                    /* Add border for visibility if logo */
                    border: 2px solid #000000 !important;
                    box-shadow: 0 0 4px rgba(0, 0, 0, 0.3) !important;
                }
                
                /* Ensure images are visible on white backgrounds - add border/shadow for white images */
                body.light-contrast img:not(.logo):not([class*="logo"]):not([id*="logo"]),
                body.light-contrast picture:not([class*="logo"]):not([id*="logo"]),
                body.light-contrast [class*="image"]:not([class*="logo"]):not([id*="logo"]),
                body.light-contrast [class*="img"]:not([class*="logo"]):not([id*="logo"]),
                body.light-contrast [class*="photo"]:not([class*="logo"]):not([id*="logo"]),
                body.light-contrast [class*="picture"]:not([class*="logo"]):not([id*="logo"]) {
                    /* Add a subtle border to make white images visible on white backgrounds */
                    border: 1px solid #cccccc !important;
                    box-shadow: 0 0 2px rgba(0, 0, 0, 0.1) !important;
                }
                
                /* For images that might be completely white, add a stronger border */
                body.light-contrast img[src*="white"]:not(.logo):not([class*="logo"]):not([id*="logo"]),
                body.light-contrast img[src*="light"]:not(.logo):not([class*="logo"]):not([id*="logo"]),
                body.light-contrast img[class*="white"]:not(.logo):not([class*="logo"]):not([id*="logo"]),
                body.light-contrast img[class*="light"]:not(.logo):not([class*="logo"]):not([id*="logo"]) {
                    border: 2px solid #000000 !important;
                    box-shadow: 0 0 4px rgba(0, 0, 0, 0.3) !important;
                }
            `;
            document.head.appendChild(style);
        }

        removeLightContrastCSS() {
            const existingStyle = document.getElementById('accessbit-light-contrast-css');
            if (existingStyle) {
                existingStyle.remove();
            }
        }
        
        // Start monitoring for dynamically added dark elements
        startLightContrastMonitoring() {
            // Stop any existing observer
            this.stopLightContrastMonitoring();
            
            this.lightContrastObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                this.processNewElementForLightContrast(node);
                                
                                // Also check for nested elements
                                const nestedElements = node.querySelectorAll ? node.querySelectorAll('*') : [];
                                nestedElements.forEach(element => {
                                    this.processNewElementForLightContrast(element);
                                });
                            }
                        });
                    }
                    
                    // Also handle attribute changes that might add dark styling
                    if (mutation.type === 'attributes' && mutation.target.nodeType === Node.ELEMENT_NODE) {
                        this.processNewElementForLightContrast(mutation.target);
                    }
                });
            });
            
            // Start observing
            this.lightContrastObserver.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['style', 'class']
            });
            
            
        }
        
        // Stop monitoring for dynamically added elements
        stopLightContrastMonitoring() {
            if (this.lightContrastObserver) {
                this.lightContrastObserver.disconnect();
                this.lightContrastObserver = null;
               
            }
        }
        
        // Process new elements for light contrast
        processNewElementForLightContrast(element) {
            if (!element || !element.style) return;
            
            const computedStyle = window.getComputedStyle(element);
            const backgroundColor = computedStyle.backgroundColor;
            const color = computedStyle.color;
            
            // Check if element has dark background or dark text
            const isDarkBackground = backgroundColor.includes('rgb(0, 0, 0)') || 
                                   backgroundColor.includes('rgba(0, 0, 0') ||
                                   backgroundColor.includes('#000') ||
                                   backgroundColor.includes('#000000');
            
            const isDarkText = color.includes('rgb(0, 0, 0)') || 
                             color.includes('rgba(0, 0, 0') ||
                             color.includes('#000') ||
                             color.includes('#000000');
            
            // Apply light contrast to dark elements
            if (isDarkBackground || isDarkText) {
                element.style.setProperty('background-color', '#ffffff', 'important');
                element.style.setProperty('color', '#000000', 'important');
                
            }
            
            // Also check for dark theme classes
            const classList = element.className || '';
            if (classList.includes('dark') || classList.includes('black') || classList.includes('night')) {
                element.style.setProperty('background-color', '#ffffff', 'important');
                element.style.setProperty('color', '#000000', 'important');
              
            }
        }
    
    
    
        // Text Color Picker Methods
    
        showTextColorPicker() {
    
           
    
            
    
            // Remove existing color picker if any
    
            this.hideTextColorPicker();
    
            
    
            // Find the adjust-text-colors module in the panel
    
            const textColorsModule = this.shadowRoot.querySelector('#adjust-text-colors').closest('.profile-item');
    
            
    
            if (textColorsModule) {
    
                // Create color picker content
    
                const colorPicker = document.createElement('div');
    
                colorPicker.id = 'text-color-picker';
    
                colorPicker.className = 'color-picker-inline';
    
                // Clear container
                while (colorPicker.firstChild) {
                    colorPicker.removeChild(colorPicker.firstChild);
                }
                
                const content = document.createElement('div');
                content.className = 'color-picker-content';
                
                const h4 = document.createElement('h4');
                h4.textContent = 'Adjust Text Colors';
                content.appendChild(h4);
                
                const textColorOptions = document.createElement('div');
                textColorOptions.className = 'color-options';
                
                const textColors = [
                    { color: '#3b82f6', selected: false },
                    { color: '#8b5cf6', selected: true },
                    { color: '#ef4444', selected: false },
                    { color: '#f97316', selected: false },
                    { color: '#14b8a6', selected: false },
                    { color: '#84cc16', selected: false },
                    { color: '#ffffff', selected: false, border: true },
                    { color: '#000000', selected: false }
                ];
                
                textColors.forEach(colorData => {
                    const option = document.createElement('div');
                    option.className = 'color-option';
                    if (colorData.selected) {
                        option.classList.add('selected');
                    }
                    option.setAttribute('data-color', colorData.color);
                    option.style.backgroundColor = colorData.color;
                    if (colorData.border) {
                        option.style.border = '1px solid #ccc';
                    }
                    textColorOptions.appendChild(option);
                });
                
                content.appendChild(textColorOptions);
                
                const textCancelBtn = document.createElement('button');
                textCancelBtn.className = 'cancel-btn';
                textCancelBtn.textContent = 'Cancel';
                content.appendChild(textCancelBtn);
                
                colorPicker.appendChild(content);
    
                
    
                // Insert after the profile-info div, before the toggle switch
    
                const profileInfo = textColorsModule.querySelector('.profile-info');
    
                const toggleSwitch = textColorsModule.querySelector('.toggle-switch');
    
                textColorsModule.insertBefore(colorPicker, toggleSwitch);
    
                
    
                // Add event listeners to color options
    
                const textColorOptionElements = colorPicker.querySelectorAll('.color-option');
    
                textColorOptionElements.forEach(option => {
    
                    option.addEventListener('click', (e) => {
    
                        const color = e.target.dataset.color;
    
                        this.applyTextColor(color);
    
                        
    
                        // Update selected state
    
                        textColorOptionElements.forEach(opt => opt.classList.remove('selected'));
    
                        e.target.classList.add('selected');
    
                    });
    
                });
    
                
    
                // Add event listener to cancel button
    
                const textCancelButton = colorPicker.querySelector('.cancel-btn');
    
                if (cancelBtn) {
    
                    cancelBtn.addEventListener('click', () => {
    
                        this.resetTextColors();
    
                        this.hideTextColorPicker();
    
                        // Turn off the toggle switch
    
                        const toggle = this.shadowRoot.querySelector('#adjust-text-colors');
    
                        if (toggle) {
    
                            toggle.checked = false;
    
                            this.handleToggle('adjust-text-colors', false);
    
                        }
    
                    });
    
                }
    
                
    
    
            } else {
    
            }
    
        }
    
    
    
        hideTextColorPicker() {
    
            const colorPicker = this.shadowRoot.getElementById('text-color-picker');
    
            if (colorPicker) {
    
                colorPicker.remove();
    
    
            }
    
        }
    
    
    
        applyTextColor(color) {
    
        
    
            
    
            // Apply color to all text elements except buttons, headings, and links
    
            const textElements = document.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b');
    
            
    
            textElements.forEach(element => {
    
                // Skip if element is inside a button, heading, link, or accessibility panel
    
                if (!element.closest('button, h1, h2, h3, h4, h5, h6, a, .btn, .accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.color = color;
    
                }
    
            });
    
            
    
            // Apply color to menu text specifically (but not accessibility panel menu)
    
            const menuElements = document.querySelectorAll('.nav-menu li a, .navbar a, nav a, .menu a, .nav-item a');
    
            menuElements.forEach(element => {
    
                // Skip if element is inside accessibility panel
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.color = color;
    
                }
    
            });
    
            
    
            // Store the selected color
    
            this.selectedTextColor = color;
    

    
        }
    
    
    
        resetTextColors() {
    
       
            
    
            // Remove custom text colors
    
            const textElements = document.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b');
    
            textElements.forEach(element => {
    
                if (!element.closest('button, h1, h2, h3, h4, h5, h6, a, .btn, .accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.color = '';
    
                }
    
            });
    
            
    
            // Reset menu colors (but not accessibility panel menu)
    
            const menuElements = document.querySelectorAll('.nav-menu li a, .navbar a, nav a, .menu a, .nav-item a');
    
            menuElements.forEach(element => {
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.color = '';
    
                }
    
            });
    
            
    
            this.selectedTextColor = null;
    
    
        }
    
    
    
        // Title Color Picker Methods
    
        showTitleColorPicker() {
    

            
    
            // Remove existing color picker if any
    
            this.hideTitleColorPicker();
    
            
    
            // Find the adjust-title-colors module in the panel
    
            const titleColorsModule = this.shadowRoot.querySelector('#adjust-title-colors').closest('.profile-item');
    
            
    
            if (titleColorsModule) {
    
                // Create color picker content
    
                const colorPicker = document.createElement('div');
    
                colorPicker.id = 'title-color-picker';
    
                colorPicker.className = 'color-picker-inline';
    
                // Clear container
                while (colorPicker.firstChild) {
                    colorPicker.removeChild(colorPicker.firstChild);
                }
                
                const content = document.createElement('div');
                content.className = 'color-picker-content';
                
                const h4 = document.createElement('h4');
                h4.textContent = 'Adjust Title Colors';
                content.appendChild(h4);
                
                const titleColorOptions = document.createElement('div');
                titleColorOptions.className = 'color-options';
                
                const titleColors = [
                    { color: '#3b82f6', selected: false },
                    { color: '#8b5cf6', selected: false },
                    { color: '#ef4444', selected: false },
                    { color: '#f97316', selected: true },
                    { color: '#14b8a6', selected: false },
                    { color: '#84cc16', selected: false },
                    { color: '#ffffff', selected: false, border: true },
                    { color: '#000000', selected: false }
                ];
                
                titleColors.forEach(colorData => {
                    const option = document.createElement('div');
                    option.className = 'color-option';
                    if (colorData.selected) {
                        option.classList.add('selected');
                    }
                    option.setAttribute('data-color', colorData.color);
                    option.style.backgroundColor = colorData.color;
                    if (colorData.border) {
                        option.style.border = '1px solid #ccc';
                    }
                    titleColorOptions.appendChild(option);
                });
                
                content.appendChild(titleColorOptions);
                
                const titleCancelBtn = document.createElement('button');
                titleCancelBtn.className = 'cancel-btn';
                titleCancelBtn.textContent = 'Cancel';
                content.appendChild(titleCancelBtn);
                
                colorPicker.appendChild(content);
    
                
    
                // Insert after the profile-info div, before the toggle switch
    
                const profileInfo = titleColorsModule.querySelector('.profile-info');
    
                const toggleSwitch = titleColorsModule.querySelector('.toggle-switch');
    
                titleColorsModule.insertBefore(colorPicker, toggleSwitch);
    
                
    
                // Add event listeners to color options
    
                const titleColorOptionElements = colorPicker.querySelectorAll('.color-option');
    
                titleColorOptionElements.forEach(option => {
    
                    option.addEventListener('click', (e) => {
    
                        const color = e.target.dataset.color;
    
                        this.applyTitleColor(color);
    
                        
    
                        // Update selected state
    
                        titleColorOptionElements.forEach(opt => opt.classList.remove('selected'));
    
                        e.target.classList.add('selected');
    
                    });
    
                });
    
                
    
                // Add event listener to cancel button
    
                const titleCancelButton = colorPicker.querySelector('.cancel-btn');
    
                if (titleCancelButton) {
    
                    titleCancelButton.addEventListener('click', () => {
    
                        this.resetTitleColors();
    
                        this.hideTitleColorPicker();
    
                        // Turn off the toggle switch
    
                        const toggle = this.shadowRoot.querySelector('#adjust-title-colors');
    
                        if (toggle) {
    
                            toggle.checked = false;
    
                            this.handleToggle('adjust-title-colors', false);
    
                        }
    
                    });
    
                }
    
                
    
          
    
            } else {
    
               
    
            }
    
        }
    
    
    
        hideTitleColorPicker() {
    
            const colorPicker = this.shadowRoot.getElementById('title-color-picker');
    
            if (colorPicker) {
    
                colorPicker.remove();
    
            
    
            }
    
        }
    
    
    
        applyTitleColor(color) {
    
          
            
    
            // Apply color to all heading elements except accessibility panel
    
            const headingElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
            
    
            headingElements.forEach(element => {
    
                // Skip if element is inside accessibility panel
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.color = color;
    
                }
    
            });
    
            
    
            // Store the selected color
    
            this.selectedTitleColor = color;
    
           
        }
    
    
    
        resetTitleColors() {
    
            
    
            // Remove custom title colors
    
            const headingElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
            headingElements.forEach(element => {
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.color = '';
    
                }
    
            });
    
            
    
            this.selectedTitleColor = null;
    

        }
    
    
    
        // Background Color Picker Methods
    
        showBackgroundColorPicker() {
    
    
            
    
            // Remove existing color picker if any
    
            this.hideBackgroundColorPicker();
    
            
    
            // Find the adjust-bg-colors module in the panel
    
            const bgColorsModule = this.shadowRoot.querySelector('#adjust-bg-colors').closest('.profile-item');
    
            
    
            if (bgColorsModule) {
    
                // Create color picker content
    
                const colorPicker = document.createElement('div');
    
                colorPicker.id = 'bg-color-picker';
    
                colorPicker.className = 'color-picker-inline';
    
                // Clear container
                while (colorPicker.firstChild) {
                    colorPicker.removeChild(colorPicker.firstChild);
                }
                
                const content = document.createElement('div');
                content.className = 'color-picker-content';
                
                const h4 = document.createElement('h4');
                h4.textContent = 'Adjust Background Colors';
                content.appendChild(h4);
                
                const bgColorOptions = document.createElement('div');
                bgColorOptions.className = 'color-options';
                
                const bgColors = [
                    { color: '#3b82f6', selected: false },
                    { color: '#8b5cf6', selected: false },
                    { color: '#ef4444', selected: false },
                    { color: '#f97316', selected: true },
                    { color: '#14b8a6', selected: false },
                    { color: '#84cc16', selected: false },
                    { color: '#ffffff', selected: false, border: true },
                    { color: '#000000', selected: false }
                ];
                
                bgColors.forEach(colorData => {
                    const option = document.createElement('div');
                    option.className = 'color-option';
                    if (colorData.selected) {
                        option.classList.add('selected');
                    }
                    option.setAttribute('data-color', colorData.color);
                    option.style.backgroundColor = colorData.color;
                    if (colorData.border) {
                        option.style.border = '1px solid #ccc';
                    }
                    bgColorOptions.appendChild(option);
                });
                
                content.appendChild(bgColorOptions);
                
                const bgCancelBtn = document.createElement('button');
                bgCancelBtn.className = 'cancel-btn';
                bgCancelBtn.textContent = 'Cancel';
                content.appendChild(bgCancelBtn);
                
                colorPicker.appendChild(content);
    
                
    
                // Insert after the profile-info div, before the toggle switch
    
                const profileInfo = bgColorsModule.querySelector('.profile-info');
    
                const toggleSwitch = bgColorsModule.querySelector('.toggle-switch');
    
                bgColorsModule.insertBefore(colorPicker, toggleSwitch);
    
                
    
                // Add event listeners to color options
    
                const bgColorOptionElements = colorPicker.querySelectorAll('.color-option');
    
                bgColorOptionElements.forEach(option => {
    
                    option.addEventListener('click', (e) => {
    
                        const color = e.target.dataset.color;
    
                        this.applyBackgroundColor(color);
    
                        
    
                        // Update selected state
    
                        bgColorOptionElements.forEach(opt => opt.classList.remove('selected'));
    
                        e.target.classList.add('selected');
    
                    });
    
                });
    
                
    
                // Add event listener to cancel button
    
                const bgCancelButton = colorPicker.querySelector('.cancel-btn');
    
                if (bgCancelButton) {
    
                    bgCancelButton.addEventListener('click', () => {
    
                        this.resetBackgroundColors();
    
                        this.hideBackgroundColorPicker();
    
                        // Turn off the toggle switch
    
                        const toggle = this.shadowRoot.querySelector('#adjust-bg-colors');
    
                        if (toggle) {
    
                            toggle.checked = false;
    
                            this.handleToggle('adjust-bg-colors', false);
    
                        }
    
                    });
    
                }
    
      
    
            } else {
    
    
            }
    
        }
    
    
    
        hideBackgroundColorPicker() {
    
            const existingPicker = this.shadowRoot.querySelector('.bg-color-picker-controls');
    
            if (existingPicker) {
    
                existingPicker.remove();
    
               
            }
    
        }
    
    
    
        applyBackgroundColor(color) {
    
    
            
    
            // Apply background color only to specific content areas, not the entire page
    
            const mainContentAreas = document.querySelectorAll('section, article, main, .container, .hero, .about, .services, .test-section, .hero-content, .about-content, .services-grid, .service-card, .test-block, .contact-form, .contact-info');
    
            
    
            mainContentAreas.forEach(element => {
    
                // Skip accessibility panel elements
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    // Apply background color to specific content areas only
    
                    element.style.backgroundColor = color;
    
                }
    
            });
    
            
    
            // Also apply to any remaining elements that might have backgrounds
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(element => {
    
                // Skip accessibility panel elements and elements that already have the color
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon') && 
    
                    element.style.backgroundColor !== color) {
    
                    
    
                    // Check if element has a background that's not transparent
    
                    const computedStyle = window.getComputedStyle(element);
    
                    const bgColor = computedStyle.backgroundColor;
    
                    
    
                    // If element has a background that's not transparent, apply our color
    
                    if (bgColor !== 'rgba(0, 0, 0, 0)' && 
    
                        bgColor !== 'transparent' && 
    
                        bgColor !== color &&
    
                        !element.classList.contains('color-option') && // Don't change color picker colors
    
                        !element.classList.contains('cancel-btn')) { // Don't change button colors
    
                        element.style.backgroundColor = color;
    
                    }
    
                }
    
            });
    
            
    
            // Store the selected color
    
            this.selectedBackgroundColor = color;
    
            this.settings['bg-color'] = color;
    
            this.settings['adjust-bg-colors'] = true;
    
            this.saveSettings();
    
         
    
        }
    
    
    
        resetBackgroundColors() {
    
          
    
            
    
            // Reset html and body background
    
            document.documentElement.style.backgroundColor = '';
    
            document.body.style.backgroundColor = '';
    
            
    
            // Reset all main content areas
    
            const mainContentAreas = document.querySelectorAll('html, body, div, section, article, main, aside, header, footer, nav, .container, .hero, .about, .services, .test-section, .hero-content, .about-content, .services-grid, .service-card, .test-block');
    
            
    
            mainContentAreas.forEach(element => {
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.backgroundColor = '';
    
                }
    
            });
    
            
    
            // Reset all other elements that might have been changed
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(element => {
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon') &&
    
                    !element.classList.contains('color-option') && 
    
                    !element.classList.contains('cancel-btn')) {
    
                    // Reset if we applied a background color to it
    
                    if (element.style.backgroundColor && element.style.backgroundColor !== '') {
    
                        element.style.backgroundColor = '';
    
                    }
    
                }
    
            });
    
            
    
            this.selectedBackgroundColor = null;
    
            this.settings['adjust-bg-colors'] = false;
    
            this.settings['bg-color'] = null;
    
            this.saveSettings();
    
            
    
        }
    
    
    
        // Mute Sound Methods
    
        enableMuteSound() {
            
    
            this.settings['mute-sound'] = true;
            this.saveSettings();
            
            // Mute everything immediately
            this.muteAllMediaDirectly();
            
            // Also try to mute any existing audio contexts
            this.muteAllAudioContexts();
            
            
            
            // Start aggressive monitoring
            this.startAggressiveMediaMonitoring();
            
            // Add event listeners to catch new media
            this.addMediaEventListeners();
            
                   }
        
        // Mute all audio contexts (Web Audio API)
        muteAllAudioContexts() {
            
            
            // Suspend all existing audio contexts
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                try {
                    // Get all audio contexts from the window
                    const contexts = [];
                    for (let prop in window) {
                        if (window[prop] instanceof AudioContext || window[prop] instanceof webkitAudioContext) {
                            contexts.push(window[prop]);
                        }
                    }
                    
                    contexts.forEach((context, index) => {
                        if (context.state !== 'closed') {
                            context.suspend();
                           
                        }
                    });
                } catch (e) {
                   
                }
            }
            
            // Also try to mute any audio elements that might be using Web Audio
            const audioElements = document.querySelectorAll('audio');
            audioElements.forEach((element, index) => {
                try {
                    // Force mute and pause
                    element.muted = true;
                    element.volume = 0;
                    element.pause();
                    
                    // Also try to set the currentTime to 0 to stop playback
                    element.currentTime = 0;
                    
                   
                } catch (e) {
                  
                }
            });
        }
        
    
    
    
    
        disableMuteSound() {
      
    
            this.settings['mute-sound'] = false;
            this.saveSettings();
            
            // Stop aggressive media monitoring
            this.stopAggressiveMediaMonitoring();
            
            // Remove event listeners
            this.removeMediaEventListeners();
            
            // Restore all media elements
            this.restoreAllMediaDirectly();
            
            
            
            // Restore iframe players
            this.restoreIframePlayers();
            
            // Restore embed/object players
            this.restoreEmbedPlayers();
            
            // Restore custom players
            this.restoreCustomPlayers();
            
            // Refresh page to ensure all audio is fully restored
            window.location.reload();
          
        }
        
        // Restore iframe players
        restoreIframePlayers() {
            const allIframes = document.querySelectorAll('iframe');
            allIframes.forEach(iframe => {
                iframe.style.display = '';
                iframe.style.visibility = '';
                iframe.style.opacity = '';
            });
        }
        
        // Restore embed/object players
        restoreEmbedPlayers() {
            const allEmbeds = document.querySelectorAll('embed, object');
            allEmbeds.forEach(embed => {
                embed.style.display = '';
                embed.style.visibility = '';
                embed.style.opacity = '';
            });
        }
        
        // Restore custom players
        restoreCustomPlayers() {
            const customPlayers = document.querySelectorAll('[class*="player"], [class*="audio"], [class*="video"], [class*="sound"], [class*="music"]');
            customPlayers.forEach(player => {
                player.style.display = '';
                player.style.visibility = '';
                player.style.opacity = '';
            });
        }
        
       
        // Add event listeners to catch new media elements
        addMediaEventListeners() {
            // Listen for new audio/video elements being added to the DOM
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) { // Element node
                            // Check if it's a media element
                            if (node.tagName === 'AUDIO' || node.tagName === 'VIDEO') {
                                this.muteElement(node);
                            }
                            
                            // Check for iframes being added
                            if (node.tagName === 'IFRAME') {
                                // Mute iframe immediately
                                setTimeout(() => {
                                    this.muteIframePlayer(node);
                                }, 100); // Small delay to allow iframe to load
                            }
                            
                            // Check for media elements within the added node
                            const mediaElements = node.querySelectorAll ? node.querySelectorAll('audio, video') : [];
                            mediaElements.forEach(element => {
                                this.muteElement(element);
                            });
                            
                            // Check for iframes within the added node
                            const iframes = node.querySelectorAll ? node.querySelectorAll('iframe') : [];
                            iframes.forEach(iframe => {
                                setTimeout(() => {
                                    this.muteIframePlayer(iframe);
                                }, 100);
                            });
                        }
                    });
                });
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // Store observer for cleanup
            this.mediaObserver = observer;
            
            // Add global event listeners to catch any media that tries to play
            const handlePlayEvent = (e) => {
                if (this.settings['mute-sound']) {
                    const element = e.target;
                    if (element.tagName === 'AUDIO' || element.tagName === 'VIDEO') {
                        element.muted = true;
                        element.volume = 0;
                        element.pause();
                        element.currentTime = 0;
                    }
                }
            };
            
            const handlePlayingEvent = (e) => {
                if (this.settings['mute-sound']) {
                    const element = e.target;
                    if (element.tagName === 'AUDIO' || element.tagName === 'VIDEO') {
                        element.muted = true;
                        element.volume = 0;
                        element.pause();
                    }
                }
            };
            
            // Add event listeners to document for capturing phase
            document.addEventListener('play', handlePlayEvent, true);
            document.addEventListener('playing', handlePlayingEvent, true);
            
            // Store handlers for cleanup
            this.globalPlayHandler = handlePlayEvent;
            this.globalPlayingHandler = handlePlayingEvent;
        }
        
        // Remove media event listeners
        removeMediaEventListeners() {
            if (this.mediaObserver) {
                this.mediaObserver.disconnect();
                this.mediaObserver = null;
            }
            
            // Remove global event listeners
            if (this.globalPlayHandler) {
                document.removeEventListener('play', this.globalPlayHandler, true);
                this.globalPlayHandler = null;
            }
            
            if (this.globalPlayingHandler) {
                document.removeEventListener('playing', this.globalPlayingHandler, true);
                this.globalPlayingHandler = null;
            }
        }
        
        // Mute a specific element
        muteElement(element) {
            if (element.tagName === 'AUDIO' || element.tagName === 'VIDEO') {
                element.muted = true;
                element.volume = 0;
                if (!element.paused) {
                    element.pause();
                }
     
            }
        }
        
        // Enhanced muting for iframe-based players (YouTube, Vimeo, etc.)
        muteIframePlayer(iframe) {
            if (!iframe || !iframe.contentWindow) return;
            
            try {
                // Try to access iframe content (may fail due to CORS)
                const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
                if (iframeDoc) {
                    // Mute any audio/video elements inside the iframe
                    const audioElements = iframeDoc.querySelectorAll('audio');
                    const videoElements = iframeDoc.querySelectorAll('video');
                    
                    // Mute audio elements and pause them
                    audioElements.forEach(element => {
                        element.muted = true;
                        element.volume = 0;
                        if (!element.paused) element.pause();
                    });
                    
                    // Mute video elements but allow them to play visually
                    videoElements.forEach(element => {
                        element.muted = true;
                        element.volume = 0;
                        // Don't pause videos - allow visual playback
                    });
                }
            } catch (e) {
                // CORS error expected for cross-origin iframes
            }
            
            // Try to mute via postMessage (for supported players)
            // Security: Use specific target origins instead of wildcard
            try {
                const iframeSrc = iframe.src || iframe.getAttribute('src') || '';
                if (!iframeSrc) return;
                
                let targetOrigin = null;
                let platform = null;
                
                // Extract origin from iframe src for security
                try {
                    const iframeUrl = new URL(iframeSrc);
                    targetOrigin = iframeUrl.origin;
                    
                    // Detect platform for specific commands
                    const hostname = iframeUrl.hostname.toLowerCase();
                    if (hostname.includes('youtube.com') || hostname.includes('youtu.be')) {
                        platform = 'youtube';
                        targetOrigin = 'https://www.youtube.com';
                    } else if (hostname.includes('vimeo.com')) {
                        platform = 'vimeo';
                        targetOrigin = 'https://player.vimeo.com';
                    } else if (hostname.includes('soundcloud.com')) {
                        platform = 'soundcloud';
                        targetOrigin = 'https://w.soundcloud.com';
                    } else if (hostname.includes('spotify.com')) {
                        platform = 'spotify';
                        targetOrigin = 'https://open.spotify.com';
                    } else if (hostname.includes('twitch.tv')) {
                        platform = 'twitch';
                        targetOrigin = 'https://player.twitch.tv';
                    } else if (hostname.includes('dailymotion.com')) {
                        platform = 'dailymotion';
                        targetOrigin = 'https://www.dailymotion.com';
                    } else if (hostname.includes('jwplayer.com') || hostname.includes('jwplatform.com')) {
                        platform = 'jwplayer';
                    } else if (hostname.includes('brightcove.com')) {
                        platform = 'brightcove';
                    } else if (hostname.includes('wistia.com')) {
                        platform = 'wistia';
                    }
                } catch {
                    // If URL parsing fails, check for known video domains
                    if (iframeSrc.includes('youtube.com') || iframeSrc.includes('youtu.be')) {
                        platform = 'youtube';
                        targetOrigin = 'https://www.youtube.com';
                    } else if (iframeSrc.includes('vimeo.com')) {
                        platform = 'vimeo';
                        targetOrigin = 'https://player.vimeo.com';
                    } else if (iframeSrc.includes('soundcloud.com')) {
                        platform = 'soundcloud';
                        targetOrigin = 'https://w.soundcloud.com';
                    } else if (iframeSrc.includes('spotify.com')) {
                        platform = 'spotify';
                        targetOrigin = 'https://open.spotify.com';
                    } else if (iframeSrc.includes('twitch.tv')) {
                        platform = 'twitch';
                        targetOrigin = 'https://player.twitch.tv';
                    }
                }
                
                if (!targetOrigin) return;
                
                // Send platform-specific mute commands
                if (platform === 'youtube') {
                    // YouTube iframe API commands
                    iframe.contentWindow.postMessage(JSON.stringify({
                        event: 'command',
                        func: 'mute',
                        args: ''
                    }), targetOrigin);
                    
                    iframe.contentWindow.postMessage(JSON.stringify({
                        event: 'command',
                        func: 'setVolume',
                        args: '0'
                    }), targetOrigin);
                    
                    // Removed pauseVideo - allow videos to play visually while muted
                } else if (platform === 'vimeo') {
                    // Vimeo Player API commands
                    iframe.contentWindow.postMessage(JSON.stringify({
                        method: 'setVolume',
                        value: 0
                    }), targetOrigin);
                    
                    // Removed pause - allow videos to play visually while muted
                } else if (platform === 'soundcloud') {
                    // SoundCloud Widget API
                    iframe.contentWindow.postMessage(JSON.stringify({
                        method: 'setVolume',
                        value: 0
                    }), targetOrigin);
                    
                    // Removed pause - allow audio to play visually while muted
                } else if (platform === 'spotify') {
                    // Spotify Embed API
                    iframe.contentWindow.postMessage(JSON.stringify({
                        command: 'setVolume',
                        value: 0
                    }), targetOrigin);
                } else if (platform === 'twitch') {
                    // Twitch Player API
                    iframe.contentWindow.postMessage(JSON.stringify({
                        type: 'mute'
                    }), targetOrigin);
                } else if (platform === 'dailymotion') {
                    // Dailymotion Player API
                    iframe.contentWindow.postMessage(JSON.stringify({
                        command: 'mute'
                    }), targetOrigin);
                } else if (platform === 'jwplayer') {
                    // JW Player API
                    iframe.contentWindow.postMessage(JSON.stringify({
                        type: 'mute'
                    }), targetOrigin);
                } else {
                    // Generic postMessage attempts for unknown players
                    // Try common mute commands
                    const muteCommands = [
                        { method: 'mute' },
                        { command: 'mute' },
                        { type: 'mute' },
                        { action: 'mute' },
                        { method: 'setVolume', value: 0 },
                        { command: 'setVolume', value: 0 }
                        // Removed pause commands - allow videos to play visually while muted
                    ];
                    
                    muteCommands.forEach(cmd => {
                        try {
                            iframe.contentWindow.postMessage(JSON.stringify(cmd), targetOrigin);
                        } catch (e) {
                            // Ignore errors
                        }
                    });
                }
            } catch (e) {
                // Ignore errors
            }
            
            // Keep iframe visible but muted
        }
        
        // Enhanced muting for embed/object players
        muteEmbedPlayer(embed) {
            
            
            // Try to mute the embed
            if (embed.muted !== undefined) {
                embed.muted = true;
            }
            if (embed.volume !== undefined) {
                embed.volume = 0;
            }
            
            // Keep embed visible but muted
        }
        
        // Enhanced muting for custom players
        muteCustomPlayer(element) {
           
            
            // Look for audio/video elements within the custom player
            const audioElements = element.querySelectorAll('audio');
            const videoElements = element.querySelectorAll('video');
            
            // Mute audio elements and pause them
            audioElements.forEach(mediaElement => {
                mediaElement.muted = true;
                mediaElement.volume = 0;
                if (!mediaElement.paused) mediaElement.pause();
            });
            
            // Mute video elements but allow them to play visually
            videoElements.forEach(mediaElement => {
                mediaElement.muted = true;
                mediaElement.volume = 0;
                // Don't pause videos - allow visual playback
            });
            
            // Try to find and mute any Web Audio API sources
            try {
                const audioContexts = this.getAllAudioContexts();
                audioContexts.forEach(context => {
                    if (context.state !== 'closed') {
                        context.suspend();
                    }
                });
            } catch (e) {
              
            }
            
            // Keep custom player visible but muted
        }
        
        // Get all AudioContext instances
        getAllAudioContexts() {
            const contexts = [];
            
            // Check window properties
            for (let prop in window) {
                try {
                    if (window[prop] instanceof AudioContext || window[prop] instanceof webkitAudioContext) {
                        contexts.push(window[prop]);
                    }
                } catch (e) {
                    // Ignore errors when checking properties
                }
            }
            
            return contexts;
        }
        
        // Comprehensive universal muting approach
        muteAllMediaDirectly() {
           
            
            let totalMuted = 0;
            
            // 1. Standard HTML5 audio/video elements
            const standardAudio = document.querySelectorAll('audio');
            const standardVideo = document.querySelectorAll('video');
  
            
            // 2. Enhanced media detection - check for all possible media sources
            const allMediaElements = [
                ...document.querySelectorAll('audio'),
                ...document.querySelectorAll('video'),
                ...document.querySelectorAll('embed[type*="audio"]'),
                ...document.querySelectorAll('embed[type*="video"]'),
                ...document.querySelectorAll('object[type*="audio"]'),
                ...document.querySelectorAll('object[type*="video"]'),
                ...document.querySelectorAll('iframe[src*="youtube"]'),
                ...document.querySelectorAll('iframe[src*="vimeo"]'),
                ...document.querySelectorAll('iframe[src*="soundcloud"]'),
                ...document.querySelectorAll('iframe[src*="spotify"]'),
                ...document.querySelectorAll('iframe[src*="bandcamp"]'),
                ...document.querySelectorAll('iframe[src*="mixcloud"]'),
                ...document.querySelectorAll('iframe[src*="twitch"]'),
                ...document.querySelectorAll('iframe[src*="dailymotion"]'),
                ...document.querySelectorAll('iframe[src*="player"]'),
                ...document.querySelectorAll('iframe[src*="embed"]'),
                ...document.querySelectorAll('[data-audio]'),
                ...document.querySelectorAll('[data-video]'),
                ...document.querySelectorAll('[data-sound]'),
                ...document.querySelectorAll('[data-music]'),
                ...document.querySelectorAll('.audio-player'),
                ...document.querySelectorAll('.video-player'),
                ...document.querySelectorAll('.music-player'),
                ...document.querySelectorAll('.sound-player'),
                ...document.querySelectorAll('[class*="player"]'),
                ...document.querySelectorAll('[class*="audio"]'),
                ...document.querySelectorAll('[class*="video"]'),
                ...document.querySelectorAll('[class*="sound"]'),
                ...document.querySelectorAll('[class*="music"]')
            ];
            

            
            // Log details about found elements
            if (standardAudio.length > 0) {
     
                standardAudio.forEach((audio, index) => {
                  
                });
            }
            
            if (standardVideo.length > 0) {
                
                standardVideo.forEach((video, index) => {
              
                });
            }
            
            // Process all media elements with enhanced muting
            allMediaElements.forEach((element, index) => {
                
                
                // Handle different types of media elements
                if (element.tagName === 'AUDIO' || element.tagName === 'VIDEO') {
                    // Standard HTML5 media - mute immediately
                    try {
                        element.muted = true;
                        element.volume = 0;
                        // For audio: pause to stop sound
                        // For video: don't pause - allow visual playback, just muted
                        if (element.tagName === 'AUDIO') {
                            element.pause(); // Always pause audio, even if already paused
                            element.currentTime = 0; // Reset to beginning
                        }
                        // Videos can continue playing visually, just muted
                        // Add event listeners to prevent unmuting
                        this.addMuteEventListeners(element);
                        totalMuted++;
                    } catch (e) {
                        // Ignore errors for individual elements
                    }
                } else if (element.tagName === 'IFRAME') {
                    // Handle iframe-based players (YouTube, Vimeo, etc.)
                    this.muteIframePlayer(element);
                    totalMuted++;
                } else if (element.tagName === 'EMBED' || element.tagName === 'OBJECT') {
                    // Handle embed/object elements
                    this.muteEmbedPlayer(element);
                    totalMuted++;
                } else {
                    // Handle custom players and audio/video containers
                    this.muteCustomPlayer(element);
                    totalMuted++;
                }
            });
            
            // 2. Universal detection - find ANY element that might contain audio/video
            const allElements = document.querySelectorAll('*');
            const mediaElements = [];
           
            
            allElements.forEach(element => {
                const tagName = element.tagName.toLowerCase();
                // Convert className to string (it might be a DOMTokenList)
                const className = (typeof element.className === 'string' ? element.className : (element.className?.toString() || '')) || '';
                const id = element.id || '';
                const textContent = element.textContent || '';
                
                // Check for audio/video indicators in various attributes - BE MORE SPECIFIC
                const hasAudioVideo = 
                    // Only check actual media elements
                    (tagName === 'audio' || tagName === 'video') ||
                    // Check for specific media-related data attributes
                    element.hasAttribute('data-audio') || element.hasAttribute('data-video') || 
                    element.hasAttribute('data-src') || element.hasAttribute('data-url') ||
                    element.hasAttribute('tmplayer-meta') || element.hasAttribute('data-player') ||
                    element.hasAttribute('audio-url') || element.hasAttribute('video-url') ||
                    element.hasAttribute('data-sound') ||
                    // Check for specific media file extensions in src attributes
                    (element.src && (element.src.includes('.mp3') || element.src.includes('.wav') || element.src.includes('.ogg') || 
                     element.src.includes('.mp4') || element.src.includes('.webm') || element.src.includes('.avi'))) ||
                    // Check for specific media-related classes (be more specific)
                    (className && typeof className.includes === 'function' && (className.includes('audio-player') || className.includes('video-player') || 
                     className.includes('media-player') || className.includes('sound-player') ||
                     className.includes('music-player') || className.includes('video-container') ||
                     className.includes('audio-container')));
                
                if (hasAudioVideo) {
                
                    mediaElements.push(element);
                }
            });
            
            
            // Mute all detected media elements
            mediaElements.forEach((element, index) => {
            
                
                // Only mute actual media elements - DO NOT HIDE ANY CONTENT
                if (element.tagName === 'AUDIO' || element.tagName === 'VIDEO') {
                    try {
                        element.muted = true;
                        element.volume = 0;
                        // For audio: pause to stop sound
                        // For video: don't pause - allow visual playback, just muted
                        if (element.tagName === 'AUDIO') {
                            element.pause(); // Always pause audio, even if already paused
                            element.currentTime = 0; // Reset to beginning
                        }
                        // Videos can continue playing visually, just muted
                        // Add event listeners to prevent unmuting or playing
                        this.addMuteEventListeners(element);
                        totalMuted++;
                    } catch (e) {
                        // Ignore errors for individual elements
                    }
                }
                // Don't hide any other elements - just mute actual media
            });
            
            // 3. Find and mute any audio sources in custom players - ONLY MUTE, DON'T HIDE
            const audioSources = document.querySelectorAll('[tmplayer-meta="audio-url"], [data-audio], [data-src], [data-url]');
      
            audioSources.forEach((source, index) => {
                
                // Only mute actual media elements - don't hide anything
                if (source.tagName === 'AUDIO' || source.tagName === 'VIDEO') {
                    try {
                        source.muted = true;
                        source.volume = 0;
                        // For audio: pause to stop sound
                        // For video: don't pause - allow visual playback, just muted
                        if (source.tagName === 'AUDIO') {
                            source.pause(); // Always pause audio
                            source.currentTime = 0; // Reset to beginning
                        }
                        // Videos can continue playing visually, just muted
                        // Add event listeners to prevent unmuting
                        this.addMuteEventListeners(source);
                        totalMuted++;
                    } catch (e) {
                        // Ignore errors for individual elements
                    }
                }
            });
            
            // 4. Check iframes for media - use enhanced muteIframePlayer function
            const iframes = document.querySelectorAll('iframe');
  
            iframes.forEach((iframe, index) => {
                try {
                    // First try direct access (same-origin iframes)
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
                    if (iframeDoc) {
                        const iframeAudio = iframeDoc.querySelectorAll('audio');
                        const iframeVideo = iframeDoc.querySelectorAll('video');

                        [...iframeAudio, ...iframeVideo].forEach(element => {
                            // Only mute actual media elements - don't hide anything
                            if (element.tagName === 'AUDIO' || element.tagName === 'VIDEO') {
                                try {
                                    element.volume = 0;
                                    element.muted = true;
                                    // For audio: pause to stop sound
                                    // For video: don't pause - allow visual playback, just muted
                                    if (element.tagName === 'AUDIO') {
                                        element.pause(); // Always pause audio
                                        element.currentTime = 0; // Reset to beginning
                                    }
                                    // Videos can continue playing visually, just muted
                                    totalMuted++;
                                } catch (e) {
                                    // Ignore errors for iframe content (CORS)
                                }
                            }
                        });
                    }
                    
                    // Always try postMessage for cross-origin iframes (YouTube, Vimeo, etc.)
                    // This works even when direct access fails due to CORS
                    this.muteIframePlayer(iframe);
                    totalMuted++;
                } catch (e) {
                    // If direct access fails, still try postMessage
                    try {
                        this.muteIframePlayer(iframe);
                        totalMuted++;
                    } catch (e2) {
                        // Ignore errors
                    }
                }
            });
            
          
            const shadowHosts = document.querySelectorAll('*');
            shadowHosts.forEach((host, index) => {
                if (host.shadowRoot) {
                    try {
                        const shadowAudio = host.shadowRoot.querySelectorAll('audio');
                        const shadowVideo = host.shadowRoot.querySelectorAll('video');
                       
                        
                        [...shadowAudio, ...shadowVideo].forEach(element => {
                            element.muted = true;
                            element.volume = 0;
                            // For audio: pause to stop sound
                            // For video: don't pause - allow visual playback, just muted
                            if (element.tagName === 'AUDIO' && !element.paused) {
                                element.pause();
                            }
                            // Videos can continue playing visually, just muted
                            totalMuted++;
                        });
                    } catch (e) {
                    
                    }
                }
            });
            
            // 5. Suspend all Web Audio API contexts
            this.muteAllAudioContexts();
            
           
            
        }
        
        // Simple direct restoration
        restoreAllMediaDirectly() {
            const allAudio = document.querySelectorAll('audio');
            const allVideo = document.querySelectorAll('video');
            
            // Remove mute event listeners and restore media
            [...allAudio, ...allVideo].forEach(element => {
                try {
                    // Remove event listeners if they were added
                    this.removeMuteEventListeners(element);
                    // Restore media properties
                    element.muted = false;
                    // Restore volume to a reasonable default (1.0 = 100%)
                    element.volume = 1;
                } catch (e) {
                    // Ignore errors for individual elements
                }
            });
        }
        
        // Enhanced aggressive monitoring to catch any media that might start playing
        startAggressiveMediaMonitoring() {
            // Check every 100ms for any media that might have started playing
            this.aggressiveMediaInterval = setInterval(() => {
                if (this.settings['mute-sound']) {
                    // Use the direct muting approach
                    this.muteAllMediaDirectly();
                    
                    // Check for any playing media and force mute
                    const allAudio = document.querySelectorAll('audio');
                    const allVideo = document.querySelectorAll('video');
                    const allIframes = document.querySelectorAll('iframe');
                    const allEmbeds = document.querySelectorAll('embed, object');
                    
                    // Mute standard media elements
                    // For audio: mute and pause
                    allAudio.forEach(element => {
                        if (!element.paused && !element.muted) {
                            element.muted = true;
                            element.volume = 0;
                            element.pause();
                        }
                    });
                    
                    // For video: mute but allow visual playback
                    allVideo.forEach(element => {
                        if (!element.muted) {
                            element.muted = true;
                            element.volume = 0;
                            // Don't pause videos - allow visual playback
                        }
                    });
                    
                    // Mute all iframe players (not just specific ones)
                    allIframes.forEach(iframe => {
                        // Try to mute all iframes, not just known ones
                        // The muteIframePlayer function will handle unknown players with generic commands
                        this.muteIframePlayer(iframe);
                    });
                    
                    // Mute embed/object players
                    allEmbeds.forEach(embed => {
                        this.muteEmbedPlayer(embed);
                    });
                    
                    // Check for Web Audio API contexts
                    try {
                        const audioContexts = this.getAllAudioContexts();
                        audioContexts.forEach(context => {
                            if (context.state === 'running') {
                              
                                context.suspend();
                            }
                        });
                    } catch (e) {
                    
                    }
                }
            }, 100);
          
        }
        
        // Stop aggressive media monitoring
        stopAggressiveMediaMonitoring() {
            if (this.aggressiveMediaInterval) {
                clearInterval(this.aggressiveMediaInterval);
                this.aggressiveMediaInterval = null;
              
            }
        }
    
        // Force mute all media immediately (including already playing)
        forceMuteAllMedia(audioElements, videoElements) {
           
            
            // Process all audio elements
            audioElements.forEach((element, index) => {
   
                
                // Force mute immediately
                element.muted = true;
                element.volume = 0;
                
                // Pause if playing
                if (!element.paused) {
                   
                    element.pause();
                }
                
                // Add event listeners to prevent unmuting
                element.addEventListener('volumechange', () => {
                    if (this.settings['mute-sound']) {
                        element.muted = true;
                        element.volume = 0;
                    }
                });
                
                element.addEventListener('play', () => {
                    if (this.settings['mute-sound']) {
                        element.pause();
                    }
                });
            });
            
            // Process all video elements
            videoElements.forEach((element, index) => {

                
                // Force mute immediately
                element.muted = true;
                element.volume = 0;
                
                // Don't pause videos - allow visual playback, just muted
                
                // Add event listeners to prevent unmuting
                element.addEventListener('volumechange', () => {
                    if (this.settings['mute-sound']) {
                        element.muted = true;
                        element.volume = 0;
                    }
                });
                
                element.addEventListener('play', () => {
                    if (this.settings['mute-sound']) {
                        element.pause();
                    }
                });
            });
        }
    
        // Comprehensive mute functionality for all media elements
        muteAllMediaElements(audioElements, videoElements) {
            // Process audio elements
            audioElements.forEach((element, index) => {
                const elementId = this.getElementId(element, 'audio', index);
                
                // Store original volume and playing state BEFORE muting
                this.originalVolumeStates.set(elementId, element.volume);
                this.originalPlayingStates.set(elementId, !element.paused);
                
                
                // Mute the element immediately
                element.muted = true;
                element.volume = 0;
                
                // If currently playing, pause it
                if (!element.paused) {
       
                    element.pause();
                }
                
                // Add event listeners to prevent unmuting
                this.addMuteEventListeners(element);
                
                
            });
    
            // Process video elements
            videoElements.forEach((element, index) => {
                const elementId = this.getElementId(element, 'video', index);
                
                // Store original volume and playing state BEFORE muting
                this.originalVolumeStates.set(elementId, element.volume);
                this.originalPlayingStates.set(elementId, !element.paused);
                
  
                
                // Mute the element immediately
                element.muted = true;
                element.volume = 0;
                
                // For audio: pause to stop sound
                // For video: don't pause - allow visual playback, just muted
                if (element.tagName === 'AUDIO' && !element.paused) {
                    element.pause();
                }
                // Videos can continue playing visually, just muted
                
                // Add event listeners to prevent unmuting
                this.addMuteEventListeners(element);
              
            });
        }
    
        // Generate unique ID for media elements
        getElementId(element, type, index) {
            // Try to use existing ID or generate one
            if (element.id) {
                return `${type}-${element.id}`;
            } else {
                return `${type}-${index}-${Date.now()}`;
            }
        }
    
        // Start monitoring for dynamically added media elements
        startMediaObserver() {
            if (this.mediaObserver) {
                this.mediaObserver.disconnect();
            }
    
            this.mediaObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // Check if the added node is a media element
                                if (node.tagName === 'AUDIO' || node.tagName === 'VIDEO') {
                                    this.muteSingleMediaElement(node);
                                }
                                
                                // Check for media elements within the added node
                                const mediaElements = node.querySelectorAll ? 
                                    node.querySelectorAll('audio, video') : [];
                                
                                mediaElements.forEach(element => {
                                    this.muteSingleMediaElement(element);
                                });
                            }
                        });
                    }
                });
            });
    
            // Start observing
            this.mediaObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
    
    
        }
    
        // Stop monitoring for media changes
        stopMediaObserver() {
            if (this.mediaObserver) {
                this.mediaObserver.disconnect();
                this.mediaObserver = null;
             
            }
        }
    
        // Mute a single media element
        muteSingleMediaElement(element) {
            const elementId = this.getElementId(element, element.tagName.toLowerCase(), Date.now());
            
            // Store original states
            this.originalVolumeStates.set(elementId, element.volume);
            this.originalPlayingStates.set(elementId, !element.paused);
            
            // Mute the element
            element.volume = 0;
            element.muted = true;
            
            // For audio: pause to stop sound
            // For video: don't pause - allow visual playback, just muted
            if (element.tagName === 'AUDIO' && !element.paused) {
                element.pause();
            }
            // Videos can continue playing visually, just muted
            
            // Add event listeners to prevent unmuting
            this.addMuteEventListeners(element);
            
      
        }
    
        // Add event listeners to prevent unmuting while mute is active
        addMuteEventListeners(element) {
            const muteHandler = (e) => {
                if (this.settings['mute-sound']) {
                    element.volume = 0;
                    element.muted = true;
                    // For audio: pause to stop sound
                    // For video: don't pause - allow visual playback, just muted
                    if (element.tagName === 'AUDIO' && !element.paused) {
                        element.pause();
                    }
                    // Videos can continue playing visually, just muted
                }
            };
    
            // Store the handler for later removal
            if (!element._muteHandlers) {
                element._muteHandlers = [];
            }
    
            const volumeHandler = (e) => {
                if (this.settings['mute-sound'] && element.volume > 0) {
                    element.volume = 0;
                }
            };
    
            const playHandler = (e) => {
                if (this.settings['mute-sound']) {
                    // For audio: pause to stop sound
                    // For video: just ensure it's muted, but allow playback
                    if (element.tagName === 'AUDIO') {
                        element.pause();
                    } else if (element.tagName === 'VIDEO') {
                        // Ensure video is muted but allow it to play
                        element.muted = true;
                        element.volume = 0;
                    }
                }
            };
    
            element.addEventListener('volumechange', volumeHandler);
            element.addEventListener('play', playHandler);
            element.addEventListener('loadeddata', muteHandler);
    
            element._muteHandlers.push(volumeHandler, playHandler, muteHandler);
        }
    
        // Remove mute event listeners
        removeMuteEventListeners(element) {
            if (element._muteHandlers) {
                element._muteHandlers.forEach(handler => {
                    element.removeEventListener('volumechange', handler);
                    element.removeEventListener('play', handler);
                    element.removeEventListener('loadeddata', handler);
                });
                element._muteHandlers = [];
            }
        }
    
        // Restore all media elements to their original states
        restoreAllMediaElements() {
            if (!this.originalVolumeStates || !this.originalPlayingStates) {
            
                return;
            }
    
            const audioElements = document.querySelectorAll('audio');
            const videoElements = document.querySelectorAll('video');
    

    
            // Restore audio elements
            audioElements.forEach((element, index) => {
                const elementId = this.getElementId(element, 'audio', index);
                const originalVolume = this.originalVolumeStates.get(elementId);
                const wasPlaying = this.originalPlayingStates.get(elementId);
    
                
    
                if (originalVolume !== undefined) {
                    // Remove mute event listeners
                    this.removeMuteEventListeners(element);
                    
                    // Restore original volume and unmute
                    element.volume = originalVolume;
                    element.muted = false;
                    

                    
                    // Resume playing if it was playing before
                    if (wasPlaying && element.paused) {
                    
                        element.play().catch(e => {
                           
                        });
                    }
                }
            });
    
            // Restore video elements
            videoElements.forEach((element, index) => {
                const elementId = this.getElementId(element, 'video', index);
                const originalVolume = this.originalVolumeStates.get(elementId);
                const wasPlaying = this.originalPlayingStates.get(elementId);
    
    
                if (originalVolume !== undefined) {
                    // Remove mute event listeners
                    this.removeMuteEventListeners(element);
                    
                    // Restore original volume and unmute
                    element.volume = originalVolume;
                    element.muted = false;
                    

                    
                    // Resume playing if it was playing before
                    if (wasPlaying && element.paused) {
                       
                        element.play().catch(e => {
                       
                        });
                    }
                }
            });
    
            // Clear stored states
            this.originalVolumeStates.clear();
            this.originalPlayingStates.clear();
          
        }
    
        // Additional method to handle Web Audio API and other audio contexts
        muteWebAudioContexts() {
            // Handle Web Audio API contexts
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                try {
                    const AudioContextClass = AudioContext || webkitAudioContext;
                    if (this.audioContext) {
                        this.audioContext.suspend();
                    }
                } catch (e) {
                   
                }
            }
    
            // Handle other audio sources that might not be in DOM
            const audioSources = document.querySelectorAll('source[type*="audio"], source[type*="video"]');
            audioSources.forEach(source => {
                const parent = source.parentElement;
                if (parent && (parent.tagName === 'AUDIO' || parent.tagName === 'VIDEO')) {
                    parent.volume = 0;
                    parent.muted = true;
                    if (!parent.paused) {
                        parent.pause();
                    }
                }
            });
        }
    
        // Method to handle iframe embedded media (YouTube, Vimeo, etc.)
        muteIframeMedia() {
            const iframes = document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                try {
                    // Try to access iframe content (may fail due to CORS)
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (iframeDoc) {
                        // Mute audio elements and pause them
                        const iframeAudio = iframeDoc.querySelectorAll('audio');
                        iframeAudio.forEach(element => {
                            element.volume = 0;
                            element.muted = true;
                            if (!element.paused) {
                                element.pause();
                            }
                        });
                        
                        // Mute video elements but allow them to play visually
                        const iframeVideo = iframeDoc.querySelectorAll('video');
                        iframeVideo.forEach(element => {
                            element.volume = 0;
                            element.muted = true;
                            // Don't pause videos - allow visual playback
                        });
                    }
                } catch (e) {
             
                }
            });
        }
    
        // Hide Images Methods
        enableHideImages() {
            this.settings['hide-images'] = true;
            document.body.classList.add('hide-images');
            
            // Add CSS rules for hiding images if not already added
            if (!document.getElementById('hide-images-css')) {
                const style = document.createElement('style');
                style.id = 'hide-images-css';
                style.textContent = `
                    /* Hide all standard image elements */
                    .hide-images img,
                    .hide-images picture,
                    .hide-images svg,
                    .hide-images video,
                    .hide-images canvas,
                    .hide-images iframe[src*="image"],
                    .hide-images iframe[src*="img"],
                    .hide-images embed[type*="image"],
                    .hide-images object[type*="image"] {
                        display: none !important;
                        visibility: hidden !important;
                        opacity: 0 !important;
                        width: 0 !important;
                        height: 0 !important;
                        max-width: 0 !important;
                        max-height: 0 !important;
                    }
                    
                    /* Hide background images */
                    .hide-images [style*="background-image"],
                    .hide-images [style*="background: url"],
                    .hide-images [style*="background:url"] {
                        background-image: none !important;
                        background: none !important;
                    }
                    
                    /* Hide CSS background images */
                    .hide-images *[class*="bg-"],
                    .hide-images *[class*="background"],
                    .hide-images *[class*="image"],
                    .hide-images *[class*="img"],
                    .hide-images *[class*="photo"],
                    .hide-images *[class*="picture"],
                    .hide-images *[class*="banner"],
                    .hide-images *[class*="hero"],
                    .hide-images *[class*="cover"] {
                        background-image: none !important;
                        background: none !important;
                    }
                    
                    /* Hide image containers and wrappers */
                    .hide-images .image-container,
                    .hide-images .img-container,
                    .hide-images .photo-container,
                    .hide-images .picture-container,
                    .hide-images .media-container,
                    .hide-images .gallery,
                    .hide-images .carousel,
                    .hide-images .slider,
                    .hide-images .banner,
                    .hide-images .hero,
                    .hide-images .cover {
                        display: none !important;
                        visibility: hidden !important;
                    }
                    
                    /* Hide lazy-loaded images */
                    .hide-images img[data-src],
                    .hide-images img[data-lazy],
                    .hide-images img[loading="lazy"],
                    .hide-images picture[data-src],
                    .hide-images picture[data-lazy] {
                        display: none !important;
                        visibility: hidden !important;
                    }
                    
                    /* Hide responsive images */
                    .hide-images source,
                    .hide-images img[srcset],
                    .hide-images picture > img {
                        display: none !important;
                        visibility: hidden !important;
                    }
                    
                    /* Hide icon fonts and icon images */
                    .hide-images [class*="icon"],
                    .hide-images [class*="fa-"],
                    .hide-images [class*="fas"],
                    .hide-images [class*="far"],
                    .hide-images [class*="fab"],
                    .hide-images [class*="material-icons"] {
                        display: none !important;
                        visibility: hidden !important;
                    }
                    
                    /* Hide decorative elements that might be images */
                    .hide-images .decoration,
                    .hide-images .ornament,
                    .hide-images .pattern,
                    .hide-images .texture {
                        display: none !important;
                        visibility: hidden !important;
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Start monitoring for dynamically added images
            this.startImageObserver();
            
            this.saveSettings();
           
        }
    
        disableHideImages() {
            this.settings['hide-images'] = false;
            document.body.classList.remove('hide-images');
            
            // Stop monitoring for dynamically added images
            this.stopImageObserver();
            
            // Remove CSS rules for hiding images
            const existingStyle = document.getElementById('hide-images-css');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            this.saveSettings();
       
        }

        // Image Observer Methods
        startImageObserver() {
            // Stop any existing observer
            this.stopImageObserver();
            
            this.imageObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                this.hideImageElement(node);
                                
                                // Also check for nested images
                                const nestedImages = node.querySelectorAll ? node.querySelectorAll('img, picture, svg, video, canvas, iframe[src*="image"], iframe[src*="img"]') : [];
                                nestedImages.forEach(img => this.hideImageElement(img));
                            }
                        });
                    }
                });
            });
            
            // Start observing
            this.imageObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
            
           
        }
        
        stopImageObserver() {
            if (this.imageObserver) {
                this.imageObserver.disconnect();
                this.imageObserver = null;
              
            }
        }
        
        hideImageElement(element) {
            if (!element || !element.style) return;
            
            // Apply hiding styles directly to the element
            element.style.setProperty('display', 'none', 'important');
            element.style.setProperty('visibility', 'hidden', 'important');
            element.style.setProperty('opacity', '0', 'important');
            element.style.setProperty('width', '0', 'important');
            element.style.setProperty('height', '0', 'important');
            element.style.setProperty('max-width', '0', 'important');
            element.style.setProperty('max-height', '0', 'important');
            
            // Remove background images
            element.style.setProperty('background-image', 'none', 'important');
            element.style.setProperty('background', 'none', 'important');
            
          
        }

        // Read Mode Methods
    
        enableReadMode() {
    
    
            // Remove existing read mode if any
    
            this.disableReadMode();
    
            
    
            // Extract content from the website
    
            const content = this.extractTextContent();
    
         
    
            
    
            // If no content was extracted, use fallback content
    
            const finalContent = content || '<div style="padding: 20px; color: #666; font-size: 1.1em;">No content could be extracted from this page.</div>';
    
            
    
            // Prevent body/html from scrolling when read mode is active
            this.injectStyle('read-mode-scroll-fix', `
                html.read-mode,
                body.read-mode {
                    overflow: hidden !important;
                    height: 100vh !important;
                    position: fixed !important;
                    width: 100% !important;
                }
            `);
            
            // Add read-mode class to body and html
            document.documentElement.classList.add('read-mode');
            document.body.classList.add('read-mode');
            
            // Create overlay with extracted content
            // Use string concatenation instead of template literal interpolation to avoid syntax errors
            const overlayHTML = '<div id="read-mode-overlay" style="position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; background: #e8f4f8 !important; z-index: 99997 !important; font-family: Arial, sans-serif !important; overflow-y: auto !important; overflow-x: hidden !important; -webkit-overflow-scrolling: touch !important;"><div style="padding: 20px; max-width: 800px; margin: 0 auto; width: 100%; box-sizing: border-box;">' + finalContent + '</div></div>';
    
            
    
            // Insert the HTML directly to body (read mode needs to cover entire page)
            // CRITICAL: Read mode overlay must be on body, not widget container, to be interactive
            if (this.isDesignerMode()) {
                return; // Exit if in Designer mode
            }
            
            // Remove existing overlay if any
            const existingOverlay = document.getElementById('read-mode-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Create overlay directly on body for full page coverage
            const overlay = document.createElement('div');
            overlay.id = 'read-mode-overlay';
            overlay.setAttribute('data-accessbit-widget-overlay', 'true');

            overlay.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; background: #e8f4f8 !important; z-index: 99997 !important; font-family: Arial, sans-serif !important; overflow-y: auto !important; overflow-x: hidden !important; -webkit-overflow-scrolling: touch !important;';
            
            const innerDiv = document.createElement('div');
            innerDiv.style.cssText = 'padding: 20px; max-width: 800px; margin: 0 auto; width: 100%; box-sizing: border-box;';
            
            // Create a temporary container to parse the content safely
            const tempDiv = document.createElement('div');
            tempDiv.textContent = finalContent.replace(/<[^>]*>/g, ''); // Strip HTML tags for text content
            // If finalContent has HTML, we need to parse it safely

            innerDiv.textContent = finalContent.replace(/<[^>]*>/g, '') || 'No content could be extracted from this page.';
            
            overlay.appendChild(innerDiv);
            
            // Append directly to body (not widget container) so it's interactive
            if (this.safeDOMOperation(() => {
                document.body.appendChild(overlay);
            }, 'create read mode overlay')) {
                // Overlay created successfully
            } else {
                return; // Failed to create overlay
            }
            
            // Overlay already created by createScopedOverlay
    
            if (overlay) {
    
    
            } else {
    

    
            }
    
            
    
         
    
        }
    
    
    
        extractTextContent() {
    
       
    
            let content = '';
            const processedTexts = new Set(); // Track processed text to avoid duplicates
            const processedElements = new Set(); // Track processed elements to avoid duplicates
    
            // First, try to find main content areas (article, main, section with content)
            const mainContentSelectors = [
                'main',
                'article', 
                '[role="main"]',
                '.content',
                '.main-content',
                '.post-content',
                '.entry-content',
                '.article-content',
                '#content',
                '#main'
            ];
    
            let contentContainer = null;
            for (const selector of mainContentSelectors) {
                const element = document.querySelector(selector);
                if (element && element.innerText.trim().length > 100) {
                    contentContainer = element;
             
                    break;
                }
            }
    
            // If no main content area found, use body but filter out navigation
            if (!contentContainer) {
                contentContainer = document.body;

            }
    
            // Get content elements, focusing on main content areas
            const allElements = contentContainer.querySelectorAll('h1, h2, h3, h4, h5, h6, p, a, img, button, div, span, li, ul, ol, section, article, main, blockquote, pre, code, strong, em, b, i, u, mark, small, sub, sup, del, ins, cite, q, abbr, time, address, details, summary, figure, figcaption, table, tr, td, th, thead, tbody, tfoot, dl, dt, dd');
    
    
            
    
            // Process elements in the order they appear on the page
            let processedCount = 0;
    
            allElements.forEach(element => {
                // Define variables at the beginning of the loop
                const tagName = element.tagName.toLowerCase();
                const text = element.innerText.trim();
    
                // Skip if already processed
                if (processedElements.has(element)) {
                    return;
                }
    
                // Skip accessibility widget elements
                if (element.closest('.accessbit-widget-panel') || element.closest('#accessbit-widget-icon')) {
                   
                    return;
                }
    
                // Skip navigation elements (but allow images and links from main content)
                if (element.closest('nav') || element.closest('.nav') || element.closest('.navigation') || 
                    element.closest('.menu') || element.closest('.header') || element.closest('.footer') ||
                    element.closest('.sidebar') || element.closest('.widget') || element.closest('.advertisement') ||
                    element.closest('.ad') || element.closest('.banner') || element.closest('.popup') ||
                    element.closest('.modal') || element.closest('.overlay')) {
                    // Allow images and links from main content areas even if they're in filtered containers
                    if (tagName === 'img' || tagName === 'a') {
                        const isInMainContent = element.closest('main, article, [role="main"], .content, .main-content, .post-content, .entry-content, .article-content, #content, #main, .post, .entry, .page-content, .site-content');
                        if (isInMainContent) {
                      
                        } else {
                            return;
                        }
                    } else {
                        return;
                    }
                }
    
                // Skip hidden elements
                if (element.style.display === 'none' || element.style.visibility === 'hidden' || 
                    element.offsetParent === null || element.getAttribute('aria-hidden') === 'true') {
                    return;
                }
    
                // Skip elements with no visible text
                if (!element.innerText || element.innerText.trim().length === 0) {
                    return;
                }
    
                // Skip elements that contain CSS or JavaScript code
                if (text.includes('{') && text.includes('}') && (text.includes('color:') || text.includes('background:') || text.includes('function') || text.includes('var ') || text.includes('const ') || text.includes('let '))) {
           
                    return;
                }
    
                // Skip very short text that's likely not content
                if (text.length < 3) {
                    return;
                }
    
                // Skip duplicate text content
                if (processedTexts.has(text)) {
             
                    return;
                }
    
             
    
                
    
                if (tagName.match(/^h[1-6]$/)) {
    
                    // Headings
    
                    if (text) {
    
                        const size = tagName === 'h1' ? '2.5em' : 
    
                                   tagName === 'h2' ? '2em' : 
    
                                   tagName === 'h3' ? '1.5em' : '1.2em';
    
                        content += `<div style="margin: 20px 0; font-size: ${size}; font-weight: bold; color: #333; line-height: 1.3;">${text}</div>`;
    
                        processedCount++;
                        processedTexts.add(text);
                        processedElements.add(element);
    
                    }
    
                } else if (tagName === 'p') {
    
                    // Paragraphs
    
                    if (text && text.length > 5) {
    
                        content += `<div style="margin: 15px 0; font-size: 1.1em; line-height: 1.6; color: #444;">${text}</div>`;
    
                        processedCount++;
                        processedTexts.add(text);
                        processedElements.add(element);
    
                    }
    
                } else if (tagName === 'a' && element.href) {
    
                    // Links
    
                    if (text) {
    
                        content += `<div style="margin: 10px 0; font-size: 1em; color: #0066cc; text-decoration: underline;">
                            <a href="${element.href}" target="_blank" style="color: #0066cc; text-decoration: underline;">${text}</a>
                            <span style="font-size: 0.8em; color: #666; margin-left: 8px;">(${element.href})</span>
                        </div>`;
    
                        processedCount++;
                        processedTexts.add(text);
                        processedElements.add(element);
    
                    }
    
                } else if (tagName === 'img' && element.src) {
    
                    // Images
    
                    const src = element.src;
    
                    const alt = element.alt || '';
    
                    const title = element.title || '';
    
                    content += `<div style="margin: 20px 0; text-align: center;">
    
                        <img src="${src}" alt="${alt}" title="${title}" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" />
    
                        ${alt ? `<div style="margin-top: 8px; font-size: 0.9em; color: #666; font-style: italic;">${alt}</div>` : ''}
    
                        ${title && title !== alt ? `<div style="margin-top: 4px; font-size: 0.8em; color: #888;">${title}</div>` : ''}
    
                    </div>`;
    
                    processedCount++;
                    processedTexts.add(text);
                    processedElements.add(element);
    
                } else if (tagName === 'button' && text) {
    
                    // Buttons
    
                    content += `<div style="margin: 10px 0; font-size: 1em; color: #333; font-weight: 500;">[Button] ${text}</div>`;
    
                    processedCount++;
                    processedTexts.add(text);
                    processedElements.add(element);
    
                } else if (tagName === 'li' && text) {
    
                    // List items
    
                    content += `<div style="margin: 8px 0; font-size: 1em; color: #444; padding-left: 20px;"> ${text}</div>`;
    
                    processedCount++;
                    processedTexts.add(text);
                    processedElements.add(element);
    
                } else if (tagName === 'div' && text && text.length > 20 && !text.includes('{') && !text.includes('}') && !text.includes('function') && !text.includes('var ') && !text.includes('const ') && !text.includes('let ')) {
    
                    // Divs with substantial text content (but not code)
    
                    content += `<div style="margin: 10px 0; font-size: 1em; color: #444; line-height: 1.5;">${text}</div>`;
    
                    processedCount++;
                    processedTexts.add(text);
                    processedElements.add(element);
    
                } else if (tagName === 'span' && text && text.length > 10 && !text.includes('{') && !text.includes('}') && !text.includes('function') && !text.includes('var ') && !text.includes('const ') && !text.includes('let ')) {
    
                    // Spans with text content (but not code)
    
                    content += `<span style="color: #444;">${text}</span>`;
    
                    processedCount++;
                    processedTexts.add(text);
                    processedElements.add(element);
    
                } else if (tagName === 'strong' || tagName === 'b') {
    
                    // Bold text
    
                    if (text) {
                        content += `<strong style="font-weight: bold; color: #333;">${text}</strong>`;
                        processedCount++;
                        processedTexts.add(text);
                        processedElements.add(element);
                    }
    
                } else if (tagName === 'em' || tagName === 'i') {
    
                    // Italic text
    
                    if (text) {
                        content += `<em style="font-style: italic; color: #444;">${text}</em>`;
                        processedCount++;
                        processedTexts.add(text);
                        processedElements.add(element);
                    }
    
                } else if (tagName === 'blockquote' && text) {
    
                    // Blockquotes
    
                    content += `<div style="margin: 15px 0; padding-left: 20px; border-left: 3px solid #ccc; font-style: italic; color: #555;">${text}</div>`;
    
                    processedCount++;
                    processedTexts.add(text);
                    processedElements.add(element);
    
                } else if (tagName === 'code' && text) {
    
                    // Code
    
                    content += `<code style="background: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; color: #333;">${text}</code>`;
    
                    processedCount++;
                    processedTexts.add(text);
                    processedElements.add(element);
    
                } else if (tagName === 'table') {
    
                    // Tables
    
                    const rows = element.querySelectorAll('tr');
                    if (rows.length > 0) {
                        content += `<div style="margin: 15px 0; overflow-x: auto;"><table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;">`;
                        rows.forEach(row => {
                            const cells = row.querySelectorAll('td, th');
                            if (cells.length > 0) {
                                content += `<tr>`;
                                cells.forEach(cell => {
                                    const cellTag = cell.tagName.toLowerCase() === 'th' ? 'th' : 'td';
                                    content += `<${cellTag} style="border: 1px solid #ddd; padding: 8px; text-align: left;">${cell.textContent.trim()}</${cellTag}>`;
                                });
                                content += `</tr>`;
                            }
                        });
                        content += `</table></div>`;
                        processedCount++;
                        processedTexts.add(text);
                        processedElements.add(element);
                    }
    
                } else if (tagName === 'section' || tagName === 'article' || tagName === 'main') {
    
                    // Sections, articles, main content
    
                    if (text && text.length > 20) {
                        content += `<div style="margin: 20px 0; padding: 15px; background: #f9f9f9; border-radius: 5px;">${text}</div>`;
                        processedCount++;
                        processedTexts.add(text);
                        processedElements.add(element);
                    }
    
                }
    
            });
    
            
    
            // If no content was extracted, show a message
    
            if (!content) {
    
                content = '<div style="text-align: center; padding: 40px; color: #6b7280;">' +
    
                    '<h2 style="color: #374151;">No readable content found</h2>' +
    
                    '<p>This page may not have extractable text content.</p>' +
    
                    '</div>';
    
            }
    
            
    
    
            // If we didn't get much content, try alternative extraction method
            if (content.length < 200) {
             
                const alternativeContent = this.extractTextContentAlternative();
                if (alternativeContent.length > content.length) {
         
                    return alternativeContent;
                }
            }
    
            return content;
    
        }
    
        // Alternative content extraction method for better results
        extractTextContentAlternative() {
           
            
            let content = '';
            const processedTexts = new Set(); // Track processed text to avoid duplicates
            
            // Try to find the main content area more aggressively
            const contentSelectors = [
                'main',
                'article',
                '[role="main"]',
                '.content',
                '.main-content',
                '.post-content',
                '.entry-content',
                '.article-content',
                '#content',
                '#main',
                '.post',
                '.entry',
                '.page-content',
                '.site-content'
            ];
            
            let mainContent = null;
            for (const selector of contentSelectors) {
                const element = document.querySelector(selector);
                if (element && element.innerText && element.innerText.trim().length > 50) {
                    mainContent = element;
           
                    break;
                }
            }
            
            if (!mainContent) {
                // Fallback to body but exclude common non-content areas
                mainContent = document.body;
               
            }
            
            // Get all text nodes and their parent elements
            const walker = document.createTreeWalker(
                mainContent,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        // Skip empty or whitespace-only text nodes
                        if (!node.textContent || node.textContent.trim().length === 0) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        
                        // Skip text nodes in script, style, or other non-content elements
                        const parent = node.parentElement;
                        if (!parent || parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE' || 
                            parent.tagName === 'NOSCRIPT' || parent.closest('nav') || 
                            parent.closest('.nav') || parent.closest('.menu') || 
                            parent.closest('.header') || parent.closest('.footer') ||
                            parent.closest('.sidebar') || parent.closest('.widget') ||
                            parent.closest('.advertisement') || parent.closest('.ad') ||
                            parent.closest('.banner') || parent.closest('.popup') ||
                            parent.closest('.modal') || parent.closest('.overlay') ||
                            parent.closest('.accessbit-widget-panel') || parent.closest('#accessbit-widget-icon')) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        
                        // Skip text that looks like code
                        const text = node.textContent.trim();
                        if (text.includes('{') && text.includes('}') && 
                            (text.includes('color:') || text.includes('background:') || 
                             text.includes('function') || text.includes('var ') || 
                             text.includes('const ') || text.includes('let '))) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        
                        return NodeFilter.FILTER_ACCEPT;
                    }
                }
            );
            
            let textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            
            // Process text nodes and their parent elements
            let processedCount = 0;
            textNodes.forEach(textNode => {
                const parent = textNode.parentElement;
                if (!parent) return;
                
                const tagName = parent.tagName.toLowerCase();
                const text = textNode.textContent.trim();
                
                if (text.length < 3) return;
                
                // Skip duplicate text content
                if (processedTexts.has(text)) {
                    return;
                }
                
                // Format based on parent element type
                if (tagName.match(/^h[1-6]$/)) {
                    const size = tagName === 'h1' ? '2.5em' : 
                               tagName === 'h2' ? '2em' : 
                               tagName === 'h3' ? '1.5em' : '1.2em';
                    content += `<div style="margin: 20px 0; font-size: ${size}; font-weight: bold; color: #333; line-height: 1.3;">${text}</div>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (tagName === 'p') {
                    content += `<div style="margin: 15px 0; font-size: 1.1em; line-height: 1.6; color: #444;">${text}</div>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (tagName === 'a' && parent.href) {
                    content += `<div style="margin: 10px 0; font-size: 1em; color: #0066cc; text-decoration: underline;">${text}</div>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (tagName === 'li') {
                    content += `<div style="margin: 8px 0; font-size: 1em; color: #444; padding-left: 20px;"> ${text}</div>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (tagName === 'strong' || tagName === 'b') {
                    content += `<strong style="font-weight: bold; color: #333;">${text}</strong>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (tagName === 'em' || tagName === 'i') {
                    content += `<em style="font-style: italic; color: #444;">${text}</em>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (tagName === 'blockquote') {
                    content += `<div style="margin: 15px 0; padding-left: 20px; border-left: 3px solid #ccc; font-style: italic; color: #555;">${text}</div>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (tagName === 'code') {
                    content += `<code style="background: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; color: #333;">${text}</code>`;
                    processedCount++;
                    processedTexts.add(text);
                } else if (text.length > 20) {
                    // Generic text content
                    content += `<div style="margin: 10px 0; font-size: 1em; color: #444; line-height: 1.5;">${text}</div>`;
                    processedCount++;
                    processedTexts.add(text);
                }
            });
            

            return content;
        }
    
    
    
        disableReadMode() {
    
       
    
            
    
            const readModeOverlay = document.getElementById('read-mode-overlay');
    
            if (readModeOverlay) {
    
                readModeOverlay.remove();

    
            } else {
    
           
            }
            
            // Remove read-mode classes from html and body to restore scrolling
            document.documentElement.classList.remove('read-mode');
            document.body.classList.remove('read-mode');
            
            // Remove the CSS that prevents body/html scrolling
            this.removeStyle('read-mode-scroll-fix');
    
            
    
            // Force a reflow to ensure the overlay is completely removed
    
            document.body.offsetHeight;
    
        }
    
    
    
        // Reading Guide Methods
    
        enableReadingGuide() {
    
            
            
    
            // Remove existing reading guide if any
    
            this.disableReadingGuide();
    
            
    
            // Add reading guide styles
    
            const style = document.createElement('style');
    
            style.id = 'reading-guide-styles';
    
            style.textContent = `
    
                .reading-guide {
    
                    position: relative;
    
                }
    
                
    
                .reading-guide-active {
    
                    cursor: none;
    
                }
    
                
    
                .reading-guide-bar {
    
                    position: fixed;
    
                    width: 200px;
    
                    height: 4px;
    
                    background: linear-gradient(90deg, rgba(99, 102, 241, 0.8), rgba(99, 102, 241, 0.4));
    
                    border-radius: 2px;
    
                    pointer-events: none;
    
                    z-index: 100000;
    
                    transition: all 0.1s ease;
    
                    box-shadow: 0 0 10px rgba(99, 102, 241, 0.3);
    
                }
    
            `;
    
            document.head.appendChild(style);
    
            
    
            // Create reading guide bar
    
            const readingGuideBar = document.createElement('div');
    
            readingGuideBar.id = 'reading-guide-bar';
    
            readingGuideBar.className = 'reading-guide-bar';
    
            document.body.appendChild(readingGuideBar);
    
            
    
            // Add mouse move event listener
    
            this.readingGuideMouseMoveHandler = (e) => {
    
                const x = e.clientX - 100; // Center the bar on cursor (half of 200px width)
    
                const y = e.clientY - 2; // Center vertically (half of 4px height)
    
                
    
                // Keep bar within viewport bounds
    
                const maxX = window.innerWidth - 200;
    
                const maxY = window.innerHeight - 4;
    
                const clampedX = Math.max(0, Math.min(x, maxX));
    
                const clampedY = Math.max(0, Math.min(y, maxY));
    
                
    
                readingGuideBar.style.left = clampedX + 'px';
    
                readingGuideBar.style.top = clampedY + 'px';
    
            };
    
            
    
            document.addEventListener('mousemove', this.readingGuideMouseMoveHandler);
    
            document.body.classList.add('reading-guide-active');
    
            
 
    
        }
    
    
    
        disableReadingGuide() {
    
          
    
            
    
            // Remove reading guide bar
    
            const readingGuideBar = document.getElementById('reading-guide-bar');
    
            if (readingGuideBar) {
    
                readingGuideBar.remove();
    
            }
    
            
    
            // Remove styles
    
            const style = document.getElementById('reading-guide-styles');
    
            if (style) {
    
                style.remove();
    
            }
    
            
    
            // Remove event listener
    
            if (this.readingGuideMouseMoveHandler) {
    
                document.removeEventListener('mousemove', this.readingGuideMouseMoveHandler);
    
                this.readingGuideMouseMoveHandler = null;
    
            }
    
            
    
            document.body.classList.remove('reading-guide-active');
    
    
        }



        // Highlight Focus Methods
    
        enableHighlightFocus() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#highlight-focus');
    
            if (toggle) {
    
                toggle.checked = true;
    
            }
    
            
    
            document.body.classList.add('highlight-focus');
    
       
    
            
    
            // Apply focus styles to currently focused element if any
    
            const activeElement = document.activeElement;
    
            if (activeElement && activeElement !== document.body && activeElement !== document.documentElement) {
    
                // Only apply to interactive elements
    
                const isInteractiveElement = activeElement.tagName === 'A' || 
    
                                          activeElement.tagName === 'BUTTON' || 
    
                                          activeElement.tagName === 'INPUT' || 
    
                                          activeElement.tagName === 'SELECT' || 
    
                                          activeElement.tagName === 'TEXTAREA' ||
    
                                          activeElement.hasAttribute('tabindex') ||
    
                                          activeElement.hasAttribute('role') ||
    
                                          activeElement.isContentEditable;
    
                
    
                // Apply to interactive elements not inside the panel (allow the icon itself)
    
                if (!activeElement.closest('.accessbit-widget-panel') && 
    
                    isInteractiveElement) {
    
         
    
                    activeElement.style.outline = '3px solid #6366f1';
    
                    activeElement.style.outlineOffset = '2px';
    
                    activeElement.style.background = 'rgba(99, 102, 241, 0.1)';
    
                    activeElement.style.borderRadius = '4px';
    
                    activeElement.style.transition = 'outline 0.2s ease, background 0.2s ease';
    
                    
    
                    // Track the currently focused element
    
                    this.currentlyFocusedElement = activeElement;
    
                }
    
            }
    
            
    
            // Add a global focus event listener to ensure immediate application of styles
    
            this.highlightFocusHandler = (e) => {
    
               
                // Special debugging for accessibility icon
                if (e.target.classList && e.target.classList.contains('accessbit-widget-icon')) {
                  
                    // Always apply focus styles to accessibility icon when focused
                    e.target.style.outline = '3px solid #6366f1';
                    e.target.style.outlineOffset = '2px';
                    e.target.style.background = 'rgba(99, 102, 241, 0.1)';
                    e.target.style.borderRadius = '4px';
                    e.target.style.transition = 'outline 0.2s ease, background 0.2s ease';
                    e.target.style.boxShadow = '0 0 0 3px rgba(99, 102, 241, 0.3)';
                    return; // Exit early to prevent other focus handling
                }
    
                if (document.body.classList.contains('highlight-focus')) {
    
                    const focusedElement = e.target;
    
                    
    
                    // Only apply to interactive elements that can actually receive focus
    
                    const isInteractiveElement = focusedElement.tagName === 'A' || 
    
                                              focusedElement.tagName === 'BUTTON' || 
    
                                              focusedElement.tagName === 'INPUT' || 
    
                                              focusedElement.tagName === 'SELECT' || 
    
                                              focusedElement.tagName === 'TEXTAREA' ||
    
                                              focusedElement.hasAttribute('tabindex') ||
    
                                              focusedElement.hasAttribute('role') ||
    
                                              focusedElement.isContentEditable;
    
                    
    
                    // Skip if element is not interactive or is part of accessibility panel (but allow accessibility icon)
    
                    if (focusedElement === document.body || 
    
                        focusedElement === document.documentElement ||
    
                        focusedElement.closest('.accessbit-widget-panel') ||
    
                        !isInteractiveElement) {
    
                        return;
    
                    }
    
                    
    
                    // Remove focus styles from previously focused element
    
                    if (this.currentlyFocusedElement && this.currentlyFocusedElement !== focusedElement) {
    
    
                        this.currentlyFocusedElement.style.outline = '';
    
                        this.currentlyFocusedElement.style.outlineOffset = '';
    
                        this.currentlyFocusedElement.style.background = '';
    
                        this.currentlyFocusedElement.style.borderRadius = '';
    
                        this.currentlyFocusedElement.style.transition = '';
    
                    }
    
                    
    
    
                    focusedElement.style.outline = '3px solid #6366f1';
    
                    focusedElement.style.outlineOffset = '2px';
    
                    focusedElement.style.background = 'rgba(99, 102, 241, 0.1)';
    
                    focusedElement.style.borderRadius = '4px';
    
                    focusedElement.style.transition = 'outline 0.2s ease, background 0.2s ease';
    
                    
    
                    // Track the currently focused element
    
                    this.currentlyFocusedElement = focusedElement;
    
                }
    
            };
    
            
    
            // Add the focus event listener
    
            document.addEventListener('focusin', this.highlightFocusHandler, true);
            
            // Add focusout handler to clean up accessibility icon styles
            this.highlightFocusOutHandler = (e) => {
                if (e.target.classList && e.target.classList.contains('accessbit-widget-icon')) {
                
                    e.target.style.outline = '';
                    e.target.style.outlineOffset = '';
                    e.target.style.background = '';
                    e.target.style.borderRadius = '';
                    e.target.style.transition = '';
                }
            };
            
            document.addEventListener('focusout', this.highlightFocusOutHandler, true);

    
            
    
            // Test if the feature is working by checking if we can find focusable elements
    
            const focusableElements = document.querySelectorAll('a, button, input, select, textarea, [tabindex], [role]');
    
            
    
            // Force a test focus on the first focusable element if any
    
            if (focusableElements.length > 0) {
    
     
    
            }
    
        }
    
    
    
        disableHighlightFocus() {
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#highlight-focus');
    
            if (toggle) {
    
                toggle.checked = false;
    
            }
    
            
    
            document.body.classList.remove('highlight-focus');
    
    
    
            
    
            // Remove focus styles from the currently tracked focused element
    
            if (this.currentlyFocusedElement) {
    
    
                this.currentlyFocusedElement.style.outline = '';
    
                this.currentlyFocusedElement.style.outlineOffset = '';
    
                this.currentlyFocusedElement.style.background = '';
    
                this.currentlyFocusedElement.style.borderRadius = '';
    
                this.currentlyFocusedElement.style.transition = '';
    
                this.currentlyFocusedElement = null;
    
            }
    
            
    
            // Also remove any remaining focus styles from all elements as a safety measure
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(element => {
    
                // Skip accessibility widget elements
    
                if (element.closest('.accessbit-widget-panel') || element.closest('#accessbit-widget-icon')) {
    
                    return;
    
                }
    
                
    
                // Remove focus-related inline styles
    
                if (element.style.outline && element.style.outline.includes('6366f1')) {
    
               
                    element.style.outline = '';
    
                    element.style.outlineOffset = '';
    
                    element.style.background = '';
    
                    element.style.borderRadius = '';
    
                    element.style.transition = '';
    
                }
    
            });
    
            
    
            // Remove the focus event listener
    
            if (this.highlightFocusHandler) {
    
                document.removeEventListener('focusin', this.highlightFocusHandler, true);
    
                this.highlightFocusHandler = null;
    
            }
            
            // Remove the focusout handler
            if (this.highlightFocusOutHandler) {
                document.removeEventListener('focusout', this.highlightFocusOutHandler, true);
                this.highlightFocusOutHandler = null;
            }
    
            
    
            // Also remove the CSS class from body to ensure complete cleanup
    
            document.body.classList.remove('highlight-focus');
    
        }
    
    
    
        showStatement() {
           
            // Check if we have a custom accessibility statement link
            if (this.customizationData && this.customizationData.accessibilityStatementLink) {
                
                // Validate the link before opening
                if (this.customizationData.accessibilityStatementLink.trim() !== '') {
                    window.open(this.customizationData.accessibilityStatementLink, '_blank');
                } else {
                 
            alert('This website is committed to providing an accessible experience for all users. We follow WCAG 2.1 guidelines and continuously work to improve accessibility.');
                }
            } else {
    
    
            }
        }
    
    
    
    
    
        enableReadableFont() {
            this.settings['readable-font'] = true;
            document.body.classList.add('readable-font');
            
            // DO NOT add readable-font class to widget - widget should keep its original font
            // Removed: this.shadowRoot.host.classList.add('readable-font');
            
            // Add CSS rules for readable font if not already added
            if (!document.getElementById('readable-font-css')) {
                const style = document.createElement('style');
                style.id = 'readable-font-css';
                style.textContent = `
                    /* READABLE FONT: ONLY change font-family, nothing else */
                    
                    /* 1. HEADINGS - Only font-family */
                    .readable-font h1,
                    .readable-font h2,
                    .readable-font h3,
                    .readable-font h4,
                    .readable-font h5,
                    .readable-font h6 {
                        font-family: 'Arial', 'Open Sans', 'Helvetica', sans-serif;
                    }
                    
                    /* 2. TEXT CONTENT - Only font-family */
                    .readable-font p,
                    .readable-font span:not([class*="icon"]):not([class*="symbol"]):not([class*="arrow"]),
                    .readable-font li,
                    .readable-font td,
                    .readable-font th,
                    .readable-font label,
                    .readable-font small,
                    .readable-font em,
                    .readable-font strong,
                    .readable-font b {
                        font-family: 'Arial', 'Open Sans', 'Helvetica', sans-serif;
                    }
                    
                    /* 3. LINKS - Only font-family */
                    .readable-font a:not([class*="icon"]):not([class*="symbol"]):not([class*="arrow"]):not([class*="slider"]):not([class*="carousel"]) {
                        font-family: 'Arial', 'Open Sans', 'Helvetica', sans-serif;
                    }
                    
                    /* 4. FORM ELEMENTS - Only font-family */
                    .readable-font input,
                    .readable-font textarea,
                    .readable-font select {
                        font-family: 'Arial', 'Open Sans', 'Helvetica', sans-serif;
                    }
                    
                    /* 5. BUTTON TEXT - Only font-family */
                    .readable-font button:not([class*="icon"]):not([class*="symbol"]):not([class*="arrow"]) {
                        font-family: 'Arial', 'Open Sans', 'Helvetica', sans-serif;
                    }
                    
                    /* EXCLUDE WIDGET - Never apply readable font to widget */
                    .readable-font .accessbit-widget,
                    .readable-font #accessbit-widget,
                    .readable-font .accessbit-widget-panel,
                    .readable-font .accessbit-widget-icon,
                    .readable-font [data-ck-widget],
                    .readable-font [class*="accessbit"],
                    .readable-font .accessbit-widget *,
                    .readable-font #accessbit-widget *,
                    .readable-font .accessbit-widget-panel * {
                        font-family: revert;
                    }
                    
                    /* EXCLUDE SLIDERS AND CAROUSELS - Never apply readable font to slider content */
                    .readable-font [class*="slider"],
                    .readable-font [class*="carousel"],
                    .readable-font [class*="swiper"],
                    .readable-font [data-slider],
                    .readable-font [data-carousel],
                    .readable-font [id*="slider"],
                    .readable-font [id*="carousel"],
                    .readable-font [id*="swiper"],
                    .readable-font [class*="slider"] *,
                    .readable-font [class*="carousel"] *,
                    .readable-font [class*="swiper"] *,
                    .readable-font [data-slider] *,
                    .readable-font [data-carousel] * {
                        font-family: revert;
                    }
                    
                    /* EXCLUDE ICONS AND SYMBOLS */
                    .readable-font i,
                    .readable-font [class*="icon"],
                    .readable-font [class*="symbol"],
                    .readable-font [class*="arrow"],
                    .readable-font [class*="fa-"],
                    .readable-font [class*="glyphicon"],
                    .readable-font [class*="material-icons"],
                    .readable-font .w-icon-dropdown-toggle,
                    .readable-font svg * {
                        font-family: initial;
                    }
                `;
                document.head.appendChild(style);
            }
            
            this.saveSettings();
         
        }
    
    
    
        disableReadableFont() {
            this.settings['readable-font'] = false;
            document.body.classList.remove('readable-font');
            
            // Widget never had readable-font class, so no need to remove it
            
            // Remove CSS rules for readable font
            const existingStyle = document.getElementById('readable-font-css');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            this.saveSettings();
          
        }
    
    
    
        // Text Alignment Methods
    
        enableAlignLeft() {
    
            // First, completely clear all alignment classes
            this.clearAllAlignmentClasses();
    
            this.settings['align-left'] = true;
    
            document.body.classList.add('align-left');
    
            // Also add to the widget host element
            if (this.shadowRoot && this.shadowRoot.host) {
                this.shadowRoot.host.classList.add('align-left');
            }
    
            this.saveSettings();
    
     
        }
    
    
    
        disableAlignLeft() {
    
            this.settings['align-left'] = false;
    
            document.body.classList.remove('align-left');
    
            // Also remove from the widget host element
    
            if (this.shadowRoot && this.shadowRoot.host) {
    
                this.shadowRoot.host.classList.remove('align-left');
    
            }
    
            this.saveSettings();
    
     
    
        }
    
    
    
        enableAlignCenter() {
    
            // First, completely clear all alignment classes
            this.clearAllAlignmentClasses();
    
            this.settings['align-center'] = true;
    
            document.body.classList.add('align-center');
    
            // Also add to the widget host element
            if (this.shadowRoot && this.shadowRoot.host) {
                this.shadowRoot.host.classList.add('align-center');
            }
    
            this.saveSettings();
    
    
    
        }
    
    
    
        disableAlignCenter() {
    
            this.settings['align-center'] = false;
    
            document.body.classList.remove('align-center');
    
            // Also remove from the widget host element
    
            if (this.shadowRoot && this.shadowRoot.host) {
    
                this.shadowRoot.host.classList.remove('align-center');
    
            }
    
            this.saveSettings();
    
   
    
        }
    
    
    
        enableAlignRight() {
    
            // First, completely clear all alignment classes
            this.clearAllAlignmentClasses();
    
            this.settings['align-right'] = true;
    
            document.body.classList.add('align-right');
    
            // Also add to the widget host element
            if (this.shadowRoot && this.shadowRoot.host) {
                this.shadowRoot.host.classList.add('align-right');
            }
    
            this.saveSettings();
    
    
        }
    
    
    
        disableAlignRight() {
    
            this.settings['align-right'] = false;
    
            document.body.classList.remove('align-right');
    
            // Also remove from the widget host element
            if (this.shadowRoot && this.shadowRoot.host) {
                this.shadowRoot.host.classList.remove('align-right');
            }
    
            this.saveSettings();
  
    
        }
    
        // Helper method to clear all alignment classes
        clearAllAlignmentClasses() {
            // Remove all alignment classes from body
            document.body.classList.remove('align-left', 'align-center', 'align-right');
            
            // Remove all alignment classes from widget host
            if (this.shadowRoot && this.shadowRoot.host) {
                this.shadowRoot.host.classList.remove('align-left', 'align-center', 'align-right');
            }
            
            // Reset all alignment settings
            this.settings['align-left'] = false;
            this.settings['align-center'] = false;
            this.settings['align-right'] = false;
            
 
        }
    
    
    
        // Big Black Cursor Methods
    
        enableBigBlackCursor() {
    

            
    
            // Disable white cursor first to avoid conflicts
    
            if (this.settings['big-white-cursor']) {
    
                document.body.classList.remove('big-white-cursor');
    
                this.settings['big-white-cursor'] = false;
    
                // Update toggle switch
    
                const whiteToggle = this.shadowRoot.getElementById('big-white-cursor');
    
                if (whiteToggle) whiteToggle.checked = false;
    
            }
    
            
    
            document.body.classList.add('big-black-cursor');
    
            this.applyBigBlackCursor();
    
            this.settings['big-black-cursor'] = true;
    
            this.saveSettings();
    
        }
    
        
    
        applyBigBlackCursor() {
            // Use black arrow cursor (32x32 base64)
            const arrowCursorUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAxMjAgMTIwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzPjxmaWx0ZXIgaWQ9InNoYWRvdy1ibGFjayIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSI+PGZlRHJvcFNoYWRvdyBkeD0iMiIgZHk9IjIiIHN0ZERldmlhdGlvbj0iMyIgZmxvb2RPcGFjaXR5PSIwLjMiLz48L2ZpbHRlcj48L2RlZnM+PHBhdGggZD0iTSAyMCAxMCBMIDIwIDgwIEwgNDAgNjAgTCA1MCA4NSBMIDU4IDgyIEwgNDggNTcgTCA3MCA1MCBaIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgZmlsdGVyPSJ1cmwoI3NoYWRvdy1ibGFjaykiLz48L3N2Zz4=';
            
            // Use black hand cursor for links/buttons (32x32 base64)
            const handCursorUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCA4MCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGZpbHRlciBpZD0ic2hhZG93LWhhbmQtYmxhY2siIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiPjxmZURyb3BTaGFkb3cgZHg9IjIiIGR5PSIyIiBzdGREZXZpYXRpb249IjMiIGZsb29kT3BhY2l0eT0iMC4zIi8+PC9maWx0ZXI+PC9kZWZzPjxwYXRoIGQ9Ik0gMjggOCBRIDI2IDggMjUgOSBRIDI0IDEwIDI0IDEyIEwgMjQgNDIgQyAyMiA0MCAyMCAzOCAxOCAzNyBDIDE2IDM2IDEzIDM2IDExIDM3LjUgQyA5IDM5IDguNSA0MSA5LjUgNDMgQyAxMC41IDQ1LjUgMTMgNDguNSAxNCA0OS41IEMgMTUgNTEgMTcuNSA1NiAxOS41IDU3LjUgQyAyMSA1OC44IDIyIDYyIDIyLjUgNjUgTCAyMi41IDY4IEwgNTIgNjggTCA1MiA2MyBDIDUyLjUgNjEuOCA1My41IDYwIDU0LjUgNTkgQyA1Ni41IDU3IDU3IDUzIDU3IDUxLjUgTCA1NyAzNiBRIDU3IDM0LjUgNTUuNSAzMyBDIDU0LjUgMzIgNTIuNSAzMS41IDUwIDMxLjMgQyA0OS44IDMxIDQ5LjUgMzAuNSA0OSAzMC4yIEMgNDcuNSAyOS4yIDQ1IDI4LjggNDIuNSAyOC43IEMgNDIuMyAyOC41IDQyIDI4LjIgNDEuNSAyNy45IEMgNDAgMjcgMzggMjYuNiAzNiAyNi41IEwgMzYgMTIgUSAzNiAxMCAzNSA5IFEgMzQgOCAzMiA4IFEgMzAgOCAyOCA4IFoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZmlsdGVyPSJ1cmwoI3NoYWRvdy1oYW5kLWJsYWNrKSIvPjwvc3ZnPg==';
            
            // Apply arrow cursor to body
            document.body.style.setProperty('cursor', `url('${arrowCursorUrl}') 20 10, auto`, 'important');
            
            // Apply arrow cursor to all elements first
            const allElements = document.querySelectorAll('*');
            allElements.forEach(el => {
                // Skip links and buttons - they'll get hand cursor
                if (!el.matches('a, button, [role="button"], [onclick], [tabindex]:not([tabindex="-1"]), input[type="button"], input[type="submit"], input[type="reset"], .btn, [class*="button"], [class*="link"]')) {
                    el.style.setProperty('cursor', `url('${arrowCursorUrl}') 20 10, auto`, 'important');
                }
            });
            
            // Apply hand cursor to links and buttons
            const interactiveElements = document.querySelectorAll('a, button, [role="button"], [onclick], [tabindex]:not([tabindex="-1"]), input[type="button"], input[type="submit"], input[type="reset"], .btn, [class*="button"], [class*="link"]');
            interactiveElements.forEach(el => {
                el.style.setProperty('cursor', `url('${handCursorUrl}') 24 10, pointer`, 'important');
            });
        }
    
    
    
        disableBigBlackCursor() {
    

            document.body.classList.remove('big-black-cursor');
    
            this.resetBigBlackCursor();
    
            this.settings['big-black-cursor'] = false;
    
            this.saveSettings();
    
            
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#big-black-cursor');
    
            if (toggle) {
    
                toggle.checked = false;
    
            }
    
            
    
            // Check if both cursor features are disabled and refresh page
    
            this.checkAndRefreshForCursorReset();
    
    
        }
    
        
    
        resetBigBlackCursor() {
    
            // Ensure the CSS class is removed from body
    
            document.body.classList.remove('big-black-cursor');
    
            
    
            // Also reset cursor on Shadow DOM host
    
            if (this.shadowRoot && this.shadowRoot.host) {
    
                this.shadowRoot.host.style.cursor = '';
    
            }
    
            
    
            // Force reset cursor on accessibility panel elements specifically
    
            const accessibilityElements = document.querySelectorAll('accessbit-widget, .accessbit-widget-panel, #accessbit-widget-icon');
    
            accessibilityElements.forEach(el => {
    
                el.style.cursor = 'auto';
    
            });
    
            
    
            // Force reset cursor on all elements to ensure no lingering styles
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(el => {
    
                if (el.style.cursor && el.style.cursor.includes('svg')) {
    
                    el.style.cursor = '';
    
                }
    
            });
    
       
    
        }
    
    
    
        // Big White Cursor Methods
    
        enableBigWhiteCursor() {

    
            
    
            // Disable black cursor first to avoid conflicts
    
            if (this.settings['big-black-cursor']) {
    
                document.body.classList.remove('big-black-cursor');
    
                this.settings['big-black-cursor'] = false;
    
                // Update toggle switch
    
                const blackToggle = this.shadowRoot.getElementById('big-black-cursor');
    
                if (blackToggle) blackToggle.checked = false;
    
            }
    
            
    
            document.body.classList.add('big-white-cursor');
    
            this.applyBigWhiteCursor();
    
            this.settings['big-white-cursor'] = true;
    
            this.saveSettings();
    
        }
    
        
    
        applyBigWhiteCursor() {
            // Use white arrow cursor (32x32 base64)
            const arrowCursorUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAxMjAgMTIwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzPjxmaWx0ZXIgaWQ9InNoYWRvdy13aGl0ZSIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSI+PGZlRHJvcFNoYWRvdyBkeD0iMiIgZHk9IjIiIHN0ZERldmlhdGlvbj0iMyIgZmxvb2RPcGFjaXR5PSIwLjUiLz48L2ZpbHRlcj48L2RlZnM+PHBhdGggZD0iTSAyMCAxMCBMIDIwIDgwIEwgNDAgNjAgTCA1MCA4NSBMIDU4IDgyIEwgNDggNTcgTCA3MCA1MCBaIiBmaWxsPSIjRkZGRkZGIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgZmlsdGVyPSJ1cmwoI3NoYWRvdy13aGl0ZSkiLz48L3N2Zz4=';
            
            // Use white hand cursor for links/buttons (32x32 base64)
            const handCursorUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCA4MCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGZpbHRlciBpZD0ic2hhZG93LWhhbmQtd2hpdGUiIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiPjxmZURyb3BTaGFkb3cgZHg9IjIiIGR5PSIyIiBzdGREZXZpYXRpb249IjMiIGZsb29kT3BhY2l0eT0iMC41Ii8+PC9maWx0ZXI+PC9kZWZzPjxwYXRoIGQ9Ik0gMjggOCBRIDI2IDggMjUgOSBRIDI0IDEwIDI0IDEyIEwgMjQgNDIgQyAyMiA0MCAyMCAzOCAxOCAzNyBDIDE2IDM2IDEzIDM2IDExIDM3LjUgQyA5IDM5IDguNSA0MSA5LjUgNDMgQyAxMC41IDQ1LjUgMTMgNDguNSAxNCA0OS41IEMgMTUgNTEgMTcuNSA1NiAxOS41IDU3LjUgQyAyMSA1OC44IDIyIDYyIDIyLjUgNjUgTCAyMi41IDY4IEwgNTIgNjggTCA1MiA2MyBDIDUyLjUgNjEuOCA1My41IDYwIDU0LjUgNTkgQyA1Ni41IDU3IDU3IDUzIDU3IDUxLjUgTCA1NyAzNiBRIDU3IDM0LjUgNTUuNSAzMyBDIDU0LjUgMzIgNTIuNSAzMS41IDUwIDMxLjMgQyA0OS44IDMxIDQ5LjUgMzAuNSA0OSAzMC4yIEMgNDcuNSAyOS4yIDQ1IDI4LjggNDIuNSAyOC43IEMgNDIuMyAyOC41IDQyIDI4LjIgNDEuNSAyNy45IEMgNDAgMjcgMzggMjYuNiAzNiAyNi41IEwgMzYgMTIgUSAzNiAxMCAzNSA5IFEgMzQgOCAzMiA4IFEgMzAgOCAyOCA4IFoiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZmlsdGVyPSJ1cmwoI3NoYWRvdy1oYW5kLXdoaXRlKSIvPjwvc3ZnPg==';
            
            // Apply arrow cursor to body
            document.body.style.setProperty('cursor', `url('${arrowCursorUrl}') 20 10, auto`, 'important');
            
            // Apply arrow cursor to all elements first
            const allElements = document.querySelectorAll('*');
            allElements.forEach(el => {
                // Skip links and buttons - they'll get hand cursor
                if (!el.matches('a, button, [role="button"], [onclick], [tabindex]:not([tabindex="-1"]), input[type="button"], input[type="submit"], input[type="reset"], .btn, [class*="button"], [class*="link"]')) {
                    el.style.setProperty('cursor', `url('${arrowCursorUrl}') 20 10, auto`, 'important');
                }
            });
            
            // Apply hand cursor to links and buttons
            const interactiveElements = document.querySelectorAll('a, button, [role="button"], [onclick], [tabindex]:not([tabindex="-1"]), input[type="button"], input[type="submit"], input[type="reset"], .btn, [class*="button"], [class*="link"]');
            interactiveElements.forEach(el => {
                el.style.setProperty('cursor', `url('${handCursorUrl}') 24 10, pointer`, 'important');
            });
        }
    
    
    
        disableBigWhiteCursor() {
    
          
    
            document.body.classList.remove('big-white-cursor');
    
            this.resetBigWhiteCursor();
    
            this.settings['big-white-cursor'] = false;
    
            this.saveSettings();
    
            
    
            // Update toggle state
    
            const toggle = this.shadowRoot.querySelector('#big-white-cursor');
    
            if (toggle) {
    
                toggle.checked = false;
    
            }
    
            
    
            // Check if both cursor features are disabled and refresh page
    
            this.checkAndRefreshForCursorReset();

    
        }
    
        
    
        resetBigWhiteCursor() {
    
            // Ensure the CSS class is removed from body
    
            document.body.classList.remove('big-white-cursor');
    
            
    
            // Force reset cursor on body and document element
    
            document.body.style.cursor = '';
    
            document.documentElement.style.cursor = '';
    
            
    
            // Also reset cursor on Shadow DOM host
    
            if (this.shadowRoot && this.shadowRoot.host) {
    
                this.shadowRoot.host.style.cursor = '';
    
            }
    
            
    
            // Force reset cursor on accessibility panel elements specifically
    
            const accessibilityElements = document.querySelectorAll('accessbit-widget, .accessbit-widget-panel, #accessbit-widget-icon');
    
            accessibilityElements.forEach(el => {
    
                el.style.cursor = 'auto';
    
            });
    
            
    
            // Force reset cursor on all elements to ensure no lingering styles
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(el => {
    
                if (el.style.cursor && (el.style.cursor.includes('svg') || el.style.cursor.includes('white'))) {
    
                    el.style.cursor = '';
    
                }
    
            });
    
            
    
            // Add a temporary CSS rule to override any remaining cursor styles
    
            const style = document.createElement('style');
    
            style.id = 'reset-cursor-styles';
    
            style.textContent = `
    
                /* Only apply auto cursor when big cursors are NOT active */
                body:not(.big-white-cursor):not(.big-black-cursor) .accessbit-widget-panel *,
                body:not(.big-white-cursor):not(.big-black-cursor) .accessbit-widget *,
                body:not(.big-white-cursor):not(.big-black-cursor) #accessbit-widget * {
    
                    cursor: auto !important;
    
                }
    
            `;
    
            document.head.appendChild(style);
    
            
    
            // Remove the temporary style after a short delay
    
            setTimeout(() => {
    
                const tempStyle = document.getElementById('reset-cursor-styles');
    
                if (tempStyle) {
    
                    tempStyle.remove();
    
                }
    
            }, 2000);
    
            
    
            // Additional comprehensive cursor reset
    
            this.forceResetAllCursors();
    
        }
    
        
    
        forceResetAllCursors() {
    
            // Reset cursor on all elements in the document
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(el => {
    
                if (el.style.cursor) {
    
                    el.style.cursor = '';
    
                }
    
            });
    
            
    
            // Reset cursor on Shadow DOM elements
    
            if (this.shadowRoot) {
    
                const shadowElements = this.shadowRoot.querySelectorAll('*');
    
                shadowElements.forEach(el => {
    
                    el.style.cursor = '';
    
                });
    
            }
    
            
    
            // Force normal cursor on body and document
    
            document.body.style.cursor = '';
    
            document.documentElement.style.cursor = '';
    
        }
    
        
    
        checkAndRefreshForCursorReset() {
    
            // Check if both cursor features are disabled
    
            const blackCursorDisabled = !this.settings['big-black-cursor'];
    
            const whiteCursorDisabled = !this.settings['big-white-cursor'];
    
            
    
            if (blackCursorDisabled && whiteCursorDisabled) {
    
                // Refresh the page immediately without showing any message
    
                window.location.reload();
    
            }
    
        }
    
        
    
        showTemporaryMessage(message, duration = 2000) {
    
            // Create a temporary message element
    
            const messageEl = document.createElement('div');
    
            messageEl.style.cssText = `
    
                position: fixed;
    
                top: 50%;
    
                left: 50%;
    
                transform: translate(-50%, -50%);
    
                background: rgba(0, 0, 0, 0.8);
    
                color: white;
    
                padding: 15px 12px;
    
                border-radius: 8px;
    
                font-family: 'DM Sans', sans-serif;
    
                font-size: 14px;
    
                z-index: 2147483645;
    
                pointer-events: none;
    
            `;
    
            messageEl.textContent = message;
    
            document.body.appendChild(messageEl);
    
            
    
            // Remove the message after the specified duration
    
            setTimeout(() => {
    
                if (messageEl.parentNode) {
    
                    messageEl.parentNode.removeChild(messageEl);
    
                }
    
            }, duration);
    
        }
    
        // Stop Animation Methods
    
        // --- STOP ANIMATION (photosensitive: no visual overlay) ---
        enableStopAnimation() {
            document.body.classList.add('stop-animation');
            document.documentElement.classList.add('stop-animation');
            this.settings['stop-animation'] = true;
            this.saveSettings();
            
            // CSS kill switch (no global overrides)
            this.injectStopAnimationCSS();

            // WAAPI pause/cancel running animations (allowed)
            try { window.seizureState?.applyWAAPIStopMotion?.(true); } catch (_) {}
            
            // Library APIs + polling (official APIs only)
            this.stopAnimationLibraries();
            this.startLottieGSAPPolling();

            // Stop autoplay media and JS-driven sliders (e.g., Swiper/Webflow)
            this.stopAutoplayMedia();
            this.stopJavaScriptAnimations();

            // Stop Webflow interactions / data-w-id transforms and hovers
            try { this.stopWebflowInteractions && this.stopWebflowInteractions(); } catch (_) {}
            
            // Start aggressive periodic animation stopping (no global overrides)
            this.startAggressiveAnimationStopping();
        }
        
        // 1. CSS Injection: Stop all CSS animations, transitions, and blinking text
        injectStopAnimationCSS() {
            if (document.getElementById('stop-animation-css')) return;
            const style = document.createElement('style');
            style.id = 'stop-animation-css';
            style.textContent = `
                /* Respect user/system reduce motion */
                @media (prefers-reduced-motion: reduce) {
                    *, *::before, *::after {
                        animation: none !important;
                        transition: none !important;
                        scroll-behavior: auto !important;
                    }
                }
                /* Explicit stop-animation toggle */
                html.stop-animation *, html.stop-animation *::before, html.stop-animation *::after,
                body.stop-animation *, body.stop-animation *::before, body.stop-animation *::after,
                .stop-animation *, .stop-animation *::before, .stop-animation *::after {
                    animation: none !important;
                    transition: none !important;
                    scroll-behavior: auto !important;
                    animation-play-state: paused !important;
                }
                /* Remove common flash triggers */
                html.stop-animation *[class*="blink"], html.stop-animation *[class*="shimmer"], 
                html.stop-animation *[class*="pulse"], html.stop-animation *[class*="caret"], 
                html.stop-animation *[class*="cursor-blink"], html.stop-animation *[class*="skeleton"],
                html.stop-animation *[class*="pulsing"], html.stop-animation *[class*="flashing"],
                body.stop-animation *[class*="blink"], body.stop-animation *[class*="shimmer"], 
                body.stop-animation *[class*="pulse"], body.stop-animation *[class*="caret"], 
                body.stop-animation *[class*="cursor-blink"], body.stop-animation *[class*="skeleton"],
                body.stop-animation *[class*="pulsing"], body.stop-animation *[class*="flashing"] {
                    animation: none !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                }

                /* Stop Webflow interactions (data-w-id) */
                html.stop-animation [data-w-id],
                body.stop-animation [data-w-id],
                .stop-animation [data-w-id] {
                    animation: none !important;
                    transition: none !important;
                    transform: none !important;
                    opacity: 1 !important;
                }

                /* Stop transforms on buttons/links (but allow hover animations) */
                html.stop-animation a, html.stop-animation button, html.stop-animation [role="button"],
                body.stop-animation a, body.stop-animation button, body.stop-animation [role="button"],
                .stop-animation a, .stop-animation button, .stop-animation [role="button"] {
                    transition: none !important;
                    transform: none !important;
                }
            `;
            document.head.appendChild(style);
        }
        
        
        stopDOMAnimationLoops() {
            
        }
        
        
        stopAutoplayMedia() {
            // Pause all currently playing videos and remove autoplay
            document.querySelectorAll('video').forEach(video => {
                try {
                    // Pause if playing
                    if (!video.paused) {
                        video.pause();
                    }
                    // Remove autoplay attribute to prevent future autoplay
                    video.removeAttribute('autoplay');
                    video.setAttribute('data-autoplay-disabled', 'true');
                    // Prevent autoplay via JavaScript
                    if (video.autoplay !== undefined) {
                        video.autoplay = false;
                    }
                    // Stop any looping
                    video.loop = false;
                } catch (_) {}
            });
            
            // Pause all currently playing audio and remove autoplay
            document.querySelectorAll('audio').forEach(audio => {
                try {
                    // Pause if playing
                    if (!audio.paused) {
                        audio.pause();
                    }
                    // Remove autoplay attribute to prevent future autoplay
                    audio.removeAttribute('autoplay');
                    audio.setAttribute('data-autoplay-disabled', 'true');
                    // Prevent autoplay via JavaScript
                    if (audio.autoplay !== undefined) {
                        audio.autoplay = false;
                    }
                    // Stop any looping
                    audio.loop = false;
                } catch (_) {}
            });
            
            // Handle embedded media (YouTube, Vimeo, etc.)
            document.querySelectorAll('iframe[src*="youtube"], iframe[src*="vimeo"], iframe[src*="dailymotion"], iframe[src*="youtube-nocookie"]').forEach(iframe => {
                try {
                    // Security: Validate URL before manipulation to prevent XSS
                    const src = iframe.src;
                    if (!src || typeof src !== 'string') return;
                    
                    // Validate URL format and allowed domains
                    let isValidUrl = false;
                    try {
                        const url = new URL(src);
                        const allowedDomains = ['youtube.com', 'youtu.be', 'vimeo.com', 'dailymotion.com', 'player.vimeo.com', 'youtube-nocookie.com'];
                        isValidUrl = allowedDomains.some(domain => url.hostname.includes(domain));
                    } catch {
                        // If URL parsing fails, skip modification
                        return;
                    }
                    
                    if (!isValidUrl) return;
                    
                    // Mark as disabled to prevent re-processing
                    if (iframe.hasAttribute('data-autoplay-disabled')) return;
                    
                    // Try to pause embedded videos by modifying src
                    let newSrc = src;
                    if (src.includes('autoplay=1')) {
                        newSrc = src.replace('autoplay=1', 'autoplay=0');
                    } else if (src.includes('autoplay=true')) {
                        newSrc = src.replace('autoplay=true', 'autoplay=false');
                    } else if (!src.includes('autoplay=')) {
                        const separator = src.includes('?') ? '&' : '?';
                        newSrc = src + separator + 'autoplay=0';
                    }
                    
                    // Also remove loop if present
                    if (newSrc.includes('loop=1')) {
                        newSrc = newSrc.replace('loop=1', 'loop=0');
                    } else if (newSrc.includes('loop=true')) {
                        newSrc = newSrc.replace('loop=true', 'loop=false');
                    }
                    
                    // Double-check the new URL is still valid
                    try {
                        new URL(newSrc);
                        iframe.src = newSrc;
                        iframe.setAttribute('data-autoplay-disabled', 'true');
                    } catch {
                        // Invalid URL, skip
                    }
                } catch (e) {
                  
                }
            });
            
            // Stop any elements with autoplay attribute
            document.querySelectorAll('[autoplay], [data-autoplay], [class*="autoplay"]').forEach(el => {
                try {
                    el.removeAttribute('autoplay');
                    el.removeAttribute('data-autoplay');
                    el.setAttribute('data-autoplay-disabled', 'true');
                    // If it's a video or audio element, pause it
                    if (el.tagName === 'VIDEO' || el.tagName === 'AUDIO') {
                        if (!el.paused) {
                            el.pause();
                        }
                        if (el.autoplay !== undefined) {
                            el.autoplay = false;
                        }
                    }
                } catch (_) {}
            });
        }
        
        // 7. Stop any JavaScript-based animations (like the slider auto-slide)
        // Comprehensive slider autoplay stopping function
        stopSliderAutoplay() {
            try {
                // Method 1: Generic window.slider API
                if (window.slider && typeof window.slider.disableAutoSlide === 'function') {
                    try {
                        window.slider.disableAutoSlide();
                    } catch (_) {}
                }
                
                // Method 2: Swiper.js (most common slider library)
                if (typeof Swiper !== 'undefined') {
                    try {
                        document.querySelectorAll('.swiper, [class*="swiper"]').forEach(swiperEl => {
                            try {
                                if (swiperEl.swiper) {
                                    // Stop autoplay
                                    if (swiperEl.swiper.autoplay) {
                                        if (typeof swiperEl.swiper.autoplay.stop === 'function') {
                                            swiperEl.swiper.autoplay.stop();
                                        }
                                        if (swiperEl.swiper.autoplay.paused !== undefined) {
                                            swiperEl.swiper.autoplay.paused = true;
                                        }
                                    }
                                    // Disable navigation
                                    if (swiperEl.swiper.allowTouchMove !== undefined) {
                                        swiperEl.swiper.allowTouchMove = false;
                                    }
                                    if (swiperEl.swiper.allowSlideNext !== undefined) {
                                        swiperEl.swiper.allowSlideNext = false;
                                    }
                                    if (swiperEl.swiper.allowSlidePrev !== undefined) {
                                        swiperEl.swiper.allowSlidePrev = false;
                                    }
                                    // Stop any running transitions
                                    if (swiperEl.swiper.setTransition) {
                                        swiperEl.swiper.setTransition(0);
                                    }
                                }
                            } catch (_) {}
                        });
                    } catch (_) {}
                }
                
                // Method 3: Webflow sliders (data-w-id based)
                try {
                    const webflowSliders = document.querySelectorAll('[data-w-id][class*="slider"], [data-w-id][class*="carousel"], .w-slider');
                    webflowSliders.forEach(slider => {
                        try {
                            // Stop any GSAP animations on slider
                            if (window.gsap && window.gsap.killTweensOf) {
                                window.gsap.killTweensOf(slider);
                            }
                            // Stop CSS animations
                            slider.style.animation = 'none';
                            slider.style.transition = 'none';
                            // Stop any autoplay intervals
                            if (slider._autoplayInterval) {
                                clearInterval(slider._autoplayInterval);
                                slider._autoplayInterval = null;
                            }
                        } catch (_) {}
                    });
                } catch (_) {}
                
                // Method 4: Generic slider detection (look for common slider patterns)
                try {
                    const possibleSliders = document.querySelectorAll('[class*="slider"], [class*="carousel"], [id*="slider"], [id*="carousel"]');
                    possibleSliders.forEach(slider => {
                        try {
                            // Stop any intervals/timeouts
                            if (slider._autoplayInterval) {
                                clearInterval(slider._autoplayInterval);
                                slider._autoplayInterval = null;
                            }
                            if (slider._autoplayTimeout) {
                                clearTimeout(slider._autoplayTimeout);
                                slider._autoplayTimeout = null;
                            }
                            // Stop CSS animations
                            slider.style.animation = 'none';
                            slider.style.transition = 'none';
                            // Stop GSAP animations
                            if (window.gsap && window.gsap.killTweensOf) {
                                window.gsap.killTweensOf(slider);
                            }
                        } catch (_) {}
                    });
                } catch (_) {}
                
                // Method 5: Stop any setInterval/setTimeout that might be running slider autoplay
                // This is a fallback - we can't directly access all intervals, but we can stop animations
                try {
                    // Look for elements with data-autoplay or autoplay attributes
                    const autoplayElements = document.querySelectorAll('[data-autoplay], [autoplay], [class*="autoplay"]');
                    autoplayElements.forEach(el => {
                        try {
                            if (el._autoplayInterval) {
                                clearInterval(el._autoplayInterval);
                                el._autoplayInterval = null;
                            }
                            el.style.animation = 'none';
                            el.style.transition = 'none';
                        } catch (_) {}
                    });
                } catch (_) {}
            } catch (_) {}
        }
        
        stopJavaScriptAnimations() {
            // Stop slider animations (now using dedicated function)
            this.stopSliderAutoplay();
            
            // Stop Swiper animations (also handled in stopSliderAutoplay, but keeping for compatibility)
            if (typeof Swiper !== 'undefined') {
                try {
                    document.querySelectorAll('.swiper').forEach(swiperEl => {
                        if (swiperEl.swiper) {
                            try {
                                swiperEl.swiper.autoplay?.stop();
                                swiperEl.swiper.allowTouchMove = false;
                                swiperEl.swiper.allowSlideNext = false;
                                swiperEl.swiper.allowSlidePrev = false;
                            } catch (_) {}
                        }
                    });
                } catch (e) {}
            }
            
            // Stop AOS (Animate On Scroll) animations
            if (typeof AOS !== 'undefined') {
                try {
                    AOS.refreshHard();
                    AOS.disable();
                } catch (e) {}
            }
            
            // Stop GSAP animations (more comprehensive)
            if (typeof window.gsap !== 'undefined') {
                try {
                    // Kill all GSAP animations
                    window.gsap.globalTimeline?.clear();
                    if (window.gsap.killTweensOf) {
                        window.gsap.killTweensOf('*');
                    }
                    // Stop all timelines
                    if (window.gsap.getAllTimelines) {
                        window.gsap.getAllTimelines().forEach(timeline => {
                            try {
                                timeline.pause();
                                timeline.kill();
                            } catch (_) {}
                        });
                    }
                } catch (e) {}
            }
            
            // Stop jQuery animations
            if (typeof window.jQuery !== 'undefined' || typeof window.$ !== 'undefined') {
                try {
                    const $ = window.jQuery || window.$;
                    $('*').stop(true, true);
                    $('*').finish();
                } catch (e) {}
            }
            
            // Stop Three.js animations
            if (typeof window.THREE !== 'undefined') {
                try {
                    // Find all Three.js scenes and stop their render loops
                    document.querySelectorAll('canvas').forEach(canvas => {
                        if (canvas._threeScene || canvas._threeRenderer) {
                            try {
                                if (canvas._threeAnimationId) {
                                    cancelAnimationFrame(canvas._threeAnimationId);
                                }
                            } catch (_) {}
                        }
                    });
                } catch (e) {}
            }
            
            // Stop Framer Motion animations (React-based)
            if (typeof window.FramerMotion !== 'undefined') {
                try {
                    // Framer Motion uses React, so we'll stop via CSS
                    document.querySelectorAll('[data-framer-name]').forEach(el => {
                        el.style.animation = 'none';
                        el.style.transition = 'none';
                    });
                } catch (e) {}
            }
            
            // Stop Webflow interactions more aggressively
            try {
                // Stop all Webflow interactions
                document.querySelectorAll('[data-w-id]').forEach(el => {
                    el.style.animation = 'none';
                    el.style.transition = 'none';
                    el.style.transform = 'none';
                    el.style.opacity = '1';
                });
                
                // Stop Webflow CMS animations
                document.querySelectorAll('[data-w-id*="cms"]').forEach(el => {
                    el.style.animation = 'none';
                    el.style.transition = 'none';
                });
            } catch (e) {}
            
            // Stop all CSS animations on ALL elements directly (most aggressive approach)
            try {
                const allElements = document.querySelectorAll('*');
                allElements.forEach(el => {
                    try {
                        // Skip widget elements
                        if (el.id && el.id.includes('accessbit')) return;
                        if (el.classList && (el.classList.contains('accessbit-widget') || el.closest('.accessbit-widget'))) return;
                        
                        // Direct style manipulation - no global overrides
                        const computedStyle = window.getComputedStyle(el);
                        if (computedStyle.animationName !== 'none' || computedStyle.transitionProperty !== 'none') {
                            el.style.setProperty('animation', 'none', 'important');
                            el.style.setProperty('transition', 'none', 'important');
                            el.style.setProperty('animation-play-state', 'paused', 'important');
                        }
                    } catch (_) {}
                });
            } catch (e) {}
            
            // Stop canvas animations (requestAnimationFrame-based)
            this.stopCanvasAnimations();
            
            // Stop SVG animations (SMIL and CSS)
            this.stopSVGAnimations();
        }
        
        // Stop canvas-based animations by finding canvas elements and stopping their animation loops
        stopCanvasAnimations() {
            try {
                const canvases = document.querySelectorAll('canvas');
                canvases.forEach(canvas => {
                    try {
                        // Stop CSS animations on canvas with !important
                        canvas.style.setProperty('animation', 'none', 'important');
                        canvas.style.setProperty('transition', 'none', 'important');
                        canvas.style.setProperty('animation-play-state', 'paused', 'important');
                        
                        // Mark canvas for stopping
                        canvas.setAttribute('data-seizure-safe-stopped', 'true');
                        
                        // Try to stop animation loops stored in various properties
                        const animationIdProps = ['_animationId', '_animationFrameId', '_rafId', '_loopId', 'animationId', 'rafId'];
                        animationIdProps.forEach(prop => {
                            if (canvas[prop]) {
                                try {
                                    cancelAnimationFrame(canvas[prop]);
                                    canvas[prop] = null;
                                } catch (_) {}
                            }
                        });
                        
                        // Stop Three.js render loops if present
                        if (canvas._threeAnimationId) {
                            try {
                                cancelAnimationFrame(canvas._threeAnimationId);
                                canvas._threeAnimationId = null;
                            } catch (_) {}
                        }
                        
                        // Stop p5.js animations if present
                        if (canvas._pInst && canvas._pInst._loop) {
                            try {
                                canvas._pInst.noLoop();
                            } catch (_) {}
                        }
                    } catch (_) {}
                });
            } catch (_) {}
        }
        
        // Stop SVG animations (SMIL animations and CSS animations on SVG elements)
        stopSVGAnimations() {
            try {
                const svgs = document.querySelectorAll('svg');
                svgs.forEach(svg => {
                    try {
                        // Stop CSS animations on SVG
                        svg.style.animation = 'none';
                        svg.style.transition = 'none';
                        
                        // Stop SMIL animations (animate, animateTransform, animateMotion)
                        const smilAnimations = svg.querySelectorAll('animate, animateTransform, animateMotion, set');
                        smilAnimations.forEach(anim => {
                            try {
                                // Pause SMIL animations
                                if (anim.pauseAnimations) {
                                    anim.pauseAnimations();
                                }
                                // Set end time to current time to finish animation
                                if (anim.setAttribute) {
                                    const begin = anim.getAttribute('begin');
                                    const dur = anim.getAttribute('dur');
                                    if (begin && dur) {
                                        // Calculate end time and set to finish
                                        try {
                                            const beginTime = parseFloat(begin) || 0;
                                            const duration = parseFloat(dur) || 0;
                                            anim.setAttribute('dur', '0s'); // Stop immediately
                                        } catch (_) {}
                                    }
                                }
                            } catch (_) {}
                        });
                        
                        // Mark as stopped
                        svg.setAttribute('data-seizure-safe-stopped', 'true');
                    } catch (_) {}
                });
            } catch (_) {}
        }
        
        enableReduceMotion() {
            // Per Webflow Security recommendations: Add explicit in-product "Reduce Motion" toggle
            // This is different from "Seizure Safe" - it only disables animations/transitions without color filters
            document.body.classList.add('reduce-motion');
            document.documentElement.classList.add('reduce-motion');
            this.settings['reduce-motion'] = true;
            this.saveSettings();
            
            // Apply global CSS kill switch
            this.injectReduceMotionCSS();
            
            // Use WAAPI to pause/cancel running animations
            this.applyWAAPIReduceMotion(true);
        }
        
        disableReduceMotion() {
            // Remove CSS rules
            const existingStyle = document.getElementById('reduce-motion-css');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            // Remove reduce-motion class
            document.body.classList.remove('reduce-motion');
            document.documentElement.classList.remove('reduce-motion');
            
            // Restore WAAPI animations
            this.applyWAAPIReduceMotion(false);
            
            this.settings['reduce-motion'] = false;
            this.saveSettings();
        }
        
        injectReduceMotionCSS() {
            if (!document.getElementById('reduce-motion-css')) {
                const style = document.createElement('style');
                style.id = 'reduce-motion-css';
                style.textContent = `
                    /* Per Webflow Security recommendations: Global CSS kill switch for Reduce Motion */
                    /* This provides stricter controls than prefers-reduced-motion for users who need it */
                    html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]),
                    html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::before,
                    html.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::after,
                    body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]),
                    body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::before,
                    body.reduce-motion *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget])::after {
                        animation: none !important;
                        transition: none !important;
                        scroll-behavior: auto !important;
                    }
                    
                    /* Remove common flash triggers (blinking caret effects, shimmer skeletons, pulsing outlines, etc.) */
                    body.reduce-motion *[class*="blink"], body.reduce-motion *[class*="shimmer"], 
                    body.reduce-motion *[class*="pulse"], body.reduce-motion *[class*="caret"], 
                    body.reduce-motion *[class*="cursor-blink"], body.reduce-motion *[class*="skeleton"],
                    body.reduce-motion *[class*="pulsing"], body.reduce-motion *[class*="flashing"],
                    html.reduce-motion *[class*="blink"], html.reduce-motion *[class*="shimmer"], 
                    html.reduce-motion *[class*="pulse"], html.reduce-motion *[class*="caret"], 
                    html.reduce-motion *[class*="cursor-blink"], html.reduce-motion *[class*="skeleton"],
                    html.reduce-motion *[class*="pulsing"], html.reduce-motion *[class*="flashing"] {
                        animation: none !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                    }
                    
                    /* Remove blinking caret effects */
                    body.reduce-motion input[type="text"], body.reduce-motion input[type="email"], 
                    body.reduce-motion input[type="search"], body.reduce-motion input[type="tel"], 
                    body.reduce-motion input[type="url"], body.reduce-motion input[type="password"], 
                    body.reduce-motion textarea, body.reduce-motion [contenteditable="true"],
                    html.reduce-motion input[type="text"], html.reduce-motion input[type="email"], 
                    html.reduce-motion input[type="search"], html.reduce-motion input[type="tel"], 
                    html.reduce-motion input[type="url"], html.reduce-motion input[type="password"], 
                    html.reduce-motion textarea, html.reduce-motion [contenteditable="true"] {
                        caret-color: transparent !important;
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        applyWAAPIReduceMotion(enabled) {
            // Use WAAPI controls where we own the animations
            // Per Webflow Security recommendations: Use WAAPI for explicit control
            try {
                if (enabled) {
                    const all = (document.getAnimations && document.getAnimations({ subtree: true })) || [];
                    all.forEach(anim => {
                        try {
                            if (typeof anim.pause === 'function') {
                                anim.pause();
                            }
                            if (typeof anim.playbackRate !== 'undefined') {
                                anim.playbackRate = 0;
                            }
                        } catch (_) {}
                    });
                } else {
                    // Restore animations when disabled
                    const all = (document.getAnimations && document.getAnimations({ subtree: true })) || [];
                    all.forEach(anim => {
                        try {
                            if (typeof anim.playbackRate !== 'undefined') {
                                anim.playbackRate = 1;
                            }
                            if (typeof anim.play === 'function' && anim.playState === 'paused') {
                                anim.play();
                            }
                        } catch (_) {}
                    });
                }
            } catch (_) {}
        }
        
        disableStopAnimation() {
            const existingStyle = document.getElementById('stop-animation-css');
            if (existingStyle) existingStyle.remove();
            document.body.classList.remove('stop-animation');
            document.documentElement.classList.remove('stop-animation');
            this.stopLottieGSAPPolling();
            // Stop aggressive animation stopping
            this.stopAggressiveAnimationStopping();
            try { window.seizureState?.applyWAAPIStopMotion?.(false); } catch (_) {}
            this.settings['stop-animation'] = false;
            this.saveSettings();
        }
        
       
        restoreDOMAnimationLoops() {
            // No restoration needed - we never overwrite setTimeout/setInterval
            // Animation stopping is handled via CSS classes and WAAPI controls
        }
        
        // Restore animated media
        restoreAnimatedMedia() {
            // Restore animated GIFs
            document.querySelectorAll('img[data-original-src]').forEach(img => {
                if (img.dataset.originalSrc) {
                    img.src = img.dataset.originalSrc;
                    delete img.dataset.originalSrc;
                }
            });
            
        }
        
        // Restore JavaScript animations
        restoreJavaScriptAnimations() {
            // Restore slider animations
            if (window.slider && typeof window.slider.enableAutoSlide === 'function') {
                try {
                    window.slider.enableAutoSlide();
                   
                } catch (e) {
                
                }
            }
            
            // Restore Swiper animations
            if (typeof Swiper !== 'undefined') {
                try {
                    document.querySelectorAll('.swiper').forEach(swiperEl => {
                        if (swiperEl.swiper && swiperEl.swiper.autoplay) {
                            swiperEl.swiper.autoplay.start();
                        }
                    });
                  
                } catch (e) {
                  
                }
            }
            
            // Restore AOS animations
            if (typeof AOS !== 'undefined') {
                try {
                    AOS.refresh();
               
                } catch (e) {
               
                }
            }
        }
    
    
    
        // Text Color Adjustment Methods
    
        showTextColorPicker() {
    
    
            this.hideTextColorPicker();
    
    
            
    
            // Add CSS rules for stop animation if not already added
    
            if (!document.getElementById('stop-animation-css')) {
    
                const style = document.createElement('style');
    
                style.id = 'stop-animation-css';
    
                style.textContent = `
    
                    .stop-animation *,
    
                    .stop-animation *::before,
    
                    .stop-animation *::after {
    
                        animation-duration: 0.01ms !important;
    
                        animation-iteration-count: 1 !important;
    
                        animation-delay: 0s !important;
    
                        transition-duration: 0.01ms !important;
    
                        /* REMOVED: scroll-behavior: auto !important; - This was blocking website scroll animations */
    
                    }
    
                    
    
                    .stop-animation * {
    
                        animation-play-state: paused !important;
    
                    }
                    
                    /* ULTIMATE CATCH-ALL: Force ALL elements to final state */
                    .stop-animation *,
                    .stop-animation *::before,
                    .stop-animation *::after {
                        animation: none !important;
                        transition: none !important;
                        /* animation-fill-mode: forwards !important; - REMOVED: This was causing elements to snap to final positions and interfere with scrolling */
                        animation-play-state: paused !important;
                    }
                    
                    /* CRITICAL: Ensure elements maintain original positions and sizes - Conservative approach */
                    .stop-animation * {
                        /* Only ensure visibility, don't reset transforms globally */
                        opacity: 1 !important;
                        visibility: visible !important;
                    }
                    
                    /* Only reset transform properties for animated elements - don't touch positioning */
                    .stop-animation *[class*="animate"],
                    .stop-animation *[class*="fade"],
                    .stop-animation *[class*="slide"],
                    .stop-animation *[class*="bounce"],
                    .stop-animation *[class*="pulse"],
                    .stop-animation *[class*="shake"],
                    .stop-animation *[class*="flash"],
                    .stop-animation *[class*="blink"],
                    .stop-animation *[class*="glow"],
                    .stop-animation *[class*="spin"],
                    .stop-animation *[class*="rotate"],
                    .stop-animation *[class*="scale"],
                    .stop-animation *[class*="zoom"],
                    .stop-animation *[class*="wiggle"],
                    .stop-animation *[class*="jiggle"],
                    .stop-animation *[class*="twist"],
                    .stop-animation *[class*="flip"],
                    .stop-animation *[class*="swing"],
                    .stop-animation *[class*="wobble"],
                    .stop-animation *[class*="tilt"] {
                        /* Only reset transform properties, preserve positioning */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* translate: none !important; - REMOVED: This was breaking website layout */
                        /* scale: 1 !important; - REMOVED: This was breaking website layout */
                        /* rotate: 0deg !important; - REMOVED: This was breaking website layout */
                        animation: none !important;
                        transition: none !important;
                        /* animation-fill-mode: forwards !important; - REMOVED: This was causing elements to snap to final positions and interfere with scrolling */
                        animation-play-state: paused !important;
                    }

                    /* Ensure interactive elements still show pointer cursor in stop-animation mode */
                    .stop-animation a[href],
                    .stop-animation button,
                    .stop-animation [role="button"],
                    .stop-animation [onclick],
                    .stop-animation input[type="button"],
                    .stop-animation input[type="submit"],
                    .stop-animation input[type="reset"],
                    .stop-animation .btn,
                    .stop-animation .button,
                    .stop-animation [class*="btn"],
                    .stop-animation [class*="button"],
                    .stop-animation [tabindex]:not([tabindex="-1"]) {
                        cursor: pointer !important;
                    }
                    /* Keep text cursor for text-editable fields */
                    .stop-animation input[type="text"],
                    .stop-animation input[type="email"],
                    .stop-animation input[type="search"],
                    .stop-animation input[type="tel"],
                    .stop-animation input[type="url"],
                    .stop-animation input[type="password"],
                    .stop-animation textarea,
                    .stop-animation [contenteditable="true"] {
                        cursor: text !important;
                    }
                    
                    /* Preserve original layout for specific elements */
                    .stop-animation img,
                    .stop-animation video,
                    .stop-animation audio,
                    .stop-animation iframe,
                    .stop-animation embed,
                    .stop-animation object {
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* width: auto !important; - REMOVED: This was breaking website layout */
                        /* height: auto !important; - REMOVED: This was breaking website layout */
                        max-width: 100% !important;
                        max-height: 100% !important;
                    }
                    
                    /* Ensure text elements maintain original layout */
                    .stop-animation h1,
                    .stop-animation h2,
                    .stop-animation h3,
                    .stop-animation h4,
                    .stop-animation h5,
                    .stop-animation h6,
                    .stop-animation p,
                    .stop-animation span,
                    .stop-animation div,
                    .stop-animation a,
                    .stop-animation li,
                    .stop-animation td,
                    .stop-animation th,
                    .stop-animation label {
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* width: auto !important; - REMOVED: This was breaking website layout */
                        /* height: auto !important; - REMOVED: This was breaking website layout */
                        /* top: auto !important; - REMOVED: This was breaking website layout */
                        /* left: auto !important; - REMOVED: This was breaking website layout */
                        /* right: auto !important; - REMOVED: This was breaking website layout */
                        /* bottom: auto !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* CRITICAL: Force ALL possible animations to their final state immediately */
                    .stop-animation *[class*="animate"],
                    .stop-animation *[class*="fade"],
                    .stop-animation *[class*="slide"],
                    .stop-animation *[class*="bounce"],
                    .stop-animation *[class*="pulse"],
                    .stop-animation *[class*="shake"],
                    .stop-animation *[class*="flash"],
                    .stop-animation *[class*="blink"],
                    .stop-animation *[class*="glow"],
                    .stop-animation *[class*="spin"],
                    .stop-animation *[class*="rotate"],
                    .stop-animation *[class*="scale"],
                    .stop-animation *[class*="zoom"],
                    .stop-animation *[class*="wiggle"],
                    .stop-animation *[class*="jiggle"],
                    .stop-animation *[class*="twist"],
                    .stop-animation *[class*="flip"],
                    .stop-animation *[class*="swing"],
                    .stop-animation *[class*="wobble"],
                    .stop-animation *[class*="tilt"],
                    /* Additional comprehensive animation coverage */
                    .stop-animation *[class*="motion"],
                    .stop-animation *[class*="move"],
                    .stop-animation *[class*="float"],
                    .stop-animation *[class*="drift"],
                    .stop-animation *[class*="sway"],
                    .stop-animation *[class*="rock"],
                    .stop-animation *[class*="wave"],
                    .stop-animation *[class*="flow"],
                    .stop-animation *[class*="glide"],
                    .stop-animation *[class*="sweep"],
                    .stop-animation *[class*="swoop"],
                    .stop-animation *[class*="dive"],
                    .stop-animation *[class*="rise"],
                    .stop-animation *[class*="fall"],
                    .stop-animation *[class*="drop"],
                    .stop-animation *[class*="lift"],
                    .stop-animation *[class*="sink"],
                    .stop-animation *[class*="hover"],
                    .stop-animation *[class*="orbit"],
                    .stop-animation *[class*="revolve"],
                    .stop-animation *[class*="turn"],
                    .stop-animation *[class*="twirl"],
                    .stop-animation *[class*="whirl"],
                    .stop-animation *[class*="spiral"],
                    .stop-animation *[class*="helix"],
                    .stop-animation *[class*="coil"],
                    .stop-animation *[class*="curl"],
                    .stop-animation *[class*="bend"],
                    .stop-animation *[class*="flex"],
                    .stop-animation *[class*="stretch"] {
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* top: auto !important; - REMOVED: This was breaking website layout */
                        /* left: auto !important; - REMOVED: This was breaking website layout */
                        /* right: auto !important; - REMOVED: This was breaking website layout */
                        /* bottom: auto !important; - REMOVED: This was breaking website layout */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* translate: none !important; - REMOVED: This was breaking website layout */
                        /* scale: 1 !important; - REMOVED: This was breaking website layout */
                        /* rotate: 0deg !important; - REMOVED: This was breaking website layout */
                        /* width: auto !important; - REMOVED: This was breaking website layout */
                        /* height: auto !important; - REMOVED: This was breaking website layout */
                        animation: none !important;
                        transition: none !important;
                        /* animation-fill-mode: forwards !important; - REMOVED: This was causing elements to snap to final positions and interfere with scrolling */
                        animation-play-state: paused !important;
                    }
                    
                    /* Only reset positioning for elements that are likely to be animated */
                    .stop-animation *[class*="animate"],
                    .stop-animation *[class*="fade"],
                    .stop-animation *[class*="slide"],
                    .stop-animation *[class*="bounce"],
                    .stop-animation *[class*="pulse"],
                    .stop-animation *[class*="shake"],
                    .stop-animation *[class*="flash"],
                    .stop-animation *[class*="blink"],
                    .stop-animation *[class*="glow"],
                    .stop-animation *[class*="spin"],
                    .stop-animation *[class*="rotate"],
                    .stop-animation *[class*="scale"],
                    .stop-animation *[class*="zoom"],
                    .stop-animation *[class*="wiggle"],
                    .stop-animation *[class*="jiggle"],
                    .stop-animation *[class*="twist"],
                    .stop-animation *[class*="flip"],
                    .stop-animation *[class*="swing"],
                    .stop-animation *[class*="wobble"],
                    .stop-animation *[class*="tilt"] {
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* top: auto !important; - REMOVED: This was breaking website layout */
                        /* left: auto !important; - REMOVED: This was breaking website layout */
                        /* right: auto !important; - REMOVED: This was breaking website layout */
                        /* bottom: auto !important; - REMOVED: This was breaking website layout */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* translate: none !important; - REMOVED: This was breaking website layout */
                        /* scale: 1 !important; - REMOVED: This was breaking website layout */
                        /* rotate: 0deg !important; - REMOVED: This was breaking website layout */
                        /* width: auto !important; - REMOVED: This was breaking website layout */
                        /* height: auto !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* Preserve original layout for specific elements */
                    .stop-animation img,
                    .stop-animation video,
                    .stop-animation audio,
                    .stop-animation iframe,
                    .stop-animation embed,
                    .stop-animation object {
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* width: auto !important; - REMOVED: This was breaking website layout */
                        /* height: auto !important; - REMOVED: This was breaking website layout */
                        max-width: 100% !important;
                        max-height: 100% !important;
                    }
                    
                    /* Ensure text elements maintain original layout */
                    .stop-animation h1,
                    .stop-animation h2,
                    .stop-animation h3,
                    .stop-animation h4,
                    .stop-animation h5,
                    .stop-animation h6,
                    .stop-animation p,
                    .stop-animation span,
                    .stop-animation div,
                    .stop-animation a,
                    .stop-animation li,
                    .stop-animation td,
                    .stop-animation th,
                    .stop-animation label {
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* width: auto !important; - REMOVED: This was breaking website layout */
                        /* height: auto !important; - REMOVED: This was breaking website layout */
                        /* top: auto !important; - REMOVED: This was breaking website layout */
                        /* left: auto !important; - REMOVED: This was breaking website layout */
                        /* right: auto !important; - REMOVED: This was breaking website layout */
                        /* bottom: auto !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* CRITICAL: Force ALL possible animations to their final state immediately */
                    .stop-animation *[class*="animate"],
                    .stop-animation *[class*="fade"],
                    .stop-animation *[class*="slide"],
                    .stop-animation *[class*="bounce"],
                    .stop-animation *[class*="pulse"],
                    .stop-animation *[class*="shake"],
                    .stop-animation *[class*="flash"],
                    .stop-animation *[class*="blink"],
                    .stop-animation *[class*="glow"],
                    .stop-animation *[class*="spin"],
                    .stop-animation *[class*="rotate"],
                    .stop-animation *[class*="scale"],
                    .stop-animation *[class*="zoom"],
                    .stop-animation *[class*="wiggle"],
                    .stop-animation *[class*="jiggle"],
                    .stop-animation *[class*="twist"],
                    .stop-animation *[class*="flip"],
                    .stop-animation *[class*="swing"],
                    .stop-animation *[class*="wobble"],
                    .stop-animation *[class*="tilt"],
                    /* Additional comprehensive animation coverage */
                    .stop-animation *[class*="motion"],
                    .stop-animation *[class*="move"],
                    .stop-animation *[class*="float"],
                    .stop-animation *[class*="drift"],
                    .stop-animation *[class*="sway"],
                    .stop-animation *[class*="rock"],
                    .stop-animation *[class*="wave"],
                    .stop-animation *[class*="flow"],
                    .stop-animation *[class*="glide"],
                    .stop-animation *[class*="sweep"],
                    .stop-animation *[class*="swoop"],
                    .stop-animation *[class*="dive"],
                    .stop-animation *[class*="rise"],
                    .stop-animation *[class*="fall"],
                    .stop-animation *[class*="drop"],
                    .stop-animation *[class*="lift"],
                    .stop-animation *[class*="sink"],
                    .stop-animation *[class*="hover"],
                    .stop-animation *[class*="orbit"],
                    .stop-animation *[class*="revolve"],
                    .stop-animation *[class*="turn"],
                    .stop-animation *[class*="twirl"],
                    .stop-animation *[class*="whirl"],
                    .stop-animation *[class*="spiral"],
                    .stop-animation *[class*="helix"],
                    .stop-animation *[class*="coil"],
                    .stop-animation *[class*="curl"],
                    .stop-animation *[class*="bend"],
                    .stop-animation *[class*="flex"],
                    .stop-animation *[class*="stretch"],
                    .stop-animation *[class*="squash"],
                    .stop-animation *[class*="squeeze"],
                    .stop-animation *[class*="compress"],
                    .stop-animation *[class*="expand"],
                    .stop-animation *[class*="grow"],
                    .stop-animation *[class*="shrink"],
                    .stop-animation *[class*="inflate"],
                    .stop-animation *[class*="deflate"],
                    .stop-animation *[class*="morph"],
                    /* REMOVED: .stop-animation *[class*="transform"], - This was interfering with scroll libraries */
                    .stop-animation *[class*="transition"],
                    .stop-animation *[class*="migrate"],
                    .stop-animation *[class*="shift"],
                    /* Additional modern animation frameworks and libraries */
                    .stop-animation *[class*="aos"], /* AOS (Animate On Scroll) */
                    .stop-animation *[class*="wow"], /* WOW.js */
                    .stop-animation *[class*="framer"], /* Framer Motion */
                    .stop-animation *[class*="spring"], /* Spring animations */
                    .stop-animation *[class*="ease"], /* Easing animations */
                    .stop-animation *[class*="cubic"], /* Cubic bezier animations */
                    .stop-animation *[class*="bounce-in"], /* Bounce variations */
                    .stop-animation *[class*="bounce-out"],
                    .stop-animation *[class*="fade-in"],
                    .stop-animation *[class*="fade-out"],
                    .stop-animation *[class*="slide-in"],
                    .stop-animation *[class*="slide-out"],
                    .stop-animation *[class*="zoom-in"],
                    .stop-animation *[class*="zoom-out"],
                    .stop-animation *[class*="flip-in"],
                    .stop-animation *[class*="flip-out"],
                    .stop-animation *[class*="rotate-in"],
                    .stop-animation *[class*="rotate-out"],
                    .stop-animation *[class*="scale-in"],
                    .stop-animation *[class*="scale-out"],
                    .stop-animation *[class*="skew"],
                    .stop-animation *[class*="skew-in"],
                    .stop-animation *[class*="skew-out"],
                    .stop-animation *[class*="elastic"],
                    .stop-animation *[class*="back"],
                    .stop-animation *[class*="circ"],
                    .stop-animation *[class*="expo"],
                    .stop-animation *[class*="quad"],
                    .stop-animation *[class*="quart"],
                    .stop-animation *[class*="quint"],
                    .stop-animation *[class*="sine"],
                    .stop-animation *[class*="power"],
                    .stop-animation *[class*="strong"],
                    .stop-animation *[class*="swing"],
                    .stop-animation *[class*="tada"],
                    .stop-animation *[class*="rubber"],
                    .stop-animation *[class*="jello"],
                    .stop-animation *[class*="heartbeat"],
                    .stop-animation *[class*="headshake"],
                    .stop-animation *[class*="hinge"],
                    .stop-animation *[class*="jack"],
                    .stop-animation *[class*="lightSpeed"],
                    .stop-animation *[class*="roll"],
                    .stop-animation *[class*="rotate"],
                    .stop-animation *[class*="slide"],
                    .stop-animation *[class*="zoom"],
                    .stop-animation *[class*="flip"],
                    .stop-animation *[class*="bounce"],
                    .stop-animation *[class*="shake"],
                    .stop-animation *[class*="wobble"],
                    .stop-animation *[class*="pulse"],
                    .stop-animation *[class*="flash"],
                    .stop-animation *[class*="rubberBand"],
                    .stop-animation *[class*="swing"],
                    .stop-animation *[class*="tada"],
                    .stop-animation *[class*="wobble"],
                    .stop-animation *[class*="jello"],
                    .stop-animation *[class*="heartbeat"],
                    .stop-animation *[class*="headShake"],
                    .stop-animation *[class*="hinge"],
                    .stop-animation *[class*="jackInTheBox"],
                    .stop-animation *[class*="lightSpeedIn"],
                    .stop-animation *[class*="lightSpeedOut"],
                    .stop-animation *[class*="rollIn"],
                    .stop-animation *[class*="rollOut"],
                    .stop-animation *[class*="rotateIn"],
                    .stop-animation *[class*="rotateInDownLeft"],
                    .stop-animation *[class*="rotateInDownRight"],
                    .stop-animation *[class*="rotateInUpLeft"],
                    .stop-animation *[class*="rotateInUpRight"],
                    .stop-animation *[class*="rotateOut"],
                    .stop-animation *[class*="rotateOutDownLeft"],
                    .stop-animation *[class*="rotateOutDownRight"],
                    .stop-animation *[class*="rotateOutUpLeft"],
                    .stop-animation *[class*="rotateOutUpRight"],
                    .stop-animation *[class*="slideInDown"],
                    .stop-animation *[class*="slideInLeft"],
                    .stop-animation *[class*="slideInRight"],
                    .stop-animation *[class*="slideInUp"],
                    .stop-animation *[class*="slideOutDown"],
                    .stop-animation *[class*="slideOutLeft"],
                    .stop-animation *[class*="slideOutRight"],
                    .stop-animation *[class*="slideOutUp"],
                    .stop-animation *[class*="zoomIn"],
                    .stop-animation *[class*="zoomInDown"],
                    .stop-animation *[class*="zoomInLeft"],
                    .stop-animation *[class*="zoomInRight"],
                    .stop-animation *[class*="zoomInUp"],
                    .stop-animation *[class*="zoomOut"],
                    .stop-animation *[class*="zoomOutDown"],
                    .stop-animation *[class*="zoomOutLeft"],
                    .stop-animation *[class*="zoomOutRight"],
                    .stop-animation *[class*="zoomOutUp"],
                    .stop-animation *[class*="flipInX"],
                    .stop-animation *[class*="flipInY"],
                    .stop-animation *[class*="flipOutX"],
                    .stop-animation *[class*="flipOutY"] {
                        animation: none !important;
                        transition: none !important;
                        /* animation-fill-mode: forwards !important; - REMOVED: This was causing elements to snap to final positions and interfere with scrolling */
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* Force GSAP and library animations to final state */
                    .stop-animation .fade-up,
                    .stop-animation .fade-left,
                    .stop-animation .fade-right,
                    .stop-animation .fade-in,
                    .stop-animation .slide-in,
                    .stop-animation .scale-in,
                    .stop-animation .zoom-in,
                    .stop-animation [data-splitting],
                    .stop-animation .split,
                    .stop-animation .char,
                    .stop-animation .word {
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        animation: none !important;
                        transition: none !important;
                    }
                    
                    /* COMPREHENSIVE CATCH-ALL: Force ANY element with animation-related styles to final state */
                    .stop-animation *[style*="animation"],
                    .stop-animation *[style*="transition"],
                    /* REMOVED: .stop-animation *[style*="transform"], - This was interfering with scroll libraries */
                    .stop-animation *[style*="opacity"],
                    .stop-animation *[style*="visibility"],
                    .stop-animation *[data-animation],
                    .stop-animation *[data-transition],
                    /* REMOVED: .stop-animation *[data-transform], - This was interfering with scroll libraries */
                    .stop-animation *[data-opacity],
                    .stop-animation *[data-visibility] {
                        animation: none !important;
                        transition: none !important;
                        /* animation-fill-mode: forwards !important; - REMOVED: This was causing elements to snap to final positions and interfere with scrolling */
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* AUTOPLAY MEDIA: Stop all autoplay videos and media */
                    .stop-animation video,
                    .stop-animation audio,
                    .stop-animation iframe,
                    .stop-animation embed,
                    .stop-animation object,
                    .stop-animation [autoplay],
                    .stop-animation [data-autoplay],
                    .stop-animation [class*="autoplay"],
                    .stop-animation [class*="video"],
                    .stop-animation [class*="media"] {
                        animation: none !important;
                        transition: none !important;
                        /* animation-fill-mode: forwards !important; - REMOVED: This was causing elements to snap to final positions and interfere with scrolling */
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* LETTER-BY-LETTER ANIMATIONS: Force all text animations to final state */
                    .stop-animation [data-splitting],
                    .stop-animation .split,
                    .stop-animation .char,
                    .stop-animation .word,
                    .stop-animation [data-splitting] .char,
                    .stop-animation [data-splitting] .word,
                    .stop-animation [class*="split"],
                    .stop-animation [class*="char"],
                    .stop-animation [class*="word"],
                    .stop-animation [class*="letter"],
                    .stop-animation [class*="text-animation"],
                    .stop-animation [class*="typing"],
                    .stop-animation [class*="typewriter"],
                    .stop-animation [class*="reveal"],
                    .stop-animation [class*="unveil"],
                    .stop-animation [class*="show-text"],
                    .stop-animation [class*="text-effect"] {
                        animation: none !important;
                        transition: none !important;
                        /* animation-fill-mode: forwards !important; - REMOVED: This was causing elements to snap to final positions and interfere with scrolling */
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* REMOVED: SCROLL-TRIGGERED ANIMATIONS - This was interfering with scroll animated websites */
                    /* .stop-animation *[class*="scroll"],
                    .stop-animation *[class*="progress"],
                    .stop-animation *[class*="bar"],
                    .stop-animation *[class*="line"],
                    .stop-animation *[class*="timeline"],
                    .stop-animation *[class*="track"],
                    .stop-animation *[class*="path"],
                    .stop-animation *[class*="stroke"],
                    .stop-animation *[class*="fill"],
                    .stop-animation *[class*="gradient"],
                    .stop-animation *[class*="wave"],
                    .stop-animation *[class*="flow"],
                    .stop-animation *[class*="stream"],
                    .stop-animation *[class*="runner"],
                    .stop-animation *[class*="mover"],
                    .stop-animation *[class*="slider"],
                    .stop-animation *[class*="indicator"],
                    .stop-animation *[class*="stopper"],
                    .stop-animation *[class*="marker"],
                    .stop-animation *[class*="pointer"],
                    .stop-animation *[class*="cursor"],
                    .stop-animation *[class*="dot"],
                    .stop-animation *[class*="circle"],
                    .stop-animation *[class*="ring"],
                    .stop-animation *[class*="orbit"] {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                    } */
                    
                    /* PROGRESS BARS AND SCROLL INDICATORS: Stop all progress animations */
                    .stop-animation progress,
                    .stop-animation [role="progressbar"],
                    .stop-animation [class*="progress"],
                    .stop-animation [class*="bar"],
                    .stop-animation [class*="indicator"],
                    .stop-animation [class*="track"],
                    .stop-animation [class*="line"],
                    .stop-animation [class*="path"],
                    .stop-animation [class*="stroke"],
                    .stop-animation [class*="fill"],
                    .stop-animation [class*="gradient"],
                    .stop-animation [class*="wave"],
                    .stop-animation [class*="flow"],
                    .stop-animation [class*="stream"],
                    .stop-animation [class*="runner"],
                    .stop-animation [class*="mover"],
                    .stop-animation [class*="slider"],
                    .stop-animation [class*="stopper"],
                    .stop-animation [class*="marker"],
                    .stop-animation [class*="pointer"],
                    .stop-animation [class*="cursor"],
                    .stop-animation [class*="dot"],
                    .stop-animation [class*="circle"],
                    .stop-animation [class*="ring"],
                    .stop-animation [class*="orbit"] {
                        animation: none !important;
                        transition: none !important;
                        
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* SVG LINE ANIMATIONS: Stop all SVG stroke animations */
                    .stop-animation svg,
                    .stop-animation svg path,
                    .stop-animation svg line,
                    .stop-animation svg polyline,
                    .stop-animation svg polygon,
                    .stop-animation svg circle,
                    .stop-animation svg rect,
                    .stop-animation svg ellipse,
                    .stop-animation svg g {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* REMOVED: SCROLL-TRIGGERED LINE ANIMATIONS - This was interfering with scroll animated websites */
                    /* .stop-animation *[class*="scroll"],
                    .stop-animation *[class*="progress"],
                    .stop-animation *[class*="bar"],
                    .stop-animation *[class*="line"],
                    .stop-animation *[class*="timeline"],
                    .stop-animation *[class*="track"],
                    .stop-animation *[class*="path"],
                    .stop-animation *[class*="stroke"],
                    .stop-animation *[class*="fill"],
                    .stop-animation *[class*="gradient"],
                    .stop-animation *[class*="wave"],
                    .stop-animation *[class*="flow"],
                    .stop-animation *[class*="stream"],
                    .stop-animation *[class*="runner"],
                    .stop-animation *[class*="mover"] {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                    } */
                    
                    /* GENERIC ANIMATION CATCH-ALL: Stop all possible animations */
                    .stop-animation *[class*="item"],
                    .stop-animation *[class*="content"],
                    .stop-animation *[class*="count"],
                    .stop-animation *[class*="counter"],
                    .stop-animation *[class*="text"],
                    .stop-animation *[class*="header"],
                    .stop-animation *[class*="connector"],
                    .stop-animation *[class*="dot"],
                    .stop-animation *[class*="timeline"],
                    .stop-animation *[class*="step"],
                    .stop-animation *[class*="stage"],
                    .stop-animation *[class*="phase"],
                    .stop-animation *[class*="card"],
                    .stop-animation *[class*="block"],
                    .stop-animation *[class*="section"],
                    .stop-animation *[class*="container"],
                    .stop-animation *[class*="wrapper"],
                    .stop-animation *[class*="element"],
                    .stop-animation *[class*="component"] {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* translate: none !important; - REMOVED: This was breaking website layout */
                        rotate: none !important;
                        scale: none !important;
                    }
                    
                    /* ULTIMATE CATCH-ALL: Stop ANY element with animation properties */
                    .stop-animation *[style*="animation"],
                    .stop-animation *[style*="transition"],
                    /* REMOVED: .stop-animation *[style*="transform"], - This was interfering with scroll libraries */
                    .stop-animation *[style*="opacity"],
                    .stop-animation *[style*="visibility"],
                    .stop-animation *[data-animation],
                    .stop-animation *[data-transition],
                    /* REMOVED: .stop-animation *[data-transform], - This was interfering with scroll libraries */
                    .stop-animation *[data-opacity],
                    .stop-animation *[data-visibility] {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* translate: none !important; - REMOVED: This was breaking website layout */
                        rotate: none !important;
                        scale: none !important;
                    }
                    
                    
                    /* STOPPER AND MARKER ELEMENTS: Stop animations and reset positioning */
                    .stop-animation *[class*="stopper"],
                    .stop-animation *[class*="marker"],
                    .stop-animation *[class*="pointer"],
                    .stop-animation *[class*="cursor"],
                    .stop-animation *[class*="dot"],
                    .stop-animation *[class*="circle"],
                    .stop-animation *[class*="ring"],
                    .stop-animation *[class*="orbit"],
                    .stop-animation *[class*="indicator"],
                    .stop-animation *[class*="slider"] {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* top: auto !important; - REMOVED: This was breaking website layout */
                        /* left: auto !important; - REMOVED: This was breaking website layout */
                        /* right: auto !important; - REMOVED: This was breaking website layout */
                        /* bottom: auto !important; - REMOVED: This was breaking website layout */
                        z-index: auto !important;
                    }
                    
                    /* CSS TEXT EFFECTS (BLINKING AND FLASHING) PREVENTION */
                    /* Ensure all text is static, stopping any blinking or rapid color changes */
                    .stop-animation *:not(body), 
                    .stop-animation *::before, 
                    .stop-animation *::after {
                        /* Override CSS rules that cause rapid visibility changes */
                        visibility: visible !important;
                        opacity: 1 !important;
                        color: inherit !important; 
                        text-decoration: none !important; /* Catch legacy/non-standard 'blink' */
                        
                        /* Prevent any rapid color changes that could cause flashing */
                        animation: none !important;
                        transition: none !important;
                        animation-duration: 0s !important;
                        transition-duration: 0s !important;
                        animation-iteration-count: 1 !important;
                        animation-play-state: paused !important;
                        
                        /* Force text to remain visible and static */
                        display: inherit !important;
                        /* position: static !important; - REMOVED: This was breaking website layout */
                        /* transform: none !important; - REMOVED: This was breaking website layout */
                    }
                    
                    /* Specific targeting of blinking text elements */
                    .stop-animation *[class*="blink"],
                    .stop-animation *[class*="flash"],
                    .stop-animation *[class*="flicker"],
                    .stop-animation *[class*="pulse"],
                    .stop-animation *[class*="glow"],
                    .stop-animation *[class*="shine"],
                    .stop-animation *[class*="twinkle"],
                    .stop-animation *[class*="sparkle"],
                    .stop-animation *[class*="blink-text"],
                    .stop-animation *[class*="flashing-text"],
                    .stop-animation *[class*="animated-text"],
                    .stop-animation *[class*="text-effect"],
                    .stop-animation *[class*="text-animation"] {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        color: inherit !important;
                        text-decoration: none !important;
                        animation-duration: 0s !important;
                        transition-duration: 0s !important;
                        animation-iteration-count: 1 !important;
                        animation-play-state: paused !important;
                    }
                    
                    /* Override any CSS animations that could cause rapid visibility changes */
                    .stop-animation *[style*="animation"],
                    .stop-animation *[style*="transition"],
                    .stop-animation *[style*="opacity"],
                    .stop-animation *[style*="visibility"],
                    .stop-animation *[style*="color"] {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        color: inherit !important;
                        text-decoration: none !important;
                        animation-duration: 0s !important;
                        transition-duration: 0s !important;
                        animation-iteration-count: 1 !important;
                        animation-play-state: paused !important;
                    }
                    
                    /* Prevent rapid color changes in text elements */
                    .stop-animation h1, .stop-animation h2, .stop-animation h3, 
                    .stop-animation h4, .stop-animation h5, .stop-animation h6,
                    .stop-animation p, .stop-animation span, .stop-animation div,
                    .stop-animation a, .stop-animation li, .stop-animation td,
                    .stop-animation th, .stop-animation label, .stop-animation button {
                        animation: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        color: inherit !important;
                        text-decoration: none !important;
                        animation-duration: 0s !important;
                        transition-duration: 0s !important;
                        animation-iteration-count: 1 !important;
                        animation-play-state: paused !important;
                    }
    
                `;
    
                document.head.appendChild(style);
    
            }
    
            // Apply same seizure-safe runtime controls but without visual changes
            this.stopAutoplayVideos();
            this.stopPortfolioAnimations();
            this.lockButtonHoverStyles();
            
            // REMOVED: overrideRequestAnimationFrame call that was blocking scroll
            
            // API Controls: Execute .stop() or .pause() methods on known animation libraries
            this.stopAnimationLibraries();
            
            // Media Replacement: Pause autoplay videos and replace animated GIFs with static placeholders
            this.replaceAnimatedMedia();
    
            // Stop any JavaScript-based animations (like the slider auto-slide)
    
            if (window.slider && typeof window.slider.disableAutoSlide === 'function') {
    
    
                window.slider.disableAutoSlide();
    
            } else {
    
                
    
                // Try again after a short delay in case slider is still initializing
    
                setTimeout(() => {
    
                    if (window.slider && typeof window.slider.disableAutoSlide === 'function') {
    
                 
    
                        window.slider.disableAutoSlide();
    
                    }
    
                }, 100);
    
            }
    
        }
    
        
       
        
        // API Controls: Execute .stop() or .pause() methods on known animation libraries
        stopAnimationLibraries() {
            try {
                // Lottie (official API)
                this.stopAllLottieAnimations();

                // GSAP (official API) - Comprehensive stopping with restart prevention
                if (typeof window.gsap !== 'undefined') {
                    try {
                        // Method 1: Kill all tweens globally
                        if (window.gsap.killTweensOf) {
                            window.gsap.killTweensOf('*');
                        }
                        
                        // Method 2: Kill all timelines and set to final state
                        if (window.gsap.getAllTimelines) {
                            const allTimelines = window.gsap.getAllTimelines();
                            allTimelines.forEach(tl => {
                                try {
                                    // Set timeline to final state (progress = 1)
                                    if (tl && typeof tl.totalProgress === 'function') { 
                                        tl.totalProgress(1); 
                                    }
                                    // Pause timeline
                                    if (tl && typeof tl.pause === 'function') {
                                        tl.pause();
                                    }
                                    // Kill timeline completely
                                    if (tl && typeof tl.kill === 'function') {
                                        tl.kill();
                                    }
                                    // Prevent restart by setting paused state
                                    if (tl && tl.paused !== undefined) {
                                        tl.paused(true);
                                    }
                                } catch (_) {}
                            });
                        }
                        
                        // Method 3: Kill all individual tweens
                        if (window.gsap.getAllTweens) {
                            const allTweens = window.gsap.getAllTweens();
                            allTweens.forEach(tween => {
                                try {
                                    // Set tween to final state
                                    if (tween && typeof tween.totalProgress === 'function') { 
                                        tween.totalProgress(1); 
                                    }
                                    // Pause tween
                                    if (tween && typeof tween.pause === 'function') {
                                        tween.pause();
                                    }
                                    // Kill tween completely
                                    if (tween && typeof tween.kill === 'function') {
                                        tween.kill();
                                    }
                                    // Prevent restart
                                    if (tween && tween.paused !== undefined) {
                                        tween.paused(true);
                                    }
                                } catch (_) {}
                            });
                        }
                        
                        // Method 4: Clear global timeline
                        if (window.gsap.globalTimeline && typeof window.gsap.globalTimeline.clear === 'function') {
                            try {
                                window.gsap.globalTimeline.clear();
                            } catch (_) {}
                        }
                        
                        // Method 5: Override GSAP methods to prevent new animations when seizure-safe is active
                        if (!seizureState.gsapMethodsOverridden) {
                            seizureState.gsapMethodsOverridden = true;
                            
                            // Store original methods
                            if (!seizureState.originalGsapTo && window.gsap.to) {
                                seizureState.originalGsapTo = window.gsap.to;
                                window.gsap.to = function() {
                                    if (document.body.classList.contains('seizure-safe') || 
                                        document.documentElement.classList.contains('seizure-safe')) {
                                        // Return a dummy tween that does nothing
                                        return { kill: function() {}, pause: function() {}, play: function() {} };
                                    }
                                    return seizureState.originalGsapTo.apply(this, arguments);
                                };
                            }
                            
                            if (!seizureState.originalGsapFrom && window.gsap.from) {
                                seizureState.originalGsapFrom = window.gsap.from;
                                window.gsap.from = function() {
                                    if (document.body.classList.contains('seizure-safe') || 
                                        document.documentElement.classList.contains('seizure-safe')) {
                                        return { kill: function() {}, pause: function() {}, play: function() {} };
                                    }
                                    return seizureState.originalGsapFrom.apply(this, arguments);
                                };
                            }
                            
                            if (!seizureState.originalGsapFromTo && window.gsap.fromTo) {
                                seizureState.originalGsapFromTo = window.gsap.fromTo;
                                window.gsap.fromTo = function() {
                                    if (document.body.classList.contains('seizure-safe') || 
                                        document.documentElement.classList.contains('seizure-safe')) {
                                        return { kill: function() {}, pause: function() {}, play: function() {} };
                                    }
                                    return seizureState.originalGsapFromTo.apply(this, arguments);
                                };
                            }
                            
                            if (!seizureState.originalGsapTimeline && window.gsap.timeline) {
                                seizureState.originalGsapTimeline = window.gsap.timeline;
                                window.gsap.timeline = function() {
                                    if (document.body.classList.contains('seizure-safe') || 
                                        document.documentElement.classList.contains('seizure-safe')) {
                                        // Return a dummy timeline that does nothing
                                        const dummy = { 
                                            kill: function() {}, 
                                            pause: function() {}, 
                                            play: function() {},
                                            to: function() { return this; },
                                            from: function() { return this; },
                                            fromTo: function() { return this; }
                                        };
                                        return dummy;
                                    }
                                    return seizureState.originalGsapTimeline.apply(this, arguments);
                                };
                            }
                        }
                    } catch (_) {}
                }

                // Webflow IX2 (official require API)
                try {
                    if (window.Webflow && typeof window.Webflow.require === 'function') {
                        const ix2 = window.Webflow.require('ix2');
                        if (ix2 && typeof ix2.stop === 'function') {
                            ix2.stop();
                        }
                    }
                } catch (_) {}

                // Webflow Lottie embeds (generic, no hardcoding)
                try {
                    const wfLotties = document.querySelectorAll('[data-animation-type="lottie"], [data-w-id][data-animation-type="lottie"]');
                    wfLotties.forEach(el => {
                        try {
                            const inst = el.lottie || el._lottie || el.__lottie || el.lottieAnimation || el.__wfLottie;
                            if (inst) {
                                if (inst.setSpeed) inst.setSpeed(0);
                                if (inst.stop) inst.stop();
                                if (inst.pause) inst.pause();
                                if (inst.goToAndStop) {
                                    // Go to final frame (finish to final state, not frame 0)
                                    const totalFrames = inst.totalFrames || inst.frameCount || 0;
                                    const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                    inst.goToAndStop(finalFrame, true);
                                } else if (inst.goToAndPlay) {
                                    // Fallback: go to end if goToAndStop not available
                                    const totalFrames = inst.totalFrames || inst.frameCount || 0;
                                    const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                    inst.goToAndPlay(finalFrame, true);
                                    if (inst.pause) {
                                        setTimeout(() => inst.pause(), 0);
                                    }
                                }
                                if (inst.autoplay !== undefined) inst.autoplay = false;
                                if (inst.loop !== undefined) inst.loop = false;
                            }
                            // Fallback: pause inner svg/canvas
                            const svg = el.querySelector('svg, canvas');
                            if (svg) {
                                svg.style.animation = 'none';
                                svg.style.transition = 'none';
                            }
                        } catch (_) {}
                    });
                } catch (_) {}

                // Webflow interactions: stop transforms/animations on data-w-id elements (finish to final)
                try {
                    const wfElems = document.querySelectorAll('[data-w-id]');
                    wfElems.forEach(el => {
                        try {
                            el.style.transition = 'none';
                            el.style.animation = 'none';
                            const cs = window.getComputedStyle(el);
                            if (cs.transform && cs.transform !== 'none') {
                                el.style.transform = 'none';
                            }
                            if (cs.opacity !== '1') {
                                el.style.opacity = '1';
                            }
                        } catch (_) {}
                    });
                } catch (_) {}
            } catch (error) {
               
            }
        }

        // Webflow interactions stopper (IX2 + data-w-id fallback)
        stopWebflowInteractions() {
            // IX2 official API stop
            try {
                if (window.Webflow && typeof window.Webflow.require === 'function') {
                    const ix2 = window.Webflow.require('ix2');
                    if (ix2) {
                        if (typeof ix2.stop === 'function') ix2.stop();
                        // destroy is heavier; call if available to fully halt interactions
                        if (typeof ix2.destroy === 'function') ix2.destroy();
                    }
                }
            } catch (_) {}

            // Fallback: neutralize data-w-id elements
            try {
                const wfElems = document.querySelectorAll('[data-w-id]');
                wfElems.forEach(el => {
                    try {
                        el.style.transition = 'none';
                        el.style.animation = 'none';
                        const cs = window.getComputedStyle(el);
                        if (cs.transform && cs.transform !== 'none') {
                            el.style.transform = 'none';
                        }
                        if (cs.opacity !== '1') {
                            el.style.opacity = '1';
                        }
                    } catch (_) {}
                });
            } catch (_) {}
        }
        
        // Start continuous polling for Lottie and GSAP animations
        // This catches animations that start AFTER seizure mode is enabled
        startLottieGSAPPolling() {
            // Clear any existing intervals first
            this.stopLottieGSAPPolling();
            
            // Poll for Lottie animations every 5ms (VERY aggressive to catch loops)
            if (!this.lottiePollInterval) {
                this.lottiePollInterval = setInterval(() => {
                    try {
                        // CRITICAL: Call stopAllLottieAnimations first to ensure all Lottie instances are stopped
                        this.stopAllLottieAnimations();
                        
                        // Method 1: lottie-player web component - Use official API methods
                        const lottiePlayers = document.querySelectorAll('lottie-player');
                        lottiePlayers.forEach(player => {
                            try {
                                // Use lottie-player's official API methods in correct order
                                if (typeof player.setSpeed === 'function') {
                                    player.setSpeed(0);
                                }
                                if (typeof player.stop === 'function') {
                                    player.stop();
                                }
                                if (typeof player.pause === 'function') {
                                    player.pause();
                                }
                                if (typeof player.seek === 'function') {
                                    // Go to final frame (finish to final state)
                                    const totalFrames = player.totalFrames || player.frameCount || 0;
                                    const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                    player.seek(finalFrame);
                                }
                                if (typeof player.setMode === 'function') {
                                    player.setMode('normal');
                                }
                                player.setAttribute('autoplay', 'false');
                                player.removeAttribute('loop');
                                player.setAttribute('loop', 'false');
                                
                                // CRITICAL: Override lottie-player's play/restart methods in polling
                                if (!player._seizureSafeOriginalPlay && typeof player.play === 'function') {
                                    player._seizureSafeOriginalPlay = player.play;
                                    player.play = function() {
                                        if (document.body.classList.contains('seizure-safe') || 
                                            document.documentElement.classList.contains('seizure-safe')) {
                                            return;
                                        }
                                        return player._seizureSafeOriginalPlay.apply(this, arguments);
                                    };
                                }
                                
                                if (!player._seizureSafeOriginalRestart && typeof player.restart === 'function') {
                                    player._seizureSafeOriginalRestart = player.restart;
                                    player.restart = function() {
                                        if (document.body.classList.contains('seizure-safe') || 
                                            document.documentElement.classList.contains('seizure-safe')) {
                                            return;
                                        }
                                        return player._seizureSafeOriginalRestart.apply(this, arguments);
                                    };
                                }
                            } catch (_) {}
                        });
                        
                        // Method 2: bodymovin/lottie library - Use official API methods
                        if (typeof window.lottie !== 'undefined' && window.lottie.getRegisteredAnimations) {
                            const lottieAnimations = window.lottie.getRegisteredAnimations();
                            lottieAnimations.forEach(animation => {
                                try {
                                    if (animation) {
                                        // CRITICAL: Cancel any requestAnimationFrame loops FIRST - this stops the render loop
                                        if (animation.animationID !== undefined && animation.animationID !== null) {
                                            try {
                                                cancelAnimationFrame(animation.animationID);
                                                animation.animationID = null;
                                            } catch (_) {}
                                        }
                                        if (animation.renderer && animation.renderer.animationID !== undefined && animation.renderer.animationID !== null) {
                                            try {
                                                cancelAnimationFrame(animation.renderer.animationID);
                                                animation.renderer.animationID = null;
                                            } catch (_) {}
                                        }
                                        if (animation._animationID !== undefined && animation._animationID !== null) {
                                            try {
                                                cancelAnimationFrame(animation._animationID);
                                                animation._animationID = null;
                                            } catch (_) {}
                                        }
                                        
                                        // Use Lottie's official API in correct order
                                        if (typeof animation.setSpeed === 'function') {
                                            animation.setSpeed(0);
                                        }
                                        if (typeof animation.stop === 'function') {
                                            animation.stop();
                                        }
                                        if (typeof animation.pause === 'function') {
                                            animation.pause();
                                        }
                                        if (typeof animation.goToAndStop === 'function') {
                                            // Go to final frame (finish to final state, not frame 0)
                                            const totalFrames = animation.totalFrames || animation.frameCount || 0;
                                            const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                            animation.goToAndStop(finalFrame, true);
                                        } else if (typeof animation.goToAndPlay === 'function') {
                                            // Fallback: go to end if goToAndStop not available
                                            const totalFrames = animation.totalFrames || animation.frameCount || 0;
                                            const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                            animation.goToAndPlay(finalFrame, true);
                                            if (typeof animation.pause === 'function') {
                                                setTimeout(() => animation.pause(), 0);
                                            }
                                        }
                                        if (animation.autoplay !== undefined) {
                                            animation.autoplay = false;
                                        }
                                        if (animation.loop !== undefined) {
                                            animation.loop = false;
                                        }
                                        if (animation.loopCount !== undefined) {
                                            animation.loopCount = 0;
                                        }
                                        
                                        // CRITICAL: Force paused state
                                        if (animation.isPaused !== undefined) {
                                            animation.isPaused = true;
                                        }
                                        if (animation._isPaused !== undefined) {
                                            animation._isPaused = true;
                                        }
                                        
                                        // CRITICAL: Stop the renderer if it exists
                                        if (animation.renderer) {
                                            try {
                                                if (animation.renderer.stop) {
                                                    animation.renderer.stop();
                                                }
                                                if (animation.renderer.pause) {
                                                    animation.renderer.pause();
                                                }
                                            } catch (_) {}
                                        }
                                        
                                        // CRITICAL: Override play/restart methods in polling to prevent restarts
                                        if (!animation._seizureSafeOriginalPlay) {
                                            animation._seizureSafeOriginalPlay = animation.play;
                                            animation.play = function() {
                                                if (document.body.classList.contains('seizure-safe') || 
                                                    document.documentElement.classList.contains('seizure-safe')) {
                                                    return;
                                                }
                                                return animation._seizureSafeOriginalPlay.apply(this, arguments);
                                            };
                                        }
                                        
                                        if (!animation._seizureSafeOriginalRestart) {
                                            animation._seizureSafeOriginalRestart = animation.restart;
                                            animation.restart = function() {
                                                if (document.body.classList.contains('seizure-safe') || 
                                                    document.documentElement.classList.contains('seizure-safe')) {
                                                    return;
                                                }
                                                return animation._seizureSafeOriginalRestart.apply(this, arguments);
                                            };
                                        }
                                        
                                        if (!animation._seizureSafeOriginalGoToAndPlay) {
                                            animation._seizureSafeOriginalGoToAndPlay = animation.goToAndPlay;
                                            animation.goToAndPlay = function() {
                                                if (document.body.classList.contains('seizure-safe') || 
                                                    document.documentElement.classList.contains('seizure-safe')) {
                                                    if (animation.goToAndStop) {
                                                        const frame = arguments[0] || 0;
                                                        animation.goToAndStop(frame, true);
                                                    }
                                                    return;
                                                }
                                                return animation._seizureSafeOriginalGoToAndPlay.apply(this, arguments);
                                            };
                                        }
                                    }
                                } catch (_) {}
                            });
                        }
                        
                        // Method 3: lottie-web (newer API) - check element instances with comprehensive API calls
                        const lottieElements = document.querySelectorAll('[data-lottie], [data-animation], .lottie, .lottie-animation');
                        lottieElements.forEach(el => {
                            try {
                                const lottieInstance = el._lottie || el.lottie || el.__lottie;
                                if (lottieInstance) {
                                    if (typeof lottieInstance.setSpeed === 'function') {
                                        lottieInstance.setSpeed(0);
                                    }
                                    if (typeof lottieInstance.stop === 'function') {
                                        lottieInstance.stop();
                                    }
                                    if (typeof lottieInstance.pause === 'function') {
                                        lottieInstance.pause();
                                    }
                                    if (typeof lottieInstance.goToAndStop === 'function') {
                                        // Go to final frame (finish to final state, not frame 0)
                                        const totalFrames = lottieInstance.totalFrames || lottieInstance.frameCount || 0;
                                        const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                        lottieInstance.goToAndStop(finalFrame, true);
                                    } else if (typeof lottieInstance.goToAndPlay === 'function') {
                                        // Fallback: go to end if goToAndStop not available
                                        const totalFrames = lottieInstance.totalFrames || lottieInstance.frameCount || 0;
                                        const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                        lottieInstance.goToAndPlay(finalFrame, true);
                                        if (typeof lottieInstance.pause === 'function') {
                                            setTimeout(() => lottieInstance.pause(), 0);
                                        }
                                    }
                                    if (lottieInstance.autoplay !== undefined) {
                                        lottieInstance.autoplay = false;
                                    }
                                    if (lottieInstance.loop !== undefined) {
                                        lottieInstance.loop = false;
                                    }
                                    if (lottieInstance.loopCount !== undefined) {
                                        lottieInstance.loopCount = 0;
                                    }
                                    
                                    // CRITICAL: Override play/restart methods for element-based instances
                                    if (!lottieInstance._seizureSafeOriginalPlay) {
                                        lottieInstance._seizureSafeOriginalPlay = lottieInstance.play;
                                        lottieInstance.play = function() {
                                            if (document.body.classList.contains('seizure-safe') || 
                                                document.documentElement.classList.contains('seizure-safe')) {
                                                return;
                                            }
                                            return lottieInstance._seizureSafeOriginalPlay.apply(this, arguments);
                                        };
                                    }
                                    
                                    if (!lottieInstance._seizureSafeOriginalRestart) {
                                        lottieInstance._seizureSafeOriginalRestart = lottieInstance.restart;
                                        lottieInstance.restart = function() {
                                            if (document.body.classList.contains('seizure-safe') || 
                                                document.documentElement.classList.contains('seizure-safe')) {
                                                return;
                                            }
                                            return lottieInstance._seizureSafeOriginalRestart.apply(this, arguments);
                                        };
                                    }
                                    
                                    if (!lottieInstance._seizureSafeOriginalGoToAndPlay) {
                                        lottieInstance._seizureSafeOriginalGoToAndPlay = lottieInstance.goToAndPlay;
                                        lottieInstance.goToAndPlay = function() {
                                            if (document.body.classList.contains('seizure-safe') || 
                                                document.documentElement.classList.contains('seizure-safe')) {
                                                if (lottieInstance.goToAndStop) {
                                                    const frame = arguments[0] || 0;
                                                    lottieInstance.goToAndStop(frame, true);
                                                }
                                                return;
                                            }
                                            return lottieInstance._seizureSafeOriginalGoToAndPlay.apply(this, arguments);
                                        };
                                    }
                                }
                            } catch (_) {}
                        });
                        
                        // Method 4: Also handle lottie-player web components in polling (already handled in Method 1 above)
                        // Note: lottie-player is handled at the start of this polling function
                    } catch (_) {}
                }, 5); // Check every 5ms (VERY aggressive for Lottie to catch loops)
            }
            
            // Poll for GSAP animations every 50ms (more aggressive)
            if (!this.gsapPollInterval) {
                this.gsapPollInterval = setInterval(() => {
                    try {
                        if (typeof window.gsap !== 'undefined') {
                            // Kill all active tweens globally
                            if (window.gsap.killTweensOf) {
                                window.gsap.killTweensOf('*');
                            }
                            
                            // Kill all timelines and set to final state
                            if (window.gsap.getAllTimelines) {
                                const allTimelines = window.gsap.getAllTimelines();
                                allTimelines.forEach(tl => {
                                    try {
                                        if (tl && typeof tl.totalProgress === 'function') { 
                                            tl.totalProgress(1); 
                                        }
                                        if (tl && typeof tl.pause === 'function') {
                                            tl.pause();
                                        }
                                        if (tl && typeof tl.kill === 'function') {
                                            tl.kill();
                                        }
                                        if (tl && tl.paused !== undefined) {
                                            tl.paused(true);
                                        }
                                    } catch (_) {}
                                });
                            }
                            
                            // Kill all active tweens (alternative method)
                            if (window.gsap.getAllTweens) {
                                const allTweens = window.gsap.getAllTweens();
                                allTweens.forEach(tween => {
                                    try {
                                        if (tween && typeof tween.totalProgress === 'function') { 
                                            tween.totalProgress(1); 
                                        }
                                        if (tween && typeof tween.pause === 'function') {
                                            tween.pause();
                                        }
                                        if (tween && typeof tween.kill === 'function') {
                                            tween.kill();
                                        }
                                        if (tween && tween.paused !== undefined) {
                                            tween.paused(true);
                                        }
                                    } catch (_) {}
                                });
                            }
                            
                            // Clear global timeline
                            if (window.gsap.globalTimeline && typeof window.gsap.globalTimeline.clear === 'function') {
                                try {
                                    window.gsap.globalTimeline.clear();
                                } catch (_) {}
                            }
                        }
                    } catch (_) {}
                }, 15); // Check every 15ms (very aggressive to catch loops)
            }
        }
        
        // Stop continuous polling for Lottie and GSAP animations
        stopLottieGSAPPolling() {
            if (this.lottiePollInterval) {
                clearInterval(this.lottiePollInterval);
                this.lottiePollInterval = null;
            }
            if (this.gsapPollInterval) {
                clearInterval(this.gsapPollInterval);
                this.gsapPollInterval = null;
            }
        }
        
        // Media Replacement: Pause autoplay videos and replace animated GIFs with static placeholders
        replaceAnimatedMedia() {
            try {
                // Pause all autoplay HTML5 video elements
                const videos = document.querySelectorAll('video[autoplay], video[data-autoplay], video[class*="autoplay"]');
                videos.forEach(video => {
                    try {
                        video.pause();
                        video.autoplay = false;
                        video.removeAttribute('autoplay');
                        video.removeAttribute('data-autoplay');
                     
                    } catch (error) {
                        
                    }
                });
                
                // Pause all autoplay audio elements
                const audios = document.querySelectorAll('audio[autoplay], audio[data-autoplay], audio[class*="autoplay"]');
                audios.forEach(audio => {
                    try {
                        audio.pause();
                        audio.autoplay = false;
                        audio.removeAttribute('autoplay');
                        audio.removeAttribute('data-autoplay');
               
                    } catch (error) {
                   
                    }
                });
                
                // Replace animated GIFs with static placeholders (only for seizure-safe mode)
                // Only target images that are likely to be animated based on class names or data attributes
                const animatedImages = document.querySelectorAll('img[class*="animated"], img[class*="gif"], img[data-animated], img[data-gif], img[src*=".gif"][class*="animate"], img[src*=".apng"][class*="animate"], img[src*=".webp"][class*="animate"]');
                animatedImages.forEach(img => {
                    try {
                        // Only replace if the image has animation-related classes or attributes
                        const hasAnimationClass = img.className && (
                            img.className.includes('animated') || 
                            img.className.includes('gif') || 
                            img.className.includes('animate') ||
                            img.className.includes('motion')
                        );
                        const hasAnimationData = img.dataset.animated || img.dataset.gif;
                        
                        if (hasAnimationClass || hasAnimationData) {
                            const src = img.src || img.getAttribute('src') || '';
                            
                            // Store original src for potential restoration
                            if (!img.dataset.originalSrc) {
                                img.dataset.originalSrc = src;
                            }
                            
                            // Create a static placeholder only for confirmed animated images
                            if (src.includes('.gif')) {
                                // Try to replace with a static version if available
                                const staticSrc = src.replace('.gif', '.jpg').replace('.gif', '.png');
                                img.src = staticSrc;
                                img.dataset.animatedReplaced = 'true';
          
                            } else if (src.includes('.apng')) {
                                // For APNG, try to replace with static PNG
                                const staticSrc = src.replace('.apng', '.png');
                                img.src = staticSrc;
                                img.dataset.animatedReplaced = 'true';
                  
                            } else if (src.includes('.webp')) {
                                // For WebP, try to replace with static JPG
                                const staticSrc = src.replace('.webp', '.jpg');
                                img.src = staticSrc;
                                img.dataset.animatedReplaced = 'true';
                              
                            }
                        }
                    } catch (error) {
                       
                    }
                });
                
                // Stop any iframe animations (like embedded videos)
                const iframes = document.querySelectorAll('iframe[src*="youtube"], iframe[src*="vimeo"], iframe[src*="player"]');
                iframes.forEach(iframe => {
                    try {
                        // Try to mute iframe content (but allow visual playback)
                        // Security: Use specific target origins instead of wildcard
                        if (iframe.contentWindow && iframe.contentWindow.postMessage) {
                            const iframeSrc = iframe.src || '';
                            let targetOrigin = '*';
                            try {
                                const iframeUrl = new URL(iframeSrc);
                                targetOrigin = iframeUrl.origin;
                            } catch {
                                // If URL parsing fails, check for known video domains
                                if (iframeSrc.includes('youtube.com') || iframeSrc.includes('youtu.be')) {
                                    targetOrigin = 'https://www.youtube.com';
                                } else if (iframeSrc.includes('vimeo.com')) {
                                    targetOrigin = 'https://player.vimeo.com';
                                }
                            }
                            // Removed pauseVideo - allow videos to play visually while muted
                            // Only send mute commands
                            iframe.contentWindow.postMessage('{"event":"command","func":"mute","args":""}', targetOrigin);
                            iframe.contentWindow.postMessage('{"event":"command","func":"setVolume","args":"0"}', targetOrigin);
                         
                        }
                    } catch (error) {
                        
                    }
                });
                
                // Stop any canvas animations
                const canvases = document.querySelectorAll('canvas');
                canvases.forEach(canvas => {
                    try {
                        
                    } catch (error) {
                  
                    }
                });
                
                
                
            } catch (error) {
                
            }
        }
        
    
        
        // Restore animation libraries when seizure-safe is disabled
        restoreAnimationLibraries() {
            try {
                // Lottie: Resume animations if they were paused
                if (typeof window.lottie !== 'undefined' && window.lottie.getRegisteredAnimations) {
                    const lottieAnimations = window.lottie.getRegisteredAnimations();
                    lottieAnimations.forEach(animation => {
                        try {
                            if (animation && typeof animation.play === 'function') {
                                animation.play();
                             
                            }
                        } catch (error) {
                            
                        }
                    });
                }
                
                // jQuery: Re-enable animations
                if (typeof window.jQuery !== 'undefined' || typeof window.$ !== 'undefined') {
                    try {
                        const $ = window.jQuery || window.$;
                        if ($ && $.fx) {
                            $.fx.off = false; // Re-enable jQuery animations
                       
                        }
                    } catch (error) {
                    
                    }
                }
                
                
            } catch (error) {
          
            }
        }
    
    
    
    
        // Text Color Adjustment Methods
    
        showTextColorPicker() {
    
         
    
            this.hideTextColorPicker();
    
            
    
            // Find the adjust-text-colors module in the panel
    
            const textColorsModule = this.shadowRoot.querySelector('#adjust-text-colors').closest('.profile-item');
    
            
    
            if (textColorsModule) {
    
                // Create color picker content with predefined color swatches
    
                const colorPickerHTML = `
    
                    <div class="color-picker-controls" style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">
    
                        <h4 style="margin: 0 0 15px 0; color: #333; font-size: 14px; font-weight: bold;">Adjust Text Colors</h4>
    
                        <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;">
    
                            <button class="color-swatch" data-color="#0066cc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #0066cc; cursor: pointer; transition: transform 0.2s;" title="Blue"></button>
    
                            <button class="color-swatch" data-color="#6633cc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #6633cc; cursor: pointer; transition: transform 0.2s;" title="Purple"></button>
    
                            <button class="color-swatch" data-color="#cc0000" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #cc0000; cursor: pointer; transition: transform 0.2s;" title="Red"></button>
    
                            <button class="color-swatch" data-color="#ff6600" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #ff6600; cursor: pointer; transition: transform 0.2s;" title="Orange"></button>
    
                            <button class="color-swatch" data-color="#00cccc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #00cccc; cursor: pointer; transition: transform 0.2s;" title="Teal"></button>
    
                            <button class="color-swatch" data-color="#669900" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #669900; cursor: pointer; transition: transform 0.2s;" title="Green"></button>
    
                            <button class="color-swatch" data-color="#ffffff" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #ffffff; cursor: pointer; transition: transform 0.2s;" title="White"></button>
    
                            <button class="color-swatch" data-color="#000000" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #000000; cursor: pointer; transition: transform 0.2s;" title="Black"></button>
    
                        </div>
    
                        <button id="cancel-text-color" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;">
    
                            Cancel
    
                        </button>
    
                    </div>
    
                `;
    
                
    
                const parser = new DOMParser();
                const doc = parser.parseFromString(colorPickerHTML, 'text/html');
                const frag = document.createDocumentFragment();
                Array.from(doc.body.childNodes).forEach(n => {
                    if (n.nodeType === Node.ELEMENT_NODE || n.nodeType === Node.TEXT_NODE) {
                        frag.appendChild(n.cloneNode(true));
                    }
                });
                if (textColorsModule.nextSibling) {
                    textColorsModule.parentNode.insertBefore(frag, textColorsModule.nextSibling);
                } else {
                    textColorsModule.parentNode.appendChild(frag);
                }
    
                
    
                // Add event listeners for color swatches
    
                const colorSwatches = this.shadowRoot.querySelectorAll('.color-swatch');
    
                colorSwatches.forEach(swatch => {
    
                    swatch.addEventListener('click', (e) => {
    
                        const selectedColor = e.target.getAttribute('data-color');
    
                        this.applyTextColor(selectedColor);
    
                    });
    
                    
    
                    // Add hover effect
    
                    swatch.addEventListener('mouseenter', (e) => {
    
                        e.target.style.transform = 'scale(1.05)';
    
                    });
    
                    swatch.addEventListener('mouseleave', (e) => {
    
                        e.target.style.transform = 'scale(1)';
    
                    });
    
                });
    
                
    
                // Add event listener for cancel button
    
                const cancelBtn = this.shadowRoot.getElementById('cancel-text-color');
    
                if (cancelBtn) {
    
                    cancelBtn.addEventListener('click', () => {
    
                        this.hideTextColorPicker();
    
                        // Turn off the toggle switch
    
                        const toggle = this.shadowRoot.querySelector('#adjust-text-colors');
    
                        if (toggle) {
    
                            toggle.checked = false;
    
                            this.handleToggle('adjust-text-colors', false);
    
                        }
    
                    });
    
                }
    
                
    
            } else {
    
            
    
            }
    
        }
    
    
    
        hideTextColorPicker() {
    
       
            const existingPicker = this.shadowRoot.querySelector('.color-picker-controls');
    
            if (existingPicker) {
    
                existingPicker.remove();
    
            }
    
        }
    
    
    
        applyTextColor(color) {
    
           
    
            // Apply color to all text elements
    
            const textElements = document.querySelectorAll('p, span, div, a, li, td, th, label, button, input, textarea, select');
    
            textElements.forEach(element => {
    
                element.style.color = color;
    
            });
    
            
    
            // Save the applied color
    
            this.settings['text-color'] = color;
    
            this.settings['adjust-text-colors'] = true;
    
            this.saveSettings();
    
            
    
            
    
        }
    
    
    
        resetTextColors() {
    
    
            // Remove any custom text color styles
    
            const textElements = document.querySelectorAll('p, span, div, a, li, td, th, label, button, input, textarea, select');
    
            textElements.forEach(element => {
    
                if (element.style.color) {
    
                    element.style.removeProperty('color');
    
                }
    
            });
    
            
    
            this.settings['adjust-text-colors'] = false;
    
            this.settings['text-color'] = null;
    
            this.saveSettings();
    
        }
    
    
    
        showTitleColorPicker() {
    

    
            this.hideTitleColorPicker();
    
            
    
            // Find the adjust-title-colors module in the panel
    
            const titleColorsModule = this.shadowRoot.querySelector('#adjust-title-colors').closest('.profile-item');
    
            
    
            if (titleColorsModule) {
    
                // Create color picker content with predefined color swatches
    
                const colorPickerHTML = `
    
                    <div class="title-color-picker-controls" style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">
    
                        <h4 style="margin: 0 0 15px 0; color: #333; font-size: 14px; font-weight: bold;">Adjust Title Colors</h4>
    
                        <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;">
    
                            <button class="title-color-swatch" data-color="#0066cc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #0066cc; cursor: pointer; transition: transform 0.2s;" title="Blue"></button>
    
                            <button class="title-color-swatch" data-color="#6633cc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #6633cc; cursor: pointer; transition: transform 0.2s;" title="Purple"></button>
    
                            <button class="title-color-swatch" data-color="#cc0000" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #cc0000; cursor: pointer; transition: transform 0.2s;" title="Red"></button>
    
                            <button class="title-color-swatch" data-color="#ff6600" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #ff6600; cursor: pointer; transition: transform 0.2s;" title="Orange"></button>
    
                            <button class="title-color-swatch" data-color="#00cccc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #00cccc; cursor: pointer; transition: transform 0.2s;" title="Teal"></button>
    
                            <button class="title-color-swatch" data-color="#669900" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #669900; cursor: pointer; transition: transform 0.2s;" title="Green"></button>
    
                            <button class="title-color-swatch" data-color="#ffffff" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #ffffff; cursor: pointer; transition: transform 0.2s;" title="White"></button>
    
                            <button class="title-color-swatch" data-color="#000000" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #000000; cursor: pointer; transition: transform 0.2s;" title="Black"></button>
    
                        </div>
    
                        <button id="cancel-title-color" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;">
    
                            Cancel
    
                        </button>
    
                    </div>
    
                `;
    
                
    
                const parser2 = new DOMParser();
                const doc2 = parser2.parseFromString(colorPickerHTML, 'text/html');
                const frag2 = document.createDocumentFragment();
                Array.from(doc2.body.childNodes).forEach(n => {
                    if (n.nodeType === Node.ELEMENT_NODE || n.nodeType === Node.TEXT_NODE) {
                        frag2.appendChild(n.cloneNode(true));
                    }
                });
                if (titleColorsModule.nextSibling) {
                    titleColorsModule.parentNode.insertBefore(frag2, titleColorsModule.nextSibling);
                } else {
                    titleColorsModule.parentNode.appendChild(frag2);
                }
    
                
    
                // Add event listeners for color swatches
    
                const colorSwatches = this.shadowRoot.querySelectorAll('.title-color-swatch');
    
                colorSwatches.forEach(swatch => {
    
                    swatch.addEventListener('click', (e) => {
    
                        const selectedColor = e.target.getAttribute('data-color');
    
                        this.applyTitleColor(selectedColor);
    
                    });
    
                    
    
                    // Add hover effect
    
                    swatch.addEventListener('mouseenter', (e) => {
    
                        e.target.style.transform = 'scale(1.05)';
    
                    });
    
                    swatch.addEventListener('mouseleave', (e) => {
    
                        e.target.style.transform = 'scale(1)';
    
                    });
    
                });
    
                
    
                // Add event listener for cancel button
    
                const cancelBtn = this.shadowRoot.getElementById('cancel-title-color');
    
                if (cancelBtn) {
    
                    cancelBtn.addEventListener('click', () => {
    
                        this.hideTitleColorPicker();
    
                        // Turn off the toggle switch
    
                        const toggle = this.shadowRoot.querySelector('#adjust-title-colors');
    
                        if (toggle) {
    
                            toggle.checked = false;
    
                            this.handleToggle('adjust-title-colors', false);
    
                        }
    
                    });
    
                }
    
                
    
    
            } else {
    
              
    
            }
    
        }
    
    
    
        hideTitleColorPicker() {
    
    
            const existingPicker = this.shadowRoot.querySelector('.title-color-picker-controls');
    
            if (existingPicker) {
    
                existingPicker.remove();
    
            }
    
        }
    
    
    
        applyTitleColor(color) {
    
         
            // Apply color to all title elements
    
            const titleElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
            titleElements.forEach(element => {
    
                element.style.color = color;
    
            });
    
            
    
            // Save the applied color
    
            this.settings['title-color'] = color;
    
            this.settings['adjust-title-colors'] = true;
    
            this.saveSettings();
    
            
    

    
        }
    
    
    
        resetTitleColors() {
    
   
    
            // Remove any custom title color styles
    
            const titleElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
            titleElements.forEach(element => {
    
                if (element.style.color) {
    
                    element.style.removeProperty('color');
    
                }
    
            });
    
            
    
            this.settings['adjust-title-colors'] = false;
    
            this.settings['title-color'] = null;
    
            this.saveSettings();
    
       
    
        }
    
    
    
        showBackgroundColorPicker() {
    
    
            this.hideBackgroundColorPicker();
    
            
    
            // Find the adjust-bg-colors module in the panel
    
            const bgColorsModule = this.shadowRoot.querySelector('#adjust-bg-colors').closest('.profile-item');
    
            
    
            if (bgColorsModule) {
    
                // Create color picker content with predefined color swatches
    
                const colorPickerHTML = `
    
                    <div class="bg-color-picker-controls" style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">
    
                        <h4 style="margin: 0 0 15px 0; color: #333; font-size: 14px; font-weight: bold;">Adjust Background Colors</h4>
    
                        <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;">
    
                            <button class="bg-color-swatch" data-color="#0066cc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #0066cc; cursor: pointer; transition: transform 0.2s;" title="Blue"></button>
    
                            <button class="bg-color-swatch" data-color="#6633cc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #6633cc; cursor: pointer; transition: transform 0.2s;" title="Purple"></button>
    
                            <button class="bg-color-swatch" data-color="#cc0000" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #cc0000; cursor: pointer; transition: transform 0.2s;" title="Red"></button>
    
                            <button class="bg-color-swatch" data-color="#ff6600" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #ff6600; cursor: pointer; transition: transform 0.2s;" title="Orange"></button>
    
                            <button class="bg-color-swatch" data-color="#00cccc" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #00cccc; cursor: pointer; transition: transform 0.2s;" title="Teal"></button>
    
                            <button class="bg-color-swatch" data-color="#669900" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #669900; cursor: pointer; transition: transform 0.2s;" title="Green"></button>
    
                            <button class="bg-color-swatch" data-color="#ffffff" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #ffffff; cursor: pointer; transition: transform 0.2s;" title="White"></button>
    
                            <button class="bg-color-swatch" data-color="#000000" style="width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; background: #000000; cursor: pointer; transition: transform 0.2s;" title="Black"></button>
    
                        </div>
    
                        <button id="cancel-bg-color" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;">
    
                            Cancel
    
                        </button>
    
                    </div>
    
                `;
    
                
    
                const parser3 = new DOMParser();
                const doc3 = parser3.parseFromString(colorPickerHTML, 'text/html');
                const frag3 = document.createDocumentFragment();
                Array.from(doc3.body.childNodes).forEach(n => {
                    if (n.nodeType === Node.ELEMENT_NODE || n.nodeType === Node.TEXT_NODE) {
                        frag3.appendChild(n.cloneNode(true));
                    }
                });
                if (bgColorsModule.nextSibling) {
                    bgColorsModule.parentNode.insertBefore(frag3, bgColorsModule.nextSibling);
                } else {
                    bgColorsModule.parentNode.appendChild(frag3);
                }
    
                
    
                // Add event listeners for color swatches
    
                const colorSwatches = this.shadowRoot.querySelectorAll('.bg-color-swatch');
    
                colorSwatches.forEach(swatch => {
    
                    swatch.addEventListener('click', (e) => {
    
                        const selectedColor = e.target.getAttribute('data-color');
    
                        this.applyBackgroundColor(selectedColor);
    
                    });
    
                    
    
                    // Add hover effect
    
                    swatch.addEventListener('mouseenter', (e) => {
    
                        e.target.style.transform = 'scale(1.05)';
    
                    });
    
                    swatch.addEventListener('mouseleave', (e) => {
    
                        e.target.style.transform = 'scale(1)';
    
                    });
    
                });
    
                
    
                // Add event listener for cancel button
    
                const cancelBtn = this.shadowRoot.getElementById('cancel-bg-color');
    
                if (cancelBtn) {
    
                    cancelBtn.addEventListener('click', () => {
    
                        this.hideBackgroundColorPicker();
    
                        // Turn off the toggle switch
    
                        const toggle = this.shadowRoot.querySelector('#adjust-bg-colors');
    
                        if (toggle) {
    
                            toggle.checked = false;
    
                            this.handleToggle('adjust-bg-colors', false);
    
                        }
    
                    });
    
                }
    
                
    
            } else {
    
               
    
            }
    
        }
    
    
    
        hideBackgroundColorPicker() {
    
            const existingPicker = this.shadowRoot.querySelector('.bg-color-picker-controls');
    
            if (existingPicker) {
    
                existingPicker.remove();
    
            
    
            }
    
        }
    
    
    
        applyBackgroundColor(color) {
    
           
            
    
            // Apply background color only to specific content areas, not the entire page
    
            const mainContentAreas = document.querySelectorAll('section, article, main, .container, .hero, .about, .services, .test-section, .hero-content, .about-content, .services-grid, .service-card, .test-block, .contact-form, .contact-info');
    
            
    
            mainContentAreas.forEach(element => {
    
                // Skip accessibility panel elements
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    // Apply background color to specific content areas only
    
                    element.style.backgroundColor = color;
    
                }
    
            });
    
            
    
            // Also apply to any remaining elements that might have backgrounds
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(element => {
    
                // Skip accessibility panel elements and elements that already have the color
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon') && 
    
                    element.style.backgroundColor !== color) {
    
                    
    
                    // Check if element has a background that's not transparent
    
                    const computedStyle = window.getComputedStyle(element);
    
                    const bgColor = computedStyle.backgroundColor;
    
                    
    
                    // If element has a background that's not transparent, apply our color
    
                    if (bgColor !== 'rgba(0, 0, 0, 0)' && 
    
                        bgColor !== 'transparent' && 
    
                        bgColor !== color &&
    
                        !element.classList.contains('color-option') && // Don't change color picker colors
    
                        !element.classList.contains('cancel-btn')) { // Don't change button colors
    
                        element.style.backgroundColor = color;
    
                    }
    
                }
    
            });
    
            
    
            // Store the selected color
    
            this.selectedBackgroundColor = color;
    
            this.settings['bg-color'] = color;
    
            this.settings['adjust-bg-colors'] = true;
    
            this.saveSettings();
    
         
    
        }
    
    
    
        resetBackgroundColors() {
    
         
    
            
    
            // Reset html and body background
    
            document.documentElement.style.backgroundColor = '';
    
            document.body.style.backgroundColor = '';
    
            
    
            // Reset all main content areas
    
            const mainContentAreas = document.querySelectorAll('html, body, div, section, article, main, aside, header, footer, nav, .container, .hero, .about, .services, .test-section, .hero-content, .about-content, .services-grid, .service-card, .test-block');
    
            
    
            mainContentAreas.forEach(element => {
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
    
                    element.style.backgroundColor = '';
    
                }
    
            });
    
            
    
            // Reset all other elements that might have been changed
    
            const allElements = document.querySelectorAll('*');
    
            allElements.forEach(element => {
    
                if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon') &&
    
                    !element.classList.contains('color-option') && 
    
                    !element.classList.contains('cancel-btn')) {
    
                    // Reset if we applied a background color to it
    
                    if (element.style.backgroundColor && element.style.backgroundColor !== '') {
    
                        element.style.backgroundColor = '';
    
                    }
    
                }
    
            });
    
            
    
            this.selectedBackgroundColor = null;
    
            this.settings['adjust-bg-colors'] = false;
    
            this.settings['bg-color'] = null;
    
            this.saveSettings();
    
          
    
        }
    
    
    
        // Seizure Safe Profile Methods
    
        enableSeizureSafe(immediate = false) {
            // Disable other mutually exclusive features
            if (this.settings['vision-impaired']) { this.disableVisionImpaired(); this.updateToggleSwitch('vision-impaired', false); }
            if (this.settings['adhd-friendly']) { this.disableADHDFriendly(); this.updateToggleSwitch('adhd-friendly', false); }
            if (this.settings['cognitive-disability']) { this.disableCognitiveDisability(); this.updateToggleSwitch('cognitive-disability', false); }
            
            this.settings['seizure-safe'] = true;
            document.body.classList.add('seizure-safe');
            try { document.documentElement.classList.add('seizure-safe'); } catch (_) {}
            this.saveSettings();
            
            // CRITICAL: Inject the SAME early CSS that runs on page load
            // This must happen FIRST, before any other operations
            try {
                if (!document.getElementById('accessbit-seizure-immediate-early')) {
                    const immediateStyle = document.createElement('style');
                    immediateStyle.id = 'accessbit-seizure-immediate-early';
                    immediateStyle.textContent = `
                        /* Per Webflow Security recommendations: Global CSS kill switch for seizure-safe mode */
                        body.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]):not(accessbit-widget),
                        html.seizure-safe *:not(nav):not(header):not(.navbar):not([class*="nav"]):not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not([data-ck-widget]):not(accessbit-widget) {
                            animation: none !important;
                            transition: none !important;
                            scroll-behavior: auto !important;
                        }
                    `;
                    document.head.appendChild(immediateStyle);
                }
            } catch (_) {}
            
            // 1) Grey overlay (light, non-sticky-breaking)
            this.addSeizureSafeGreyOverlay();
            // 2) CSS kill switch (additional comprehensive rules)
            this.injectSeizureSafeAnimationCSS();
            
            // CRITICAL: Force browser to apply CSS immediately before stopping animations
            // This ensures CSS rules take effect before we try to stop animations
            try {
                // Force a reflow to ensure CSS is applied
                void document.body.offsetHeight;
                // Also force reflow on documentElement
                void document.documentElement.offsetHeight;
                // Force style recalculation
                getComputedStyle(document.body);
                
                // CRITICAL: Also apply animation: none directly to ALL elements via JavaScript
                // This ensures CSS takes effect even if stylesheet hasn't fully loaded
                const allElements = document.querySelectorAll('*');
                for (let i = 0; i < Math.min(allElements.length, 10000); i++) {
                    try {
                        const el = allElements[i];
                        // Skip widget elements
                        if (el.closest('#accessbit-widget-container') || 
                            el.closest('[id*="accessbit-widget"]') || 
                            el.closest('[class*="accessbit-widget"]')) {
                            continue;
                        }
                        // Skip nav/header elements
                        if (el.closest('nav') || el.closest('header') || 
                            el.closest('.navbar') || el.closest('[class*="nav"]') || 
                            el.closest('[class*="header"]')) {
                            continue;
                        }
                        el.style.setProperty('animation', 'none', 'important');
                        el.style.setProperty('transition', 'none', 'important');
                    } catch (_) {}
                }
            } catch (_) {}
            
            // 3) WAAPI pause/cancel running animations (no globals)
            try { window.seizureState?.applyWAAPIStopMotion?.(true); } catch (_) {}
            
            // CRITICAL: Override loadAnimation IMMEDIATELY to prevent new animations
            try {
                if (typeof window.lottie !== 'undefined' && typeof window.lottie.loadAnimation === 'function') {
                    if (!window.seizureState) window.seizureState = {};
                    if (!window.seizureState.originalLottieLoadAnimation) {
                        window.seizureState.originalLottieLoadAnimation = window.lottie.loadAnimation;
                    }
                    window.lottie.loadAnimation = function(config) {
                        const anim = window.seizureState.originalLottieLoadAnimation.call(this, config);
                        // Immediately stop the newly loaded animation
                        if (anim) {
                            try {
                                if (typeof anim.setSpeed === 'function') anim.setSpeed(0);
                                if (typeof anim.stop === 'function') anim.stop();
                                if (typeof anim.pause === 'function') anim.pause();
                                if (anim.loop !== undefined) anim.loop = false;
                                if (anim.loopCount !== undefined) anim.loopCount = 0;
                                // Cancel any requestAnimationFrame
                                if (anim.animationID !== undefined && anim.animationID !== null) {
                                    try { cancelAnimationFrame(anim.animationID); anim.animationID = null; } catch (_) {}
                                }
                                if (anim.renderer && anim.renderer.animationID !== undefined && anim.renderer.animationID !== null) {
                                    try { cancelAnimationFrame(anim.renderer.animationID); anim.renderer.animationID = null; } catch (_) {}
                                }
                            } catch (_) {}
                        }
                        return anim;
                    };
                }
            } catch (_) {}
            
            // CRITICAL: Freeze ALL canvas and SVG elements immediately via DOM
            try {
                const allCanvases = document.querySelectorAll('canvas');
                allCanvases.forEach(canvas => {
                    try {
                        canvas.style.setProperty('animation', 'none', 'important');
                        canvas.style.setProperty('transition', 'none', 'important');
                        canvas.style.setProperty('pointer-events', 'none', 'important');
                        canvas.setAttribute('data-seizure-safe-frozen', 'true');
                        // Try to get context and prevent drawing
                        try {
                            const ctx = canvas.getContext('2d');
                            if (ctx && ctx.clearRect) {
                                // Don't clear, just mark as frozen
                            }
                        } catch (_) {}
                    } catch (_) {}
                });
                
                const allSvgs = document.querySelectorAll('svg');
                allSvgs.forEach(svg => {
                    try {
                        svg.style.setProperty('animation', 'none', 'important');
                        svg.style.setProperty('transition', 'none', 'important');
                        svg.setAttribute('data-seizure-safe-frozen', 'true');
                    } catch (_) {}
                });
            } catch (_) {}
            
            // CRITICAL: Stop Lottie animations IMMEDIATELY like early initialization does
            // This must happen BEFORE other stopping functions to catch looped animations
            try {
                // Method 1: Stop via registered animations API
                if (typeof window.lottie !== 'undefined' && window.lottie.getRegisteredAnimations) {
                    const lottieAnimations = window.lottie.getRegisteredAnimations();
                    lottieAnimations.forEach(animation => {
                        try {
                            if (animation && typeof animation.stop === 'function') {
                                animation.stop();
                            }
                            if (animation && typeof animation.pause === 'function') {
                                animation.pause();
                            }
                            // CRITICAL: Cancel requestAnimationFrame loops immediately
                            if (animation.animationID !== undefined && animation.animationID !== null) {
                                try {
                                    cancelAnimationFrame(animation.animationID);
                                    animation.animationID = null;
                                } catch (_) {}
                            }
                            if (animation.renderer && animation.renderer.animationID !== undefined && animation.renderer.animationID !== null) {
                                try {
                                    cancelAnimationFrame(animation.renderer.animationID);
                                    animation.renderer.animationID = null;
                                } catch (_) {}
                            }
                            if (animation._animationID !== undefined && animation._animationID !== null) {
                                try {
                                    cancelAnimationFrame(animation._animationID);
                                    animation._animationID = null;
                                } catch (_) {}
                            }
                            // Disable looping immediately
                            if (animation.loop !== undefined) {
                                animation.loop = false;
                            }
                            if (animation.loopCount !== undefined) {
                                animation.loopCount = 0;
                            }
                            if (animation.setSpeed && typeof animation.setSpeed === 'function') {
                                animation.setSpeed(0);
                            }
                            // Freeze the renderer directly
                            if (animation.renderer) {
                                try {
                                    if (animation.renderer.canvas) {
                                        animation.renderer.canvas.style.setProperty('animation', 'none', 'important');
                                        animation.renderer.canvas.style.setProperty('transition', 'none', 'important');
                                        animation.renderer.canvas.setAttribute('data-seizure-safe-frozen', 'true');
                                    }
                                    if (animation.renderer.svgElement) {
                                        animation.renderer.svgElement.style.setProperty('animation', 'none', 'important');
                                        animation.renderer.svgElement.style.setProperty('transition', 'none', 'important');
                                        animation.renderer.svgElement.setAttribute('data-seizure-safe-frozen', 'true');
                                    }
                                } catch (_) {}
                            }
                        } catch (_) {}
                    });
                }
                
                // Method 2: Stop lottie-player web components directly via DOM
                const lottiePlayers = document.querySelectorAll('lottie-player');
                lottiePlayers.forEach(player => {
                    try {
                        if (typeof player.setSpeed === 'function') {
                            player.setSpeed(0);
                        }
                        if (typeof player.stop === 'function') {
                            player.stop();
                        }
                        if (typeof player.pause === 'function') {
                            player.pause();
                        }
                        player.setAttribute('autoplay', 'false');
                        player.removeAttribute('loop');
                        player.setAttribute('loop', 'false');
                    } catch (_) {}
                });
            } catch (_) {}
            
            // CRITICAL: Call the same early initialization functions that run on page load
            // These do direct DOM manipulation to freeze animations immediately
            try { 
                window.seizureState?.applySeizureSafeDOMFreeze?.(); 
            } catch (_) {}
            try { 
                window.seizureState?.seizureConsolidateSplitText?.(); 
            } catch (_) {}
            try { 
                window.seizureState?.installStyleSanitizer?.(); 
            } catch (_) {}
            
            // CRITICAL: Stop animations IMMEDIATELY and MULTIPLE TIMES when toggled on
            // This ensures we catch animations that are already running
            // Run synchronously in a tight loop first to catch animations immediately
            for (let i = 0; i < 10; i++) {
                this.stopAnimationLibraries();
                this.stopAllLottieAnimations();
                this.stopAutoplayMedia();
                this.stopJavaScriptAnimations();
                try { this.stopWebflowInteractions && this.stopWebflowInteractions(); } catch (_) {}
                this.aggressivelyStopAllAnimations();
                // Also call DOM freeze in the loop
                try { window.seizureState?.applySeizureSafeDOMFreeze?.(); } catch (_) {}
            }
            
            // 4) Start polling IMMEDIATELY for continuous stopping (before any animations can restart)
            this.startLottieGSAPPolling();
            
            // 5) Start aggressive periodic animation stopping IMMEDIATELY (no global overrides)
            this.startAggressiveAnimationStopping();
            
            // CRITICAL: Run stopping functions again after micro-delays to catch any that restarted
            // Use requestAnimationFrame to run in the next frame
            requestAnimationFrame(() => {
                this.stopAnimationLibraries();
                this.stopAllLottieAnimations();
                this.stopAutoplayMedia();
                this.stopJavaScriptAnimations();
                try { this.stopWebflowInteractions && this.stopWebflowInteractions(); } catch (_) {}
                this.aggressivelyStopAllAnimations();
                try { window.seizureState?.applySeizureSafeDOMFreeze?.(); } catch (_) {}
            });
            
            // Run again after a tiny delay
            setTimeout(() => {
                this.stopAnimationLibraries();
                this.stopAllLottieAnimations();
                this.stopAutoplayMedia();
                this.stopJavaScriptAnimations();
                try { this.stopWebflowInteractions && this.stopWebflowInteractions(); } catch (_) {}
                this.aggressivelyStopAllAnimations();
                try { window.seizureState?.applySeizureSafeDOMFreeze?.(); } catch (_) {}
            }, 0);
            
            // Run again after another tiny delay
            setTimeout(() => {
                this.stopAnimationLibraries();
                this.stopAllLottieAnimations();
                this.stopAutoplayMedia();
                this.stopJavaScriptAnimations();
                try { this.stopWebflowInteractions && this.stopWebflowInteractions(); } catch (_) {}
                this.aggressivelyStopAllAnimations();
                try { window.seizureState?.applySeizureSafeDOMFreeze?.(); } catch (_) {}
            }, 10);
            
            // Run again after a slightly longer delay
            setTimeout(() => {
                this.stopAnimationLibraries();
                this.stopAllLottieAnimations();
                this.stopAutoplayMedia();
                this.stopJavaScriptAnimations();
                try { this.stopWebflowInteractions && this.stopWebflowInteractions(); } catch (_) {}
                this.aggressivelyStopAllAnimations();
                try { window.seizureState?.applySeizureSafeDOMFreeze?.(); } catch (_) {}
            }, 50);
            
            // Run again after 100ms to catch any late starters
            setTimeout(() => {
                this.stopAnimationLibraries();
                this.stopAllLottieAnimations();
                this.stopAutoplayMedia();
                this.stopJavaScriptAnimations();
                try { this.stopWebflowInteractions && this.stopWebflowInteractions(); } catch (_) {}
                this.aggressivelyStopAllAnimations();
                try { window.seizureState?.applySeizureSafeDOMFreeze?.(); } catch (_) {}
            }, 100);
            
            // CRITICAL: Also stop jQuery animations like the early initialization does
            try {
                if (typeof window.jQuery !== 'undefined' || typeof window.$ !== 'undefined') {
                    const $ = window.jQuery || window.$;
                    if ($ && $.fx) {
                        $.fx.off = true;
                    }
                }
            } catch (_) {}
        }
        
        // Aggressive periodic animation stopping - directly manipulates element styles
        // This runs periodically to catch any animations that start after initial stopping
        startAggressiveAnimationStopping() {
            // Clear any existing interval
            if (this._aggressiveAnimationStopperInterval) {
                clearInterval(this._aggressiveAnimationStopperInterval);
            }
            
            // Run immediately
            this.aggressivelyStopAllAnimations();
            
            // Then run every 5ms to catch new animations even more aggressively
            this._aggressiveAnimationStopperInterval = setInterval(() => {
                this.aggressivelyStopAllAnimations();
            }, 5);
        }
        
        stopAggressiveAnimationStopping() {
            if (this._aggressiveAnimationStopperInterval) {
                clearInterval(this._aggressiveAnimationStopperInterval);
                this._aggressiveAnimationStopperInterval = null;
            }
        }
        
        aggressivelyStopAllAnimations() {
            try {
                // Check if seizure-safe or stop-animation is active
                const isSeizureSafe = document.body.classList.contains('seizure-safe') || 
                                     document.documentElement.classList.contains('seizure-safe');
                const isStopAnimation = document.body.classList.contains('stop-animation') || 
                                       document.documentElement.classList.contains('stop-animation');
                
                if (!isSeizureSafe && !isStopAnimation) {
                    return; // Don't run if neither is active
                }
                
                // Stop all WAAPI animations globally first
                try {
                    if (document.getAnimations) {
                        const allAnims = document.getAnimations({ subtree: true });
                        allAnims.forEach(anim => {
                            try {
                                if (typeof anim.finish === 'function') {
                                    anim.finish();
                                } else if (anim.effect && anim.effect.getComputedTiming) {
                                    const timing = anim.effect.getComputedTiming();
                                    const end = timing.endTime != null ? timing.endTime : 
                                               (timing.duration != null && timing.duration !== 'auto' ? timing.duration : null);
                                    if (end != null) {
                                        anim.currentTime = end;
                                    }
                                }
                                if (typeof anim.pause === 'function') anim.pause();
                                anim.playbackRate = 0;
                            } catch (_) {}
                        });
                    }
                } catch (_) {}
                
                // Get all elements (excluding widget elements)
                const allElements = document.querySelectorAll('*:not(#accessbit-widget-container):not([id*="accessbit-widget"]):not([class*="accessbit-widget"]):not(accessbit-widget)');
                
                allElements.forEach(el => {
                    try {
                        // Skip if element is inside widget
                        if (el.closest('#accessbit-widget-container') || 
                            el.closest('[id*="accessbit-widget"]') || 
                            el.closest('[class*="accessbit-widget"]') ||
                            el.closest('accessbit-widget')) {
                            return;
                        }
                        
                        // Get computed style
                        const computedStyle = window.getComputedStyle(el);
                        
                        // Check if element has animations or transitions
                        const hasAnimation = computedStyle.animationName !== 'none' && computedStyle.animationName !== '';
                        const hasTransition = computedStyle.transitionProperty !== 'none' && computedStyle.transitionProperty !== '';
                        
                        // Directly stop animations/transitions with !important
                        if (hasAnimation || hasTransition) {
                            el.style.setProperty('animation', 'none', 'important');
                            el.style.setProperty('transition', 'none', 'important');
                            el.style.setProperty('animation-play-state', 'paused', 'important');
                            el.style.setProperty('animation-duration', '0s', 'important');
                            el.style.setProperty('transition-duration', '0s', 'important');
                        }
                        
                        // Also stop any WAAPI animations on this element
                        if (el.getAnimations) {
                            try {
                                const anims = el.getAnimations();
                                anims.forEach(anim => {
                                    try {
                                        if (typeof anim.finish === 'function') {
                                            anim.finish();
                                        } else if (anim.effect && anim.effect.getComputedTiming) {
                                            const timing = anim.effect.getComputedTiming();
                                            const end = timing.endTime != null ? timing.endTime : 
                                                       (timing.duration != null && timing.duration !== 'auto' ? timing.duration : null);
                                            if (end != null) {
                                                anim.currentTime = end;
                                            }
                                        }
                                        if (typeof anim.pause === 'function') anim.pause();
                                        anim.playbackRate = 0;
                                    } catch (_) {}
                                });
                            } catch (_) {}
                        }
                    } catch (_) {}
                });
                
                // Use existing public API functions instead of duplicating code
                // Call stopAnimationLibraries which uses the official Lottie and GSAP APIs
                try {
                    this.stopAnimationLibraries();
                } catch (_) {}
                
                // CRITICAL: Also call stopAllLottieAnimations directly to ensure Lottie is stopped
                try {
                    this.stopAllLottieAnimations();
                } catch (_) {}
                
                // CRITICAL: Also stop autoplay media and JS animations in aggressive loop
                try {
                    this.stopAutoplayMedia();
                } catch (_) {}
                try {
                    this.stopJavaScriptAnimations();
                } catch (_) {}
                try {
                    this.stopWebflowInteractions && this.stopWebflowInteractions();
                } catch (_) {}
                
                // Stop slider autoplay (Swiper, Webflow sliders, etc.)
                try {
                    this.stopSliderAutoplay();
                } catch (_) {}
            } catch (e) {}
        }
    
    
    
        // REMOVED: enforceNativeScroll function that was blocking scroll
    
        disableSeizureSafe() {
            // 1. Remove CSS rules for seizure-safe animation stopping FIRST
            const existingAnimationStyle = document.getElementById('seizure-safe-animation-css');
            if (existingAnimationStyle) {
                existingAnimationStyle.remove();
            }
            
            // 2. Remove grey overlay
            const existingGreyOverlay = document.getElementById('accessbit-seizure-safe-grey-overlay');
            if (existingGreyOverlay) {
                existingGreyOverlay.remove();
            }
            
            // 3. Remove old styles if they exist (backward compatibility)
            this.removeSeizureSafeStyles();
            
            // 4. Remove seizure-safe class from body and html
            this.safeBodyClassToggle('seizure-safe', false);
            document.documentElement.classList.remove('seizure-safe');
            
            // 5. Stop continuous polling for Lottie and GSAP
            this.stopLottieGSAPPolling();
            
            // 6. Stop aggressive animation stopping
            this.stopAggressiveAnimationStopping();
            
            // 7. Clean up Lottie event interceptor
            if (seizureState && seizureState.lottieAnimObserver) {
                try {
                    seizureState.lottieAnimObserver.disconnect();
                    seizureState.lottieAnimObserver = null;
                } catch (_) {}
            }
            if (seizureState && seizureState.lottieDOMFreezeObserver) {
                try {
                    seizureState.lottieDOMFreezeObserver.disconnect();
                    seizureState.lottieDOMFreezeObserver = null;
                } catch (_) {}
            }
            if (seizureState) {
                seizureState.lottieEventInterceptorActive = false;
            }
            
            // 8. Restore frozen canvas/SVG elements
            try {
                const frozenElements = document.querySelectorAll('[data-seizure-safe-frozen]');
                frozenElements.forEach(el => {
                    try {
                        el.style.removeProperty('animation');
                        el.style.removeProperty('transition');
                        el.style.removeProperty('pointer-events');
                        el.removeAttribute('data-seizure-safe-frozen');
                    } catch (_) {}
                });
            } catch (_) {}
            
            // 7. Restore WAAPI animations
            try {
                if (window.seizureState && window.seizureState.applyWAAPIStopMotion) {
                    window.seizureState.applyWAAPIStopMotion(false);
                }
            } catch (_) {}
            
            this.settings['seizure-safe'] = false;
            this.saveSettings();
            
            // Update widget appearance to sync Shadow DOM host classes
            this.updateWidgetAppearance();
        }
    
        // Vision Impaired - comprehensive scaling and contrast enhancement
        enableVisionImpaired() {
            try {
                // Disable other mutually exclusive features
                if (this.settings['seizure-safe']) {
                    this.disableSeizureSafe();
                    this.updateToggleSwitch('seizure-safe', false);
                }
                if (this.settings['adhd-friendly']) {
                    this.disableADHDFriendly();
                    this.updateToggleSwitch('adhd-friendly', false);
                }
                if (this.settings['cognitive-disability']) {
                    this.disableCognitiveDisability();
                    this.updateToggleSwitch('cognitive-disability', false);
                }
                
                this.settings['vision-impaired'] = true;
                document.body.classList.add('vision-impaired');
                document.documentElement.classList.add('vision-impaired');

                // Apply vision impaired class to the accessibility widget
                if (this.shadowRoot && this.shadowRoot.host) {
                    this.shadowRoot.host.classList.add('vision-impaired');
                }
                
                // Also apply to the widget container if it exists
                const widget = document.querySelector('.accessbit-widget');
                if (widget) {
                    widget.classList.add('vision-impaired');
                }

                // Update toggle switch in UI
                const viToggle = this.shadowRoot?.getElementById('vision-impaired');
                if (viToggle) {
                    viToggle.checked = true;
                }

                // Apply comprehensive website scaling and contrast enhancement
                this.applyVisionImpaired(true);

                // CRITICAL FIX: Also save to the separate localStorage key that sync functions use
                localStorage.setItem('accessbit-widget-vision-impaired', 'true');

                // Persist and sync
                this.saveSettings();
                this.updateWidgetAppearance();
           
            } catch (e) {
            }
        }
        
        // Vision Impaired helper: apply simple zoom and brightness
        applyVisionImpaired(on) {
            // CRITICAL: Don't manipulate Designer DOM
            if (this.isDesignerMode()) {
                return;
            }
            
            try {
                // Toggle root classes
                document.documentElement.classList.toggle('vision-impaired', !!on);
                document.body.classList.toggle('vision-impaired', !!on);

                // Remove content wrapper if it exists (cleanup from old implementation)
                const wrapper = document.getElementById('accessbit-content-wrapper');
                if (wrapper && !on) {
                    // Move all wrapper children back to body
                    while (wrapper.firstChild) {
                        document.body.insertBefore(wrapper.firstChild, wrapper);
                    }
                    wrapper.remove();
                }
                
                let style = document.getElementById('accessbit-vision-impaired-immediate-early');
                if (!style && on) {
                    style = document.createElement('style');
                    style.id = 'accessbit-vision-impaired-immediate-early';
                    document.head.appendChild(style);
                } else if (!on && style) {
                    style.remove();
                    return;
                }
                
                if (!on) return;
                
                style.textContent = `
            /* VISION IMPAIRED: Keep typography intact; small brightness bump + gentle centered zoom */
            
            html.vision-impaired {
                /* No zoom or layout changes */
            }
            
            body.vision-impaired {
                overflow-x: hidden !important;
            }
            
            /* CRITICAL: Apply brightness filter ONLY to media inside main content areas - NEVER to nav/header */
            /* Filters create stacking contexts that break sticky positioning - so we avoid them on nav ancestors */
            body.vision-impaired main img,
            body.vision-impaired main video,
            body.vision-impaired main picture,
            body.vision-impaired main canvas,
            body.vision-impaired main svg,
            body.vision-impaired section img,
            body.vision-impaired section video,
            body.vision-impaired section picture,
            body.vision-impaired section canvas,
            body.vision-impaired section svg,
            body.vision-impaired article img,
            body.vision-impaired article video,
            body.vision-impaired article picture,
            body.vision-impaired article canvas,
            body.vision-impaired article svg {
                filter: brightness(1.06) !important;
                -webkit-filter: brightness(1.06) !important;
            }
            
            /* Gentle zoom for main content only, anchored at top to avoid pushing nav off-screen */
            body.vision-impaired main,
            body.vision-impaired [role="main"],
            body.vision-impaired .main-content,
            body.vision-impaired .page-wrapper {
                transform: scale(1.02);
                transform-origin: top center;
            }
            
            /* Exclude widget from scaling and brightness */
            body.vision-impaired .accessbit-widget,
            body.vision-impaired #accessbit-widget,
            body.vision-impaired .accessbit-widget-panel,
            .accessbit-widget-panel {
                font-size: 100% !important;
                filter: none !important;
                z-index: 2147483646 !important;
            }
            
            body.vision-impaired .accessbit-widget-icon,
            body.vision-impaired #accessbit-widget-icon,
            .accessbit-widget-icon,
            #accessbit-widget-icon {
                font-size: 100% !important;
                filter: none !important;
                z-index: 2147483645 !important;
            }
            
            body.vision-impaired .accessbit-widget,
            body.vision-impaired #accessbit-widget,
            .accessbit-widget,
            #accessbit-widget {
                font-size: 100% !important;
                filter: none !important;
                z-index: 2147483647 !important;
            }
            
            /* Keep images at original size (no scaling) */
            body.vision-impaired img,
            html.vision-impaired img {
                /* Images stay at original size */
            }
            
            /* Keep sliders and carousels at original size */
            body.vision-impaired [class*="slider"],
            body.vision-impaired [id*="slider"],
            body.vision-impaired [data-slider],
            body.vision-impaired [class*="swiper"],
            body.vision-impaired [id*="swiper"],
            body.vision-impaired [class*="carousel"],
            body.vision-impaired [id*="carousel"],
            html.vision-impaired [class*="slider"],
            html.vision-impaired [id*="slider"],
            html.vision-impaired [data-slider],
            html.vision-impaired [class*="swiper"],
            html.vision-impaired [id*="swiper"],
            html.vision-impaired [class*="carousel"],
            html.vision-impaired [id*="carousel"] {
                /* Sliders stay at original size */
            }
        `;
                
                
            } catch (error) {
               
            }
        }

        disableVisionImpaired() {
            try {
                this.settings['vision-impaired'] = false;
                document.body.classList.remove('vision-impaired');
                document.documentElement.classList.remove('vision-impaired');

                // Remove vision impaired class from the accessibility widget
                if (this.shadowRoot && this.shadowRoot.host) {
                    this.shadowRoot.host.classList.remove('vision-impaired');
                }
                
                // Also remove from the widget container if it exists
                const widget = document.querySelector('.accessbit-widget');
                if (widget) {
                    widget.classList.remove('vision-impaired');
                }

                // Update toggle switch in UI
                const viToggle = this.shadowRoot?.getElementById('vision-impaired');
                if (viToggle) {
                    viToggle.checked = false;
                }

                // Remove comprehensive vision impaired styles
                const existingStyle = document.getElementById('accessbit-vision-impaired-immediate-early');
                if (existingStyle) {
                    existingStyle.remove();
                }
                
                // Remove content wrapper and restore body children
                const wrapper = document.getElementById('accessbit-content-wrapper');
                if (wrapper) {
                    // Move all wrapper children back to body
                    while (wrapper.firstChild) {
                        document.body.insertBefore(wrapper.firstChild, wrapper);
                    }
                    wrapper.remove();
                }
                
                // Apply vision impaired with false to clean up
                this.applyVisionImpaired(false);

                // CRITICAL FIX: Clear the separate localStorage key that sync functions use
                localStorage.removeItem('accessbit-widget-vision-impaired');
                
                // Persist and sync
                this.saveSettings();
                this.updateWidgetAppearance();
          
            } catch (e) {
            }
        }
    
        // Stop autoplay videos to prevent seizures
        stopAutoplayVideos() {
            // Find all video and audio elements
            const videos = document.querySelectorAll('video');
            const audios = document.querySelectorAll('audio');
            
            // Stop and pause all videos
            videos.forEach((video, index) => {
                if (video.autoplay || video.getAttribute('autoplay') !== null) {
                    video.pause();
                    video.currentTime = 0;
                    video.removeAttribute('autoplay');
                    video.setAttribute('data-seizure-safe-paused', 'true');
                  
                }
            });
            
            // Stop and pause all audio
            audios.forEach((audio, index) => {
                if (audio.autoplay || audio.getAttribute('autoplay') !== null) {
                    audio.pause();
                    audio.currentTime = 0;
                    audio.removeAttribute('autoplay');
                    audio.setAttribute('data-seizure-safe-paused', 'true');
                    
                }
            });
            
            // Add CSS to prevent future autoplay
            if (!document.getElementById('seizure-safe-autoplay-css')) {
                const style = document.createElement('style');
                style.id = 'seizure-safe-autoplay-css';
                style.textContent = `
                    .seizure-safe video[autoplay],
                    .seizure-safe audio[autoplay] {
                        animation-play-state: paused !important;
                    }
                    .seizure-safe video,
                    .seizure-safe audio {
                        animation: none !important;
                        transition: none !important;
                    }
                `;
                document.head.appendChild(style);
            }
            
           
        }
        
        // Stop portfolio animations that could cause black screen
        stopPortfolioAnimations() {
      
            
            // Stop requestAnimationFrame loops
            if (window.circleRAF) {
                cancelAnimationFrame(window.circleRAF);
                window.circleRAF = null;
            }
            if (window.hoverRAF) {
                cancelAnimationFrame(window.hoverRAF);
                window.hoverRAF = null;
            }
            
            
            // CRITICAL: Ensure letter-by-letter text animations show full text immediately
            this.forceCompleteTextAnimations();
            
            // ScrollTrigger detected - do not killAll; preserve scroll behavior
            if (typeof ScrollTrigger !== 'undefined') {
          
            }
            
            // Ensure portfolio elements remain visible
            const portfolioCards = document.querySelectorAll('.portfolio-card');
            portfolioCards.forEach(card => {
                card.style.opacity = '1';
                card.style.visibility = 'visible';
                card.style.display = 'block';
            });
            
            // Ensure hover circle is visible but not animated
            const hoverCircle = document.querySelector('.hover-circle');
            if (hoverCircle) {
                hoverCircle.style.opacity = '1';
                hoverCircle.style.visibility = 'visible';
                hoverCircle.style.display = 'block';
            }
            
            // Ensure background images are visible
            const bgElements = document.querySelectorAll('.portfolio-hover-img, .bg-overlay');
            bgElements.forEach(bg => {
                bg.style.opacity = '1';
                bg.style.visibility = 'visible';
            });
            
            // Hide curtain loader to prevent black screen
            const curtainLoader = document.querySelector('.curtain-page-loader');
            if (curtainLoader) {
                curtainLoader.style.display = 'none';
            }
            
            // Ensure page content is visible
            const pageWrapper = document.querySelector('.page-wrapper');
            if (pageWrapper) {
                pageWrapper.style.opacity = '1';
                pageWrapper.style.visibility = 'visible';
                pageWrapper.style.display = 'block';
            }
            
            // Make all fade elements visible
            const fadeElements = document.querySelectorAll('.fade-up, .fade-left, .fade-right, .fade-in');
            fadeElements.forEach(el => {
                el.style.opacity = '1';
                el.style.transform = 'none';
                el.style.visibility = 'visible';
            });
            
            // Ensure hero content is visible
            const heroText = document.querySelector('.portfolio-hero-text');
            if (heroText) {
                heroText.style.opacity = '1';
                heroText.style.transform = 'none';
                heroText.style.visibility = 'visible';
            }
            
        }
        
        // COMPREHENSIVE ANIMATION STOPPING - AccessiBe-style methods
        
        // Stop all JavaScript animations (requestAnimationFrame, setInterval, setTimeout)
        stopAllJavaScriptAnimations() {
  
            try {
                // SECURITY FIX: Removed global requestAnimationFrame override per Webflow Security requirements
                // Animation blocking is now handled via CSS classes and WAAPI controls only
                // Use WAAPI to pause/cancel running animations instead of hijacking global methods
                try {
                    if (seizureState && seizureState.applyWAAPIStopMotion) {
                        seizureState.applyWAAPIStopMotion(true);
                    }
                    } catch (_) {}
                
      
            } catch (e) {
               
            }
        }
        
        // Stop all GIFs, videos, and media (comprehensive media stopping)
        stopAllGIFsAndVideos() {
         
            
            try {
                // Stop all HTML5 videos and audio
                const videos = document.querySelectorAll('video');
                const audios = document.querySelectorAll('audio');
                
                videos.forEach(video => {
                    video.pause();
                    video.currentTime = 0;
                    video.removeAttribute('autoplay');
                    video.setAttribute('data-seizure-safe-paused', 'true');
                });
                
                audios.forEach(audio => {
                    audio.pause();
                    audio.currentTime = 0;
                    audio.removeAttribute('autoplay');
                    audio.setAttribute('data-seizure-safe-paused', 'true');
                });
                
                // Stop embedded media (YouTube, Vimeo, etc.)
                const iframes = document.querySelectorAll('iframe[src*="youtube"], iframe[src*="vimeo"], iframe[src*="dailymotion"]');
                iframes.forEach(iframe => {
                    try {
                        // Security: Validate URL before manipulation to prevent XSS
                        const src = iframe.src;
                        if (!src || typeof src !== 'string') return;
                        
                        // Validate URL format and allowed domains
                        let isValidUrl = false;
                        try {
                            const url = new URL(src);
                            const allowedDomains = ['youtube.com', 'youtu.be', 'vimeo.com', 'dailymotion.com', 'player.vimeo.com'];
                            isValidUrl = allowedDomains.some(domain => url.hostname.includes(domain));
                        } catch {
                            // If URL parsing fails, skip modification
                            return;
                        }
                        
                        if (!isValidUrl) return;
                        
                        // Try to stop embedded videos by modifying src
                        if (src.includes('autoplay=1')) {
                            const newSrc = src.replace('autoplay=1', 'autoplay=0');
                            // Double-check the new URL is still valid
                            try {
                                new URL(newSrc);
                                iframe.src = newSrc;
                            } catch {
                                // Invalid URL, skip
                            }
                        } else if (!src.includes('autoplay=0')) {
                            const separator = src.includes('?') ? '&' : '?';
                            const newSrc = src + separator + 'autoplay=0';
                            // Double-check the new URL is still valid
                            try {
                                new URL(newSrc);
                                iframe.src = newSrc;
                            } catch {
                                // Invalid URL, skip
                            }
                        }
                        iframe.setAttribute('data-seizure-safe-stopped', 'true');
                    } catch (_) {}
                });
                
                // Replace animated GIFs and APNGs with static frames
                const images = document.querySelectorAll('img');
                images.forEach(img => {
                    if (img.src && (img.src.includes('.gif') || img.src.includes('gif') || img.src.includes('.png'))) {
                        // Store original src
                        if (!img.dataset.originalSrc) {
                            img.dataset.originalSrc = img.src;
                        }
                        // Replace with static fallback (1x1 transparent pixel)
                        img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                        img.setAttribute('data-seizure-safe-replaced', 'true');
                    }
                });
                
                // Stop canvas animations and SVG animations
                const canvases = document.querySelectorAll('canvas');
                canvases.forEach(canvas => {
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    canvas.setAttribute('data-seizure-safe-stopped', 'true');
                });
                
                // Stop SVG animations
                const svgs = document.querySelectorAll('svg');
                svgs.forEach(svg => {
                    const animatedElements = svg.querySelectorAll('animate, animateTransform, animateMotion');
                    animatedElements.forEach(el => {
                        el.remove();
                    });
                    svg.setAttribute('data-seizure-safe-stopped', 'true');
                });
                
            
            } catch (e) {
          
            }
        }
        
        // Stop all animation libraries (GSAP, Lottie, jQuery, etc.)
        stopAllAnimationLibraries() {
          
            
            try {
                
                // Stop Lottie animations - Universal approach for all websites
                this.stopAllLottieAnimations();
                
                // Stop jQuery animations
                if (typeof window.jQuery !== 'undefined') {
                    try {
                        window.jQuery('*').stop(true, true);
                        window.jQuery.fx.off = true;
                    } catch (_) {}
                }
                
                // Stop Three.js animations
                if (typeof window.THREE !== 'undefined') {
                    try {
                        // Stop all render loops
                        if (window.THREE.AnimationMixer) {
                            const mixers = document.querySelectorAll('[data-three-mixer]');
                            mixers.forEach(mixer => {
                                try { mixer.stopAllAction(); } catch (_) {}
                            });
                        }
                    } catch (_) {}
                }
                
                // GSAP: Stop all animations including motionPath (orbit), progress bars, and pointer animations
                if (typeof window.gsap !== 'undefined') {
                    try {
                        // Kill all active GSAP tweens and timelines
                        if (window.gsap.killTweensOf) {
                            // Stop motionPath animations (orbit animations) - target elements with motionPath animations
                            // BUT ensure they remain visible in their final position
                            const orbitElements = document.querySelectorAll('[class*="orbit"], [class*="dot"], .dot-1a, .dot-1b, .dot-1c, .dot-1d, .dot-2a, .dot-2b, .dot-2c, .dot-2d, .dot-3a, .dot-3b, .dot-3c, .dot-3d');
                            orbitElements.forEach(el => {
                                try {
                                    // Kill the animation but preserve final state
                                    const currentTransform = window.getComputedStyle(el).transform;
                                    const currentOpacity = window.getComputedStyle(el).opacity;
                                    window.gsap.killTweensOf(el);
                                    // Ensure element remains visible
                                    el.style.opacity = currentOpacity !== '0' ? '1' : '1';
                                    el.style.visibility = 'visible';
                                    el.style.display = '';
                                    // Preserve final transform position
                                    if (currentTransform && currentTransform !== 'none' && currentTransform !== 'matrix(1, 0, 0, 1, 0, 0)') {
                                        el.style.transform = currentTransform;
                                    }
                                } catch (_) {}
                            });
                            
                            // Stop progress bar animations
                            const progressElements = document.querySelectorAll('[class*="progress"], [role="progressbar"], .progress, .slider-progress, .progress-bar');
                            progressElements.forEach(el => {
                                try {
                                    window.gsap.killTweensOf(el);
                                } catch (_) {}
                            });
                            
                            // Stop pointer animations (click simulation with expanding overlays)
                            const pointerElements = document.querySelectorAll('.pointer, .color-overlay, .color-overlay-2, [class*="pointer"], [class*="overlay"]');
                            pointerElements.forEach(el => {
                                try {
                                    window.gsap.killTweensOf(el);
                                } catch (_) {}
                            });
                            
                            // Stop floating image animations
                            const floatingElements = document.querySelectorAll('.floating-image, [class*="floating"]');
                            floatingElements.forEach(el => {
                                try {
                                    window.gsap.killTweensOf(el);
                                } catch (_) {}
                            });
                        }
                        
                        // Kill all timelines that might contain these animations
                        if (window.gsap.globals && window.gsap.globals.timeline) {
                            try {
                                const timelines = window.gsap.globals.timeline.getAll ? window.gsap.globals.timeline.getAll() : [];
                                timelines.forEach(tl => {
                                    try {
                                        if (tl && typeof tl.kill === 'function') {
                                            tl.kill();
                                        }
                                    } catch (_) {}
                                });
                            } catch (_) {}
                        }
                        
                        // Get all active tweens and kill motionPath-related ones
                        if (window.gsap.getAllTweens) {
                            try {
                                const allTweens = window.gsap.getAllTweens();
                                allTweens.forEach(tween => {
                                    try {
                                        if (tween && tween.vars && (tween.vars.motionPath || tween.vars.motionPath)) {
                                            tween.kill();
                                        }
                                    } catch (_) {}
                                });
                            } catch (_) {}
                        }
                    } catch (error) {
                        // Silent fail
                    }
                }
                
          
            } catch (e) {
               
            }
        }
        
        // Stop all parallax and scroll effects
        stopAllParallaxAndScrollEffects() {
            
            
            try {
                // Stop scroll-triggered animations
                const scrollElements = document.querySelectorAll('[data-scroll], [data-aos], [data-animate]');
                scrollElements.forEach(el => {
                    el.style.transform = 'none';
                    el.style.opacity = '1';
                    el.style.visibility = 'visible';
                    el.setAttribute('data-seizure-safe-stopped', 'true');
                });
                
                // Stop parallax elements
                const parallaxElements = document.querySelectorAll('.parallax, [data-parallax]');
                parallaxElements.forEach(el => {
                    el.style.transform = 'none';
                    el.style.backgroundAttachment = 'scroll';
                    el.setAttribute('data-seizure-safe-stopped', 'true');
                });
                
                // REMOVED: Stop smooth scrolling - This was blocking Lenis smooth scrolling
                // Lenis handles smooth scrolling and should not be blocked
                
             
            } catch (e) {
          
            }
        }
        
        // SECURITY FIX: Removed global EventTarget.prototype.addEventListener override per Webflow Security requirements
        // Scroll-based animation blocking is now handled via CSS classes only.
        stopAllScrollInteractions() {
            // No-op: keep for backward compatibility with callers.
            return;
        }
        
        // Universal Lottie Animation Stopping - Works on ALL websites
        // Uses Lottie's official API methods as recommended by Lottie documentation
        stopAllLottieAnimations() {
            // CRITICAL: This function must be comprehensive and handle all Lottie instances
            // Some Lottie animations may restart or be created dynamically, so we need to be thorough
            try {
                // Method 1: Stop via lottie-web API (most reliable) - Using Lottie's official methods
                if (typeof window.lottie !== 'undefined') {
                    try {
                        // Get all registered animations
                        if (typeof window.lottie.getRegisteredAnimations === 'function') {
                            const allAnimations = window.lottie.getRegisteredAnimations();
                            if (allAnimations && allAnimations.length > 0) {
                                allAnimations.forEach(anim => {
                                    try {
                                        if (anim) {
                                            // CRITICAL: Cancel any requestAnimationFrame loops FIRST - stops render loop immediately
                                            if (anim.animationID !== undefined && anim.animationID !== null) {
                                                try {
                                                    cancelAnimationFrame(anim.animationID);
                                                    anim.animationID = null;
                                                } catch (_) {}
                                            }
                                            if (anim.renderer && anim.renderer.animationID !== undefined && anim.renderer.animationID !== null) {
                                                try {
                                                    cancelAnimationFrame(anim.renderer.animationID);
                                                    anim.renderer.animationID = null;
                                                } catch (_) {}
                                            }
                                            if (anim._animationID !== undefined && anim._animationID !== null) {
                                                try {
                                                    cancelAnimationFrame(anim._animationID);
                                                    anim._animationID = null;
                                                } catch (_) {}
                                            }
                                            
                                            // CRITICAL: Use Lottie's official API methods in the correct order
                                            // 1. Set speed to 0 first (immediately stops playback)
                                            if (typeof anim.setSpeed === 'function') {
                                                anim.setSpeed(0);
                                            }
                                            
                                            // 2. Stop the animation (stops playback)
                                            if (typeof anim.stop === 'function') {
                                                anim.stop();
                                            }
                                            
                                            // 3. Pause the animation (pauses at current frame)
                                            if (typeof anim.pause === 'function') {
                                                anim.pause();
                                            }
                                            
                                            // 3.5. Stop the renderer if it exists
                                            if (anim.renderer) {
                                                try {
                                                    if (anim.renderer.stop) {
                                                        anim.renderer.stop();
                                                    }
                                                    if (anim.renderer.pause) {
                                                        anim.renderer.pause();
                                                    }
                                                } catch (_) {}
                                            }
                                            
                                            // 4. Go to final frame and stop (finish to final state, not frame 0)
                                            if (typeof anim.goToAndStop === 'function') {
                                                // Get total frames and go to last frame
                                                const totalFrames = anim.totalFrames || anim.frameCount || 0;
                                                const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                                anim.goToAndStop(finalFrame, true);
                                            } else if (typeof anim.goToAndPlay === 'function') {
                                                // Fallback: go to end if goToAndStop not available
                                                const totalFrames = anim.totalFrames || anim.frameCount || 0;
                                                const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                                anim.goToAndPlay(finalFrame, true);
                                                if (typeof anim.pause === 'function') {
                                                    setTimeout(() => anim.pause(), 0);
                                                }
                                            }
                                            
                                            // 5. Prevent autoplay
                                            if (anim.autoplay !== undefined) {
                                                anim.autoplay = false;
                                            }
                                            
                                            // 6. Set direction to normal (prevents reverse)
                                            if (typeof anim.setDirection === 'function') {
                                                anim.setDirection(1);
                                            }
                                            
                                            // 7. Remove all event listeners that might restart animation
                                            if (anim.removeEventListener) {
                                                // Remove all possible restart-related event listeners
                                                const eventsToRemove = ['complete', 'loopComplete', 'enterFrame', 'segmentStart', 'destroy'];
                                                eventsToRemove.forEach(eventName => {
                                                    try {
                                                        // Try to remove with common handler names
                                                        if (anim.restart) anim.removeEventListener(eventName, anim.restart);
                                                        if (anim.play) anim.removeEventListener(eventName, anim.play);
                                                        if (anim.start) anim.removeEventListener(eventName, anim.start);
                                                        // Remove all listeners for this event by cloning and re-adding (if possible)
                                                        if (anim._listeners && anim._listeners[eventName]) {
                                                            anim._listeners[eventName] = [];
                                                        }
                                                    } catch (_) {}
                                                });
                                            }
                                            
                                            // 8. Disable looping - CRITICAL: Set multiple loop-related properties
                                            if (anim.loop !== undefined) {
                                                anim.loop = false;
                                            }
                                            if (anim.loopCount !== undefined) {
                                                anim.loopCount = 0;
                                            }
                                            if (anim.isPaused !== undefined) {
                                                anim.isPaused = true;
                                            }
                                            
                                            // 9. CRITICAL: Override play/restart methods to prevent animations from restarting
                                            if (!anim._seizureSafeOriginalPlay) {
                                                anim._seizureSafeOriginalPlay = anim.play;
                                                anim.play = function() {
                                                    // Prevent play when seizure-safe is active
                                                    if (document.body.classList.contains('seizure-safe') || 
                                                        document.documentElement.classList.contains('seizure-safe')) {
                                                        return;
                                                    }
                                                    return anim._seizureSafeOriginalPlay.apply(this, arguments);
                                                };
                                            }
                                            
                                            if (!anim._seizureSafeOriginalRestart) {
                                                anim._seizureSafeOriginalRestart = anim.restart;
                                                anim.restart = function() {
                                                    // Prevent restart when seizure-safe is active
                                                    if (document.body.classList.contains('seizure-safe') || 
                                                        document.documentElement.classList.contains('seizure-safe')) {
                                                        return;
                                                    }
                                                    return anim._seizureSafeOriginalRestart.apply(this, arguments);
                                                };
                                            }
                                            
                                            if (!anim._seizureSafeOriginalGoToAndPlay) {
                                                anim._seizureSafeOriginalGoToAndPlay = anim.goToAndPlay;
                                                anim.goToAndPlay = function() {
                                                    // Prevent goToAndPlay when seizure-safe is active
                                                    if (document.body.classList.contains('seizure-safe') || 
                                                        document.documentElement.classList.contains('seizure-safe')) {
                                                        // Just go to frame without playing
                                                        if (anim.goToAndStop) {
                                                            const frame = arguments[0] || 0;
                                                            anim.goToAndStop(frame, true);
                                                        }
                                                        return;
                                                    }
                                                    return anim._seizureSafeOriginalGoToAndPlay.apply(this, arguments);
                                                };
                                            }
                                            
                                            // 10. Override setDirection to prevent reverse loops
                                            if (!anim._seizureSafeOriginalSetDirection && typeof anim.setDirection === 'function') {
                                                anim._seizureSafeOriginalSetDirection = anim.setDirection;
                                                anim.setDirection = function(direction) {
                                                    // Only allow setting direction if not seizure-safe
                                                    if (document.body.classList.contains('seizure-safe') || 
                                                        document.documentElement.classList.contains('seizure-safe')) {
                                                        return;
                                                    }
                                                    return anim._seizureSafeOriginalSetDirection.apply(this, arguments);
                                                };
                                            }
                                            
                                            // 11. CRITICAL: Intercept the render/update loop directly to prevent loops
                                            // This catches animations that restart through internal mechanisms
                                            if (!anim._seizureSafeRenderIntercepted) {
                                                anim._seizureSafeRenderIntercepted = true;
                                                
                                                // Override render function if it exists
                                                if (anim.renderFrame && !anim._seizureSafeOriginalRenderFrame) {
                                                    anim._seizureSafeOriginalRenderFrame = anim.renderFrame;
                                                    anim.renderFrame = function(frame) {
                                                        if (document.body.classList.contains('seizure-safe') || 
                                                            document.documentElement.classList.contains('seizure-safe')) {
                                                            // Stop the animation and go to final frame
                                                            try {
                                                                if (anim && typeof anim.goToAndStop === 'function') {
                                                                    const totalFrames = anim.totalFrames || anim.frameCount || 0;
                                                                    const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                                                    anim.goToAndStop(finalFrame, true);
                                                                }
                                                                if (anim && typeof anim.pause === 'function') {
                                                                    anim.pause();
                                                                }
                                                                if (anim && typeof anim.setSpeed === 'function') {
                                                                    anim.setSpeed(0);
                                                                }
                                                            } catch (_) {}
                                                            return;
                                                        }
                                                        return anim._seizureSafeOriginalRenderFrame.apply(this, arguments);
                                                    };
                                                }
                                                
                                                // Override enterFrame/update function if it exists
                                                if (anim.enterFrame && !anim._seizureSafeOriginalEnterFrame) {
                                                    anim._seizureSafeOriginalEnterFrame = anim.enterFrame;
                                                    anim.enterFrame = function() {
                                                        if (document.body.classList.contains('seizure-safe') || 
                                                            document.documentElement.classList.contains('seizure-safe')) {
                                                            // Stop the animation
                                                            try {
                                                                if (anim && typeof anim.pause === 'function') {
                                                                    anim.pause();
                                                                }
                                                                if (anim && typeof anim.setSpeed === 'function') {
                                                                    anim.setSpeed(0);
                                                                }
                                                            } catch (_) {}
                                                            return;
                                                        }
                                                        return anim._seizureSafeOriginalEnterFrame.apply(this, arguments);
                                                    };
                                                }
                                                
                                                // CRITICAL: Intercept the animation's internal update/tick function
                                                // This is where the loop actually happens
                                                if (anim.renderer && anim.renderer.renderFrame && !anim._seizureSafeOriginalRendererRenderFrame) {
                                                    anim._seizureSafeOriginalRendererRenderFrame = anim.renderer.renderFrame;
                                                    anim.renderer.renderFrame = function(frame) {
                                                        if (document.body.classList.contains('seizure-safe') || 
                                                            document.documentElement.classList.contains('seizure-safe')) {
                                                            return; // Don't render anything
                                                        }
                                                        return anim._seizureSafeOriginalRendererRenderFrame.apply(this, arguments);
                                                    };
                                                }
                                                
                                                // Intercept the animation's update function
                                                if (anim.update && !anim._seizureSafeOriginalUpdate) {
                                                    anim._seizureSafeOriginalUpdate = anim.update;
                                                    anim.update = function() {
                                                        if (document.body.classList.contains('seizure-safe') || 
                                                            document.documentElement.classList.contains('seizure-safe')) {
                                                            return; // Don't update
                                                        }
                                                        return anim._seizureSafeOriginalUpdate.apply(this, arguments);
                                                    };
                                                }
                                                
                                                // Intercept the animation's tick function
                                                if (anim.tick && !anim._seizureSafeOriginalTick) {
                                                    anim._seizureSafeOriginalTick = anim.tick;
                                                    anim.tick = function() {
                                                        if (document.body.classList.contains('seizure-safe') || 
                                                            document.documentElement.classList.contains('seizure-safe')) {
                                                            return; // Don't tick
                                                        }
                                                        return anim._seizureSafeOriginalTick.apply(this, arguments);
                                                    };
                                                }
                                                
                                                // Override the animation's internal loop check
                                                // Some Lottie versions use _isPaused or isPaused internally
                                                if (anim._isPaused !== undefined) {
                                                    Object.defineProperty(anim, '_isPaused', {
                                                        get: function() {
                                                            if (document.body.classList.contains('seizure-safe') || 
                                                                document.documentElement.classList.contains('seizure-safe')) {
                                                                return true; // Force paused state
                                                            }
                                                            return this._seizureSafeOriginalIsPaused !== undefined ? this._seizureSafeOriginalIsPaused : false;
                                                        },
                                                        set: function(value) {
                                                            if (document.body.classList.contains('seizure-safe') || 
                                                                document.documentElement.classList.contains('seizure-safe')) {
                                                                this._seizureSafeOriginalIsPaused = true; // Always keep paused
                                                                return;
                                                            }
                                                            this._seizureSafeOriginalIsPaused = value;
                                                        },
                                                        configurable: true
                                                    });
                                                    anim._seizureSafeOriginalIsPaused = anim._isPaused;
                                                }
                                                
                                                // Override isPaused property
                                                if (anim.isPaused !== undefined) {
                                                    Object.defineProperty(anim, 'isPaused', {
                                                        get: function() {
                                                            if (document.body.classList.contains('seizure-safe') || 
                                                                document.documentElement.classList.contains('seizure-safe')) {
                                                                return true; // Force paused state
                                                            }
                                                            return this._seizureSafeOriginalIsPausedProp !== undefined ? this._seizureSafeOriginalIsPausedProp : false;
                                                        },
                                                        set: function(value) {
                                                            if (document.body.classList.contains('seizure-safe') || 
                                                                document.documentElement.classList.contains('seizure-safe')) {
                                                                this._seizureSafeOriginalIsPausedProp = true; // Always keep paused
                                                                return;
                                                            }
                                                            this._seizureSafeOriginalIsPausedProp = value;
                                                        },
                                                        configurable: true
                                                    });
                                                    anim._seizureSafeOriginalIsPausedProp = anim.isPaused;
                                                }
                                                
                                                // CRITICAL: Directly manipulate the DOM element to stop rendering
                                                // Find the canvas or SVG element associated with this animation
                                                if (anim.renderer && anim.renderer.canvas) {
                                                    try {
                                                        const canvas = anim.renderer.canvas;
                                                        if (canvas && canvas.nodeType === 1) {
                                                            // Freeze the canvas by clearing and stopping updates
                                                            canvas.style.setProperty('animation', 'none', 'important');
                                                            canvas.style.setProperty('transition', 'none', 'important');
                                                            canvas.style.setProperty('pointer-events', 'none', 'important');
                                                            canvas.setAttribute('data-seizure-safe-frozen', 'true');
                                                        }
                                                    } catch (_) {}
                                                }
                                                
                                                // Also check for SVG elements
                                                if (anim.renderer && anim.renderer.svgElement) {
                                                    try {
                                                        const svg = anim.renderer.svgElement;
                                                        if (svg && svg.nodeType === 1) {
                                                            svg.style.setProperty('animation', 'none', 'important');
                                                            svg.style.setProperty('transition', 'none', 'important');
                                                            svg.setAttribute('data-seizure-safe-frozen', 'true');
                                                        }
                                                    } catch (_) {}
                                                }
                                                
                                                // Find the container element and freeze it
                                                if (anim.container) {
                                                    try {
                                                        const container = anim.container;
                                                        if (container && container.nodeType === 1) {
                                                            container.style.setProperty('animation', 'none', 'important');
                                                            container.style.setProperty('transition', 'none', 'important');
                                                            container.setAttribute('data-seizure-safe-frozen', 'true');
                                                            
                                                            // Freeze all canvas and SVG children
                                                            const canvases = container.querySelectorAll('canvas');
                                                            canvases.forEach(canvas => {
                                                                canvas.style.setProperty('animation', 'none', 'important');
                                                                canvas.style.setProperty('transition', 'none', 'important');
                                                                canvas.setAttribute('data-seizure-safe-frozen', 'true');
                                                            });
                                                            
                                                            const svgs = container.querySelectorAll('svg');
                                                            svgs.forEach(svg => {
                                                                svg.style.setProperty('animation', 'none', 'important');
                                                                svg.style.setProperty('transition', 'none', 'important');
                                                                svg.setAttribute('data-seizure-safe-frozen', 'true');
                                                            });
                                                        }
                                                    } catch (_) {}
                                                }
                                            }
                                        }
                                    } catch (_) {}
                                });
                            }
                        }
                        
                        // Freeze all future animations (prevents new animations from starting)
                        if (typeof window.lottie.freeze === 'function') {
                            try {
                                window.lottie.freeze();
                            } catch (_) {}
                        }
                        
                        // CRITICAL: Intercept and prevent all animation completion events that trigger loops
                        // This prevents looped animations from restarting even if they have internal loop logic
                        if (!seizureState.lottieEventInterceptorActive) {
                            seizureState.lottieEventInterceptorActive = true;
                            
                            // Override addEventListener on all animation instances to intercept completion events
                            const originalGetRegisteredAnimations = window.lottie.getRegisteredAnimations;
                            if (originalGetRegisteredAnimations) {
                                const self = this;
                                // Set up a MutationObserver to catch new animations and override their event listeners
                                const animObserver = new MutationObserver(() => {
                                    try {
                                        const allAnims = window.lottie.getRegisteredAnimations();
                                        allAnims.forEach(anim => {
                                            if (anim && !anim._seizureSafeEventInterceptorAdded) {
                                                anim._seizureSafeEventInterceptorAdded = true;
                                                
                                                // Override addEventListener to block completion events
                                                if (anim.addEventListener && !anim._seizureSafeOriginalAddEventListener) {
                                                    anim._seizureSafeOriginalAddEventListener = anim.addEventListener;
                                                    anim.addEventListener = function(eventName, handler) {
                                                        // Block completion events that might restart loops
                                                        if (eventName === 'complete' || eventName === 'loopComplete') {
                                                            // Only allow the handler if seizure-safe is not active
                                                            if (document.body.classList.contains('seizure-safe') || 
                                                                document.documentElement.classList.contains('seizure-safe')) {
                                                                // Replace handler with a no-op that stops the animation
                                                                const safeHandler = function() {
                                                                    try {
                                                                        if (anim && typeof anim.stop === 'function') anim.stop();
                                                                        if (anim && typeof anim.pause === 'function') anim.pause();
                                                                        if (anim && typeof anim.setSpeed === 'function') anim.setSpeed(0);
                                                                        if (anim && anim.loop !== undefined) anim.loop = false;
                                                                    } catch (_) {}
                                                                };
                                                                return anim._seizureSafeOriginalAddEventListener.call(this, eventName, safeHandler);
                                                            }
                                                        }
                                                        return anim._seizureSafeOriginalAddEventListener.apply(this, arguments);
                                                    };
                                                }
                                            }
                                        });
                                    } catch (_) {}
                                });
                                
                                // Observe for new animations - VERY AGGRESSIVE
                                animObserver.observe(document.body, { 
                                    childList: true, 
                                    subtree: true,
                                    attributes: true,
                                    attributeFilter: ['class', 'style']
                                });
                                seizureState.lottieAnimObserver = animObserver;
                                
                                // CRITICAL: Also set up a more aggressive observer to catch and freeze DOM elements immediately
                                if (!seizureState.lottieDOMFreezeObserver) {
                                    seizureState.lottieDOMFreezeObserver = new MutationObserver((mutations) => {
                                        if (!document.body.classList.contains('seizure-safe') && 
                                            !document.documentElement.classList.contains('seizure-safe')) {
                                            return;
                                        }
                                        
                                        mutations.forEach(mutation => {
                                            // Check added nodes
                                            mutation.addedNodes.forEach(node => {
                                                if (node.nodeType === 1) { // Element node
                                                    try {
                                                        // Immediately freeze any canvas or SVG
                                                        if (node.tagName === 'CANVAS') {
                                                            node.style.setProperty('animation', 'none', 'important');
                                                            node.style.setProperty('transition', 'none', 'important');
                                                            node.setAttribute('data-seizure-safe-frozen', 'true');
                                                        }
                                                        if (node.tagName === 'SVG') {
                                                            node.style.setProperty('animation', 'none', 'important');
                                                            node.style.setProperty('transition', 'none', 'important');
                                                            node.setAttribute('data-seizure-safe-frozen', 'true');
                                                        }
                                                        
                                                        // Check children
                                                        const canvases = node.querySelectorAll ? node.querySelectorAll('canvas') : [];
                                                        canvases.forEach(canvas => {
                                                            canvas.style.setProperty('animation', 'none', 'important');
                                                            canvas.style.setProperty('transition', 'none', 'important');
                                                            canvas.setAttribute('data-seizure-safe-frozen', 'true');
                                                        });
                                                        
                                                        const svgs = node.querySelectorAll ? node.querySelectorAll('svg') : [];
                                                        svgs.forEach(svg => {
                                                            svg.style.setProperty('animation', 'none', 'important');
                                                            svg.style.setProperty('transition', 'none', 'important');
                                                            svg.setAttribute('data-seizure-safe-frozen', 'true');
                                                        });
                                                        
                                                        // Immediately stop any Lottie animations
                                                        if (typeof window.lottie !== 'undefined' && window.lottie.getRegisteredAnimations) {
                                                            const allAnims = window.lottie.getRegisteredAnimations();
                                                            allAnims.forEach(anim => {
                                                                try {
                                                                    if (anim && anim.container && (anim.container === node || anim.container.contains(node))) {
                                                                        if (typeof anim.stop === 'function') anim.stop();
                                                                        if (typeof anim.pause === 'function') anim.pause();
                                                                        if (typeof anim.setSpeed === 'function') anim.setSpeed(0);
                                                                        if (anim.loop !== undefined) anim.loop = false;
                                                                        if (anim.animationID !== undefined && anim.animationID !== null) {
                                                                            cancelAnimationFrame(anim.animationID);
                                                                            anim.animationID = null;
                                                                        }
                                                                    }
                                                                } catch (_) {}
                                                            });
                                                        }
                                                    } catch (_) {}
                                                }
                                            });
                                        });
                                    });
                                    
                                    seizureState.lottieDOMFreezeObserver.observe(document.documentElement, {
                                        childList: true,
                                        subtree: true,
                                        attributes: true,
                                        attributeFilter: ['class']
                                    });
                                }
                                
                                // Also apply immediately to existing animations
                                setTimeout(() => {
                                    try {
                                        const allAnims = window.lottie.getRegisteredAnimations();
                                        allAnims.forEach(anim => {
                                            if (anim && !anim._seizureSafeEventInterceptorAdded) {
                                                anim._seizureSafeEventInterceptorAdded = true;
                                                if (anim.addEventListener && !anim._seizureSafeOriginalAddEventListener) {
                                                    anim._seizureSafeOriginalAddEventListener = anim.addEventListener;
                                                    anim.addEventListener = function(eventName, handler) {
                                                        if (eventName === 'complete' || eventName === 'loopComplete') {
                                                            if (document.body.classList.contains('seizure-safe') || 
                                                                document.documentElement.classList.contains('seizure-safe')) {
                                                                const safeHandler = function() {
                                                                    try {
                                                                        if (anim && typeof anim.stop === 'function') anim.stop();
                                                                        if (anim && typeof anim.pause === 'function') anim.pause();
                                                                        if (anim && typeof anim.setSpeed === 'function') anim.setSpeed(0);
                                                                        if (anim && anim.loop !== undefined) anim.loop = false;
                                                                    } catch (_) {}
                                                                };
                                                                return anim._seizureSafeOriginalAddEventListener.call(this, eventName, safeHandler);
                                                            }
                                                        }
                                                        return anim._seizureSafeOriginalAddEventListener.apply(this, arguments);
                                                    };
                                                }
                                            }
                                        });
                                    } catch (_) {}
                                }, 0);
                            }
                        }
                        
                        // Method 5: Override Lottie loading globally (store original for restoration)
                        // Prevents new animations from starting when seizure-safe is active
                        if (typeof window.lottie.loadAnimation === 'function' && !seizureState.originalLottieLoadAnimation) {
                            seizureState.originalLottieLoadAnimation = window.lottie.loadAnimation;
                            const self = this;
                            window.lottie.loadAnimation = function(config) {
                                try {
                                    const anim = seizureState.originalLottieLoadAnimation.call(this, config);
                                    if (anim) {
                                        try {
                                            // Immediately stop new animations using comprehensive API methods
                                            if (typeof anim.setSpeed === 'function') {
                                                anim.setSpeed(0);
                                            }
                                            if (typeof anim.stop === 'function') {
                                                anim.stop();
                                            }
                                            if (typeof anim.pause === 'function') {
                                                anim.pause();
                                            }
                                            if (typeof anim.goToAndStop === 'function') {
                                                // Go to final frame (finish to final state, not frame 0)
                                                const totalFrames = anim.totalFrames || anim.frameCount || 0;
                                                const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                                anim.goToAndStop(finalFrame, true);
                                            } else if (typeof anim.goToAndPlay === 'function') {
                                                // Fallback: go to end if goToAndStop not available
                                                const totalFrames = anim.totalFrames || anim.frameCount || 0;
                                                const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                                anim.goToAndPlay(finalFrame, true);
                                                if (typeof anim.pause === 'function') {
                                                    setTimeout(() => anim.pause(), 0);
                                                }
                                            }
                                            if (anim.autoplay !== undefined) {
                                                anim.autoplay = false;
                                            }
                                            if (anim.loop !== undefined) {
                                                anim.loop = false;
                                            }
                                            if (anim.loopCount !== undefined) {
                                                anim.loopCount = 0;
                                            }
                                            
                                            // CRITICAL: Cancel any requestAnimationFrame immediately for new animations
                                            if (anim.animationID !== undefined && anim.animationID !== null) {
                                                try {
                                                    cancelAnimationFrame(anim.animationID);
                                                    anim.animationID = null;
                                                } catch (_) {}
                                            }
                                            if (anim.renderer && anim.renderer.animationID !== undefined && anim.renderer.animationID !== null) {
                                                try {
                                                    cancelAnimationFrame(anim.renderer.animationID);
                                                    anim.renderer.animationID = null;
                                                } catch (_) {}
                                            }
                                            
                                            // CRITICAL: Override play/restart methods for newly loaded animations
                                            if (!anim._seizureSafeOriginalPlay) {
                                                anim._seizureSafeOriginalPlay = anim.play;
                                                anim.play = function() {
                                                    if (document.body.classList.contains('seizure-safe') || 
                                                        document.documentElement.classList.contains('seizure-safe')) {
                                                        return;
                                                    }
                                                    return anim._seizureSafeOriginalPlay.apply(this, arguments);
                                                };
                                            }
                                            
                                            if (!anim._seizureSafeOriginalRestart) {
                                                anim._seizureSafeOriginalRestart = anim.restart;
                                                anim.restart = function() {
                                                    if (document.body.classList.contains('seizure-safe') || 
                                                        document.documentElement.classList.contains('seizure-safe')) {
                                                        return;
                                                    }
                                                    return anim._seizureSafeOriginalRestart.apply(this, arguments);
                                                };
                                            }
                                            
                                            if (!anim._seizureSafeOriginalGoToAndPlay) {
                                                anim._seizureSafeOriginalGoToAndPlay = anim.goToAndPlay;
                                                anim.goToAndPlay = function() {
                                                    if (document.body.classList.contains('seizure-safe') || 
                                                        document.documentElement.classList.contains('seizure-safe')) {
                                                        if (anim.goToAndStop) {
                                                            const frame = arguments[0] || 0;
                                                            anim.goToAndStop(frame, true);
                                                        }
                                                        return;
                                                    }
                                                    return anim._seizureSafeOriginalGoToAndPlay.apply(this, arguments);
                                                };
                                            }
                                        } catch (_) {}
                                    }
                                    return anim;
                                } catch (_) {
                                    return seizureState.originalLottieLoadAnimation.call(this, config);
                                }
                            };
                        }
                        
                    } catch (_) {}
                }
                
                // Method 2: Stop via lottie-player web components (using official lottie-player API)
                try {
                    const lottiePlayers = document.querySelectorAll('lottie-player');
                    lottiePlayers.forEach(player => {
                        try {
                            // Use lottie-player's official API methods
                            // 1. Stop the animation
                            if (typeof player.stop === 'function') {
                                player.stop();
                            }
                            
                            // 2. Pause the animation
                            if (typeof player.pause === 'function') {
                                player.pause();
                            }
                            
                            // 3. Set speed to 0
                            if (typeof player.setSpeed === 'function') {
                                player.setSpeed(0);
                            }
                            
                            // 4. Go to final frame and stop (finish to final state)
                            if (typeof player.seek === 'function') {
                                // Get total frames and seek to last frame
                                const totalFrames = player.totalFrames || player.frameCount || 0;
                                const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                player.seek(finalFrame);
                            }
                            
                            // 5. Set mode to 'normal' (prevents looping)
                            if (typeof player.setMode === 'function') {
                                player.setMode('normal');
                            }
                            
                            // 6. Disable autoplay via attribute
                            player.setAttribute('autoplay', 'false');
                            player.removeAttribute('loop');
                            player.setAttribute('loop', 'false');
                            
                            // 7. CRITICAL: Override lottie-player's play/restart methods
                            if (!player._seizureSafeOriginalPlay && typeof player.play === 'function') {
                                player._seizureSafeOriginalPlay = player.play;
                                player.play = function() {
                                    if (document.body.classList.contains('seizure-safe') || 
                                        document.documentElement.classList.contains('seizure-safe')) {
                                        return;
                                    }
                                    return player._seizureSafeOriginalPlay.apply(this, arguments);
                                };
                            }
                            
                            if (!player._seizureSafeOriginalRestart && typeof player.restart === 'function') {
                                player._seizureSafeOriginalRestart = player.restart;
                                player.restart = function() {
                                    if (document.body.classList.contains('seizure-safe') || 
                                        document.documentElement.classList.contains('seizure-safe')) {
                                        return;
                                    }
                                    return player._seizureSafeOriginalRestart.apply(this, arguments);
                                };
                            }
                            
                            if (!player._seizureSafeOriginalLoad && typeof player.load === 'function') {
                                player._seizureSafeOriginalLoad = player.load;
                                player.load = function() {
                                    const result = player._seizureSafeOriginalLoad.apply(this, arguments);
                                    // Immediately stop after loading if seizure-safe is active
                                    if (document.body.classList.contains('seizure-safe') || 
                                        document.documentElement.classList.contains('seizure-safe')) {
                                        setTimeout(() => {
                                            try {
                                                if (typeof player.stop === 'function') player.stop();
                                                if (typeof player.pause === 'function') player.pause();
                                                if (typeof player.setSpeed === 'function') player.setSpeed(0);
                                            } catch (_) {}
                                        }, 0);
                                    }
                                    return result;
                                };
                            }
                            
                            player.setAttribute('data-seizure-safe-stopped', 'true');
                            // Keep visible but stop animation - force to final state
                            player.style.opacity = '1';
                            player.style.visibility = 'visible';
                        } catch (_) {}
                    });
                } catch (_) {}
                
                // Method 3: Stop via DOM elements with Lottie data attributes (using element.lottie reference)
                try {
                    const lottieElements = document.querySelectorAll('[data-lottie], [data-animation], .lottie, .lottie-animation');
                    lottieElements.forEach(element => {
                        try {
                            // Try to find and stop any Lottie instance on this element
                            // Check both element.lottie and element._lottie (different implementations store it differently)
                            const lottieInstance = element.lottie || element._lottie || element.__lottie;
                            
                            if (lottieInstance) {
                                // Use Lottie's official API methods
                                if (typeof lottieInstance.setSpeed === 'function') {
                                    lottieInstance.setSpeed(0);
                                }
                                if (typeof lottieInstance.stop === 'function') {
                                    lottieInstance.stop();
                                }
                                if (typeof lottieInstance.pause === 'function') {
                                    lottieInstance.pause();
                                }
                                if (typeof lottieInstance.goToAndStop === 'function') {
                                    // Go to final frame (finish to final state, not frame 0)
                                    const totalFrames = lottieInstance.totalFrames || lottieInstance.frameCount || 0;
                                    const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                    lottieInstance.goToAndStop(finalFrame, true);
                                } else if (typeof lottieInstance.goToAndPlay === 'function') {
                                    // Fallback: go to end if goToAndStop not available
                                    const totalFrames = lottieInstance.totalFrames || lottieInstance.frameCount || 0;
                                    const finalFrame = totalFrames > 0 ? totalFrames - 1 : 0;
                                    lottieInstance.goToAndPlay(finalFrame, true);
                                    if (typeof lottieInstance.pause === 'function') {
                                        setTimeout(() => lottieInstance.pause(), 0);
                                    }
                                }
                                if (lottieInstance.autoplay !== undefined) {
                                    lottieInstance.autoplay = false;
                                }
                                if (lottieInstance.loop !== undefined) {
                                    lottieInstance.loop = false;
                                }
                            }
                            
                            // Mark as stopped but keep visible - force to final state
                            element.setAttribute('data-seizure-safe-stopped', 'true');
                            element.style.animation = 'none';
                            element.style.transition = 'none';
                            element.style.opacity = '1';
                            element.style.visibility = 'visible';
                        } catch (_) {}
                    });
                } catch (_) {}
                
                // Method 4: CRITICAL - Directly freeze ALL canvas and SVG elements that might be Lottie
                // This stops rendering at the DOM level, not just the API level
                try {
                    // Find all canvas elements that might be Lottie animations
                    const allCanvases = document.querySelectorAll('canvas');
                    allCanvases.forEach(canvas => {
                        try {
                            // Skip if already frozen
                            if (canvas.hasAttribute('data-seizure-safe-frozen')) return;
                            
                            // Freeze the canvas directly
                            canvas.style.setProperty('animation', 'none', 'important');
                            canvas.style.setProperty('transition', 'none', 'important');
                            canvas.style.setProperty('pointer-events', 'none', 'important');
                            canvas.setAttribute('data-seizure-safe-frozen', 'true');
                            
                            // Try to stop any animation loops on this canvas
                            if (canvas._lottie) {
                                try {
                                    const anim = canvas._lottie;
                                    if (anim.animationID !== undefined && anim.animationID !== null) {
                                        cancelAnimationFrame(anim.animationID);
                                        anim.animationID = null;
                                    }
                                    if (anim.renderer && anim.renderer.animationID !== undefined && anim.renderer.animationID !== null) {
                                        cancelAnimationFrame(anim.renderer.animationID);
                                        anim.renderer.animationID = null;
                                    }
                                } catch (_) {}
                            }
                        } catch (_) {}
                    });
                    
                    // Find all SVG elements that might be Lottie
                    const allSvgs = document.querySelectorAll('svg');
                    allSvgs.forEach(svg => {
                        try {
                            // Skip if already frozen
                            if (svg.hasAttribute('data-seizure-safe-frozen')) return;
                            
                            // Freeze the SVG directly
                            svg.style.setProperty('animation', 'none', 'important');
                            svg.style.setProperty('transition', 'none', 'important');
                            svg.setAttribute('data-seizure-safe-frozen', 'true');
                            
                            // Stop any animations on child elements
                            const animatedElements = svg.querySelectorAll('*');
                            animatedElements.forEach(el => {
                                el.style.setProperty('animation', 'none', 'important');
                                el.style.setProperty('transition', 'none', 'important');
                            });
                        } catch (_) {}
                    });
                    
                    // Also handle Lottie containers
                    const lottieContainers = document.querySelectorAll('div[id*="lottie"], div[class*="lottie"]');
                    lottieContainers.forEach(container => {
                        try {
                            container.style.setProperty('animation', 'none', 'important');
                            container.style.setProperty('transition', 'none', 'important');
                            container.setAttribute('data-seizure-safe-stopped', 'true');
                            
                            // Freeze all canvas and SVG children
                            const canvases = container.querySelectorAll('canvas');
                            canvases.forEach(canvas => {
                                canvas.style.setProperty('animation', 'none', 'important');
                                canvas.style.setProperty('transition', 'none', 'important');
                                canvas.setAttribute('data-seizure-safe-frozen', 'true');
                            });
                            
                            const svgs = container.querySelectorAll('svg');
                            svgs.forEach(svg => {
                                svg.style.setProperty('animation', 'none', 'important');
                                svg.style.setProperty('transition', 'none', 'important');
                                svg.setAttribute('data-seizure-safe-frozen', 'true');
                            });
                        } catch (_) {}
                    });
                } catch (_) {}
                
               
            } catch (e) {
                // Silent fail - don't crash the website
            }
        }
        
        // Force all animated elements to their final visible state
        forceAllAnimationsToFinalVisibleState() {
            try {
                // Force all elements with animations to be visible and in final state
                const allAnimatedElements = document.querySelectorAll('*');
                allAnimatedElements.forEach(element => {
                    try {
                        const computed = window.getComputedStyle(element);
                        const hasAnimation = computed.animationName && computed.animationName !== 'none';
                        const hasTransition = computed.transitionProperty && computed.transitionProperty !== 'none';
                        const isHidden = computed.opacity === '0' || computed.visibility === 'hidden' || computed.display === 'none';
                        
                        // If element has animation/transition or is hidden, force to visible final state
                        if (hasAnimation || hasTransition || isHidden) {
                            // Skip widget elements
                            if (element.closest && (element.closest('.accessbit-widget') || element.closest('.accessbit-widget-panel') || element.closest('.accessbit-widget-icon'))) {
                                return;
                            }
                            
                            // Skip nav/header to preserve sticky behavior
                            if (element.matches && (element.matches('nav, header, .navbar, [role="navigation"]') || element.closest('nav, header, .navbar, [role="navigation"]'))) {
                                return;
                            }
                            
                            // CRITICAL: Skip dropdown menus to prevent them from auto-opening
                            // Check if element is a dropdown menu that should remain hidden
                            const className = element.className || '';
                            const id = element.id || '';
                            const role = element.getAttribute && element.getAttribute('role') || '';
                            const ariaExpanded = element.getAttribute && element.getAttribute('aria-expanded');
                            const tagName = element.tagName ? element.tagName.toLowerCase() : '';
                            
                            // Check if element has dropdown/menu classes/ids/roles
                            const hasDropdownClass = className.includes('dropdown') || id.includes('dropdown');
                            const hasMenuClass = (className.includes('menu') || id.includes('menu') || role === 'menu' || role === 'menubar') && 
                                                  !element.matches('nav') && !element.matches('header');
                            const hasSubmenuClass = className.includes('submenu') || className.includes('sub-menu') || id.includes('submenu') || id.includes('sub-menu');
                            
                            // Check for ul/ol elements that are likely dropdowns (nested lists in nav)
                            const isNestedList = (tagName === 'ul' || tagName === 'ol') && 
                                                  element.parentElement && 
                                                  (element.parentElement.matches('nav, header, [class*="nav"], [class*="header"]') ||
                                                   element.parentElement.closest('nav, header, [class*="nav"], [class*="header"]'));
                            
                            // Check if dropdown/menu is closed (not open/active/show)
                            const isOpen = className.includes('open') || className.includes('active') || className.includes('show') || 
                                          ariaExpanded === 'true';
                            
                            // If it's a dropdown/menu and it's closed, skip it
                            if ((hasDropdownClass || hasMenuClass || hasSubmenuClass || isNestedList) && !isOpen) {
                                return; // Don't force visibility on closed dropdown menus
                            }
                            
                            // Also check if element is inside a closed dropdown menu
                            let parent = element.parentElement;
                            let depth = 0;
                            while (parent && depth < 5) { // Check up to 5 levels up
                                const parentClass = parent.className || '';
                                const parentId = parent.id || '';
                                const parentRole = parent.getAttribute && parent.getAttribute('role') || '';
                                const parentAriaExpanded = parent.getAttribute && parent.getAttribute('aria-expanded');
                                const parentTagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                                
                                const parentHasDropdown = parentClass.includes('dropdown') || parentId.includes('dropdown');
                                const parentHasMenu = (parentClass.includes('menu') || parentId.includes('menu') || parentRole === 'menu' || parentRole === 'menubar') && 
                                                      !parent.matches('nav') && !parent.matches('header');
                                const parentHasSubmenu = parentClass.includes('submenu') || parentClass.includes('sub-menu') || parentId.includes('submenu') || parentId.includes('sub-menu');
                                const parentIsNestedList = (parentTagName === 'ul' || parentTagName === 'ol') && 
                                                          parent.parentElement && 
                                                          (parent.parentElement.matches('nav, header, [class*="nav"], [class*="header"]') ||
                                                           parent.parentElement.closest('nav, header, [class*="nav"], [class*="header"]'));
                                const parentIsOpen = parentClass.includes('open') || parentClass.includes('active') || parentClass.includes('show') || 
                                                     parentAriaExpanded === 'true';
                                
                                if ((parentHasDropdown || parentHasMenu || parentHasSubmenu || parentIsNestedList) && !parentIsOpen) {
                                    return; // Don't force visibility on elements inside closed dropdown menus
                                }
                                
                                parent = parent.parentElement;
                                depth++;
                            }
                            
                            // Force to final visible state
                            element.style.animation = 'none';
                            element.style.transition = 'none';
                            element.style.opacity = '1';
                            element.style.visibility = 'visible';
                            
                            // Remove clip-path restrictions that might hide content
                            if (computed.clipPath && computed.clipPath !== 'none') {
                                element.style.clipPath = 'none';
                            }
                            
                            // Ensure width/height aren't restricting visibility
                            if (computed.width === '0px' || computed.height === '0px') {
                                const rect = element.getBoundingClientRect();
                                if (rect.width === 0 && element.style.width !== 'auto') {
                                    element.style.width = 'auto';
                                }
                                if (rect.height === 0 && element.style.height !== 'auto') {
                                    element.style.height = 'auto';
                                }
                            }
                        }
                    } catch (_) {}
                });
                
                // Force all children of animated containers to be visible
                const animatedContainers = document.querySelectorAll('[class*="animate"], [class*="animation"], [data-animate], [data-animation]');
                animatedContainers.forEach(container => {
                    try {
                        const children = container.querySelectorAll('*');
                        children.forEach(child => {
                            if (child.closest && !child.closest('.accessbit-widget')) {
                                child.style.opacity = '1';
                                child.style.visibility = 'visible';
                            }
                        });
                    } catch (_) {}
                });
            } catch (e) {
                // Silent fail
            }
        }
        
        // Restore Lottie animations when seizure safe is disabled
        restoreLottieAnimations() {
         
            
            try {
                // Restore lottie-web API
                if (typeof window.lottie !== 'undefined') {
                    try {
                        // Unfreeze animations
                        if (typeof window.lottie.unfreeze === 'function') {
                            window.lottie.unfreeze();
                        }
                        
                        // Restore original loadAnimation function
                        if (seizureState && seizureState.originalLottieLoadAnimation) {
                            window.lottie.loadAnimation = seizureState.originalLottieLoadAnimation;
                            seizureState.originalLottieLoadAnimation = null;
                        }
                        
                      
                    } catch (_) {}
                }
                
                // Restore GSAP methods
                if (typeof window.gsap !== 'undefined' && seizureState && seizureState.gsapMethodsOverridden) {
                    try {
                        if (seizureState.originalGsapTo) {
                            window.gsap.to = seizureState.originalGsapTo;
                            seizureState.originalGsapTo = null;
                        }
                        if (seizureState.originalGsapFrom) {
                            window.gsap.from = seizureState.originalGsapFrom;
                            seizureState.originalGsapFrom = null;
                        }
                        if (seizureState.originalGsapFromTo) {
                            window.gsap.fromTo = seizureState.originalGsapFromTo;
                            seizureState.originalGsapFromTo = null;
                        }
                        if (seizureState.originalGsapTimeline) {
                            window.gsap.timeline = seizureState.originalGsapTimeline;
                            seizureState.originalGsapTimeline = null;
                        }
                        seizureState.gsapMethodsOverridden = false;
                    } catch (_) {}
                }
                
                // Restore lottie-player web components
                try {
                    const lottiePlayers = document.querySelectorAll('lottie-player[data-seizure-safe-stopped]');
                    lottiePlayers.forEach(player => {
                        try {
                            if (typeof player.play === 'function') {
                                player.play();
                            }
                            player.removeAttribute('data-seizure-safe-stopped');
                            // Restore visibility
                            player.style.opacity = '';
                            player.style.visibility = '';
                        } catch (_) {}
                    });
                } catch (_) {}
                
                // Restore DOM elements with Lottie data attributes
                try {
                    const lottieElements = document.querySelectorAll('[data-seizure-safe-stopped]');
                    lottieElements.forEach(element => {
                        try {
                            element.removeAttribute('data-seizure-safe-stopped');
                            element.style.animation = '';
                            element.style.transition = '';
                            element.style.transform = '';
                            // Restore visibility
                            element.style.opacity = '';
                            element.style.visibility = '';
                        } catch (_) {}
                    });
                } catch (_) {}
                
                // Restore Lottie containers (canvas, svg, div)
                try {
                    const lottieContainers = document.querySelectorAll('div[id*="lottie"][data-seizure-safe-stopped], div[class*="lottie"][data-seizure-safe-stopped], svg[class*="lottie"][data-seizure-safe-stopped], canvas[data-lottie][data-seizure-safe-stopped], canvas.lottie[data-seizure-safe-stopped]');
                    lottieContainers.forEach(container => {
                        try {
                            container.removeAttribute('data-seizure-safe-stopped');
                            container.style.animation = '';
                            container.style.transition = '';
                            container.style.transform = '';
                            // Restore visibility
                            container.style.opacity = '';
                            container.style.visibility = '';
                        } catch (_) {}
                    });
                } catch (_) {}
                
              
            } catch (e) {
                
            }
        }
        
        // SECURITY FIX: Removed requestAnimationFrame restoration - we no longer overwrite it
        restoreAllMediaAndAnimations() {
            try {
                if (seizureState && seizureState.applyWAAPIStopMotion) {
                    seizureState.applyWAAPIStopMotion(false);
                }
                
                // Restore videos and audio
                const pausedVideos = document.querySelectorAll('video[data-seizure-safe-paused]');
                pausedVideos.forEach(video => {
                    video.removeAttribute('data-seizure-safe-paused');
                    // Don't auto-play, just remove the seizure-safe attributes
                });
                
                const pausedAudios = document.querySelectorAll('audio[data-seizure-safe-paused]');
                pausedAudios.forEach(audio => {
                    audio.removeAttribute('data-seizure-safe-paused');
                });
                
                // Restore GIFs and images
                const replacedImages = document.querySelectorAll('img[data-seizure-safe-replaced]');
                replacedImages.forEach(img => {
                    if (img.dataset.originalSrc) {
                        img.src = img.dataset.originalSrc;
                        img.removeAttribute('data-seizure-safe-replaced');
                        delete img.dataset.originalSrc;
                    }
                });
                
                // Restore canvas elements
                const stoppedCanvases = document.querySelectorAll('canvas[data-seizure-safe-stopped]');
                stoppedCanvases.forEach(canvas => {
                    canvas.removeAttribute('data-seizure-safe-stopped');
                });
                
                // Restore SVG elements
                const stoppedSvgs = document.querySelectorAll('svg[data-seizure-safe-stopped]');
                stoppedSvgs.forEach(svg => {
                    svg.removeAttribute('data-seizure-safe-stopped');
                });
                
                // Restore embedded media
                const stoppedIframes = document.querySelectorAll('iframe[data-seizure-safe-stopped]');
                stoppedIframes.forEach(iframe => {
                    iframe.removeAttribute('data-seizure-safe-stopped');
                });
                
             
            } catch (e) {
                
            }
        }
        
        // Force complete letter-by-letter text animations for seizure safety
        // This ensures all text is immediately visible in its final state
        // Prevents duplication by checking if already processed
        forceCompleteTextAnimations() {
            // Use a flag to prevent multiple executions from duplicating content
            if (this._textAnimationsCompleted) return;
            this._textAnimationsCompleted = true;
            
            // First, find and process all parent containers that have split text
            // This must be done first to avoid processing children individually
            const splitContainers = document.querySelectorAll('[data-splitting], .split, [class*="split-text"], [class*="text-split"], [class*="text-animation"], [class*="typing"], [class*="typewriter"]');
            splitContainers.forEach(container => {
                if (container.hasAttribute('data-seizure-text-processed')) return;
                container.setAttribute('data-seizure-text-processed', 'true');
                
                // Find all character/word elements within this container
                const charElements = container.querySelectorAll('.char, [class*="char"], .letter, [class*="letter"], .word, [class*="word"]');
                if (charElements.length > 0) {
                    // Collect all text from character elements
                    let fullText = '';
                    charElements.forEach(char => {
                        const charText = char.textContent || char.innerText || '';
                        // Get text even if it's just a single character
                        if (charText) {
                            fullText += charText;
                        }
                    });
                    
                    // If we collected text, consolidate it
                    if (fullText.trim()) {
                            // Store original structure clone if needed, but replace with clean text
                            const originalClone = container.cloneNode(true);
                        // Hide all child elements to prevent layering
                        charElements.forEach(char => {
                            char.style.display = 'none';
                            char.style.visibility = 'hidden';
                            char.style.opacity = '0';
                            char.style.position = 'absolute';
                            char.style.pointerEvents = 'none';
                        });
                    }
                    
                    // Ensure container is visible and in final state
                    container.style.opacity = '1';
                    container.style.visibility = 'visible';
                    container.style.animation = 'none';
                    container.style.transition = 'none';
                    container.style.transform = 'none';
                    container.style.clipPath = 'none';
                    container.style.webkitClipPath = 'none';
                    container.style.width = '';
                    container.style.height = '';
                    container.style.maxWidth = '';
                    container.style.maxHeight = '';
                }
            });
            
            // Now handle individual text elements that might be animated
            const textElements = document.querySelectorAll('.char, .word, [class*="char"], [class*="word"], [class*="letter"], [class*="text-animation"]');
            textElements.forEach(element => {
                // Skip if already processed or if parent was processed
                if (element.hasAttribute('data-seizure-text-processed')) return;
                const parent = element.parentElement;
                if (parent && parent.hasAttribute('data-seizure-text-processed')) return;
                
                element.setAttribute('data-seizure-text-processed', 'true');
                
                // Force animation to final state immediately
                element.style.animation = 'none';
                element.style.transition = 'none';
                element.style.opacity = '1';
                element.style.visibility = 'visible';
                if (element.style.display === 'none') {
                    element.style.display = element.tagName === 'SPAN' ? 'inline' : 'block';
                }
                element.style.transform = 'none';
                element.style.clipPath = 'none';
                element.style.webkitClipPath = 'none';
                element.style.width = '';
                element.style.height = '';
                element.style.maxWidth = '';
                element.style.maxHeight = '';
            });
            
            // Also handle any text that might be using GSAP TextPlugin or similar
            // Look for elements with multiple overlapping text layers (common in GSAP text animations)
            // Only process elements that are likely part of text animations, not all paragraphs/divs
            const allTextContainers = document.querySelectorAll('h1, h2, h3, h4, h5, h6, [class*="text"], [class*="title"], [class*="heading"], [class*="hero"], [class*="headline"]');
            allTextContainers.forEach(element => {
                // Skip if already processed or if it's a nav/header element
                if (element.hasAttribute('data-seizure-text-processed') || 
                    element.closest('nav, header, .navbar, [class*="nav"], [class*="header"]')) return;
                
                const computedStyle = window.getComputedStyle(element);
                
                // Only process if element has animation-related classes or is part of a text animation
                const hasAnimationClass = element.classList.toString().match(/(animate|fade|slide|typing|typewriter|split|char|letter|text-animation|reveal|unveil)/i);
                const hasAnimationStyle = computedStyle.animation !== 'none' || computedStyle.transition !== 'none';
                const hasHiddenChildren = element.querySelectorAll('.char, .word, [class*="char"], [class*="letter"]').length > 0;
                
                // Check for overlapping sibling elements (common in GSAP text animations where multiple divs with same text are siblings)
                const parent = element.parentElement;
                const hasOverlappingSiblings = parent && Array.from(parent.children).filter(child => {
                    if (child === element) return false;
                    const childText = (child.textContent || '').trim();
                    const elementText = (element.textContent || '').trim();
                    // Check if sibling has similar or same text (overlapping layers)
                    return childText && elementText && (
                        childText === elementText || 
                        (childText.length > 10 && elementText.length > 10 && 
                         (childText.includes(elementText.substring(0, 20)) || elementText.includes(childText.substring(0, 20))))
                    );
                }).length > 0;
                
                // Skip if element doesn't appear to be part of a text animation
                if (!hasAnimationClass && !hasAnimationStyle && !hasHiddenChildren && !hasOverlappingSiblings) {
                    return;
                }
                
                // Handle overlapping siblings - hide siblings with same text (they're overlapping layers)
                if (hasOverlappingSiblings && parent) {
                    const siblings = Array.from(parent.children);
                    const elementText = (element.textContent || '').trim();
                    siblings.forEach(sibling => {
                        if (sibling === element) return;
                        const siblingText = (sibling.textContent || '').trim();
                        // If sibling has same or very similar text, hide it (it's an overlapping layer)
                        if (siblingText && elementText && (
                            siblingText === elementText || 
                            (siblingText.length > 10 && elementText.length > 10 && 
                             (siblingText.includes(elementText.substring(0, 20)) || elementText.includes(siblingText.substring(0, 20))))
                        )) {
                            sibling.style.display = 'none';
                            sibling.style.visibility = 'hidden';
                            sibling.style.opacity = '0';
                            sibling.style.position = 'absolute';
                            sibling.style.pointerEvents = 'none';
                        }
                    });
                }
                
                // Check if this element has multiple text layers (indicated by multiple children with same text)
                const children = Array.from(element.children);
                if (children.length > 0) {
                    // Check if children contain overlapping text
                    const childTexts = children.map(child => (child.textContent || '').trim()).filter(t => t);
                    const uniqueTexts = [...new Set(childTexts)];
                    
                    // If we have multiple children with text, consolidate
                    if (childTexts.length > 1 && uniqueTexts.length === 1) {
                        // All children have the same text - this is likely a layered animation
                        element.textContent = uniqueTexts[0];
                        children.forEach(child => {
                            child.style.display = 'none';
                            child.style.visibility = 'hidden';
                            child.style.opacity = '0';
                            child.style.position = 'absolute';
                            child.style.pointerEvents = 'none';
                        });
                    } else if (childTexts.length > 0 && hasHiddenChildren) {
                        // Different texts - concatenate them (only if has hidden children indicating animation)
                        const fullText = childTexts.join('');
                        if (fullText.trim() && fullText.trim() !== element.textContent.trim()) {
                            element.textContent = fullText.trim();
                            children.forEach(child => {
                                child.style.display = 'none';
                                child.style.visibility = 'hidden';
                                child.style.opacity = '0';
                            });
                        }
                    }
                }
                
                element.setAttribute('data-seizure-text-processed', 'true');
                
                // Only force visibility if element was actually hidden due to animation
                if (hasAnimationStyle || hasHiddenChildren || hasOverlappingSiblings) {
                    if (computedStyle.opacity !== '1' || computedStyle.visibility === 'hidden') {
                        element.style.opacity = '1';
                        element.style.visibility = 'visible';
                    }
                    if (computedStyle.animation !== 'none' || computedStyle.transition !== 'none') {
                        element.style.animation = 'none';
                        element.style.transition = 'none';
                        if (computedStyle.transform !== 'none') {
                            element.style.transform = 'none';
                        }
                    }
                    element.style.clipPath = 'none';
                    element.style.webkitClipPath = 'none';
                }
            });
            
            // Run again after a short delay to catch any dynamically added text
            setTimeout(() => {
                this._textAnimationsCompleted = false;
                this.forceCompleteTextAnimations();
            }, 100);
        }
    
        // Lock current button visual state to prevent hover color changes during seizure-safe
        lockButtonHoverStyles() {
            try {
                const root = document;
                // Only target actual buttons and links, not all interactive elements
                const buttons = root.querySelectorAll('a, button, [role="button"], .button, .btn');
                this._lockedButtons = [];
                buttons.forEach((btn) => {
                    const cs = window.getComputedStyle(btn);
                    const snapshot = {
                        el: btn,
                        style: {
                            backgroundColor: btn.style.backgroundColor,
                            color: btn.style.color,
                            borderColor: btn.style.borderColor,
                            boxShadow: btn.style.boxShadow,
                            filter: btn.style.filter,
                            transition: btn.style.transition
                        }
                    };
                    this._lockedButtons.push(snapshot);
                    // Apply computed values inline to freeze state
                    btn.style.backgroundColor = cs.backgroundColor;
                    btn.style.color = cs.color;
                    btn.style.borderColor = cs.borderColor;
                    btn.style.boxShadow = 'none';
                    btn.style.filter = 'none';
                    btn.style.transition = 'none';
                });
      
            } catch (e) {
                
            }
        }
    
        // Restore original inline styles on buttons
        restoreButtonHoverStyles() {
            try {
                if (!this._lockedButtons) return;
                this._lockedButtons.forEach(({ el, style }) => {
                    if (!el) return;
                    el.style.backgroundColor = style.backgroundColor || '';
                    el.style.color = style.color || '';
                    el.style.borderColor = style.borderColor || '';
                    el.style.boxShadow = style.boxShadow || '';
                    el.style.filter = style.filter || '';
                    el.style.transition = style.transition || '';
                });
                this._lockedButtons = null;
         
            } catch (e) {
                
            }
        }
        
        // Restore portfolio animations when seizure safety is disabled
        restorePortfolioAnimations() {
         
            
            // Remove inline styles that were set for seizure safety
            const portfolioCards = document.querySelectorAll('.portfolio-card');
            portfolioCards.forEach(card => {
                card.style.opacity = '';
                card.style.visibility = '';
                card.style.display = '';
            });
            
            const hoverCircle = document.querySelector('.hover-circle');
            if (hoverCircle) {
                hoverCircle.style.opacity = '';
                hoverCircle.style.visibility = '';
                hoverCircle.style.display = '';
            }
            
            const bgElements = document.querySelectorAll('.portfolio-hover-img, .bg-overlay');
            bgElements.forEach(bg => {
                bg.style.opacity = '';
                bg.style.visibility = '';
            });
            
           
            // Restore button styles
            this.restoreButtonHoverStyles();
        }
    
    
    
        // Apply only the grey overlay (grayscale filter) - this is the only difference from stop-animation
        addSeizureSafeGreyOverlay() {
            // Remove existing grey overlay if it exists
            const existingStyle = document.getElementById('accessbit-seizure-safe-grey-overlay');
            if (existingStyle) {
                existingStyle.remove();
            }
    
            // Create style element for grey overlay only
            const style = document.createElement('style');
            style.id = 'accessbit-seizure-safe-grey-overlay';
            style.textContent = `
                /* APPLY GREYISH COLOR FILTER - Reduce color intensity to prevent seizures */
                /* CRITICAL: Apply filters to content containers, NOT to body/html, to preserve sticky nav */
                /* Filters create stacking contexts that break sticky positioning - so we avoid them on body/html */
                /* Apply to main content areas and their children to get the grey muted color effect throughout the page */
                body.seizure-safe main,
                body.seizure-safe main *,
                body.seizure-safe section,
                body.seizure-safe section *,
                body.seizure-safe article,
                body.seizure-safe article *,
                body.seizure-safe div:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]):not([class*="navbar"]),
                body.seizure-safe p:not(nav p):not(header p),
                body.seizure-safe span:not(nav span):not(header span),
                html.seizure-safe main,
                html.seizure-safe main *,
                html.seizure-safe section,
                html.seizure-safe section *,
                html.seizure-safe article,
                html.seizure-safe article *,
                html.seizure-safe div:not(nav):not(header):not(.navbar):not([class*="nav"]):not([class*="header"]):not([class*="navbar"]),
                html.seizure-safe p:not(nav p):not(header p),
                html.seizure-safe span:not(nav span):not(header span) {
                    filter: grayscale(15%) contrast(0.95) brightness(0.98) !important;
                    -webkit-filter: grayscale(15%) contrast(0.95) brightness(0.98) !important;
                }
                
                /* Exclude widget container and all its contents from color filter */
                body.seizure-safe #accessbit-widget-container,
                body.seizure-safe [id*="accessbit-widget"],
                body.seizure-safe [class*="accessbit-widget"],
                body.seizure-safe [data-ck-widget] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Also exclude any shadow DOM content by targeting the host element */
                body.seizure-safe accessbit-widget {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
            `;
            document.head.appendChild(style);
        }
        
        // CSS Injection: Stop all CSS animations, transitions, and blinking text - same as stop-animation
        injectSeizureSafeAnimationCSS() {
            if (!document.getElementById('seizure-safe-animation-css')) {
                const style = document.createElement('style');
                style.id = 'seizure-safe-animation-css';
                style.textContent = `
                    /* Seizure-safe animation kill switch */
                    .seizure-safe *, .seizure-safe *::before, .seizure-safe *::after {
                        animation: none !important;
                        transition: none !important;
                        scroll-behavior: auto !important;
                        animation-play-state: paused !important;
                    }

                    /* Remove common flash triggers */
                    .seizure-safe *[class*="blink"], .seizure-safe *[class*="shimmer"], 
                    .seizure-safe *[class*="pulse"], .seizure-safe *[class*="caret"], 
                    .seizure-safe *[class*="cursor-blink"], .seizure-safe *[class*="skeleton"],
                    .seizure-safe *[class*="pulsing"], .seizure-safe *[class*="flashing"] {
                        animation: none !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                    }

                /* Stop Webflow interactions (data-w-id) */
                .seizure-safe [data-w-id] {
                    animation: none !important;
                    transition: none !important;
                    transform: none !important;
                    opacity: 1 !important;
                }

                /* Stop transforms on buttons/links (but allow hover animations) */
                .seizure-safe a, .seizure-safe button, .seizure-safe [role="button"] {
                    transition: none !important;
                    transform: none !important;
                }
                `;
                document.head.appendChild(style);
            }
        }
        
        addSeizureSafeStyles() {
            // Remove existing styles if they exist
            this.removeSeizureSafeStyles();
    
            // Create style element for seizure-safe overlay
            const style = document.createElement('style');
            style.id = 'accessbit-seizure-safe-styles';
            style.textContent = `
                /* COMPREHENSIVE SEIZURE-SAFE STYLES - AccessiBe-style animation stopping */
                
                /* 0. APPLY GREYISH COLOR FILTER - Reduce color intensity to prevent seizures */
                body.seizure-safe,
                html.seizure-safe {
                    filter: grayscale(15%) contrast(0.95) brightness(0.98) !important;
                    -webkit-filter: grayscale(15%) contrast(0.95) brightness(0.98) !important;
                }
                
                /* Exclude widget container and all its contents from color filter */
                body.seizure-safe #accessbit-widget-container,
                body.seizure-safe [id*="accessbit-widget"],
                body.seizure-safe [class*="accessbit-widget"],
                body.seizure-safe [data-ck-widget] {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* Also exclude any shadow DOM content by targeting the host element */
                body.seizure-safe accessbit-widget {
                    filter: none !important;
                    -webkit-filter: none !important;
                }
                
                /* 1. HALT CSS ANIMATIONS - Stop all CSS animations immediately */
                body.seizure-safe *,
                body.seizure-safe *::before,
                body.seizure-safe *::after {
                    animation: none !important;
                    animation-name: none !important;
                    animation-duration: 0s !important;
                    animation-timing-function: linear !important;
                    animation-delay: 0s !important;
                    animation-iteration-count: 1 !important;
                    animation-direction: normal !important;
                    animation-fill-mode: forwards !important;
                    animation-play-state: paused !important;
                }
                
                /* 2. HALT CSS TRANSITIONS - Stop all smooth transitions */
                body.seizure-safe *,
                body.seizure-safe *::before,
                body.seizure-safe *::after {
                    transition: none !important;
                    transition-property: none !important;
                    transition-duration: 0s !important;
                    transition-timing-function: linear !important;
                    transition-delay: 0s !important;
                }
                
                /* 3. STOP MOTION EFFECTS - Prevent transform-based animations */
                /* BUT preserve transforms for slider manual navigation */
                body.seizure-safe *:not(.swiper-slide):not(.slick-slide):not(.carousel-item):not([class*="swiper"]):not([class*="slick"]):not([class*="carousel"]):not([data-slider]):not([data-carousel]):not([class*="slider"]):not([class*="carousel"]) {
                    transform: none !important;
                    transform-origin: unset !important;
                    scale: 1 !important;
                    zoom: 1 !important;
                    will-change: auto !important;
                }
                
                /* 4. STOP LOTTIE ANIMATIONS - Universal Lottie stopping (make invisible like stop-animation) */
                body.seizure-safe lottie-player,
                body.seizure-safe [data-lottie],
                body.seizure-safe [data-animation],
                body.seizure-safe .lottie,
                body.seizure-safe .lottie-animation,
                body.seizure-safe div[id*="lottie"],
                body.seizure-safe div[class*="lottie"],
                body.seizure-safe svg[class*="lottie"],
                body.seizure-safe canvas[data-lottie],
                body.seizure-safe canvas.lottie {
                    animation: none !important;
                    transition: none !important;
                    transform: none !important;
                    animation-play-state: paused !important;
                    opacity: 0 !important;
                    visibility: hidden !important;
                }
                
                /* 5. STOP BLINKING TEXT AND FLASHING ELEMENTS - WCAG 2.3.1 compliance */
                body.seizure-safe *,
                body.seizure-safe *::before,
                body.seizure-safe *::after {
                    visibility: visible !important;
                    opacity: 1 !important;
                    /* REMOVED: color: inherit !important; - Don't change font colors, only apply overall greyscale filter */
                    text-decoration: none !important;
                    animation-duration: 0s !important;
                    transition-duration: 0s !important;
                    animation-iteration-count: 1 !important;
                    animation-play-state: paused !important;
                }
                
                /* 6. STOP SMOOTH SCROLLING - Prevent vestibular-triggering motion */
                /* REMOVED: scroll-behavior: auto - This was blocking Lenis smooth scrolling */
                /* Lenis handles smooth scrolling and should not be blocked */
                
                /* 7. STOP VIDEO AND MEDIA AUTOPLAY */
                body.seizure-safe video[autoplay],
                body.seizure-safe audio[autoplay] {
                    animation-play-state: paused !important;
                }
                
                body.seizure-safe video,
                body.seizure-safe audio {
                    animation: none !important;
                    transition: none !important;
                }
                
                /* 8. RESPECT PREFERS-REDUCED-MOTION - WCAG compliance */
                @media (prefers-reduced-motion: reduce) {
                    body.seizure-safe *,
                    body.seizure-safe *::before,
                    body.seizure-safe *::after {
                        animation: none !important;
                        transition: none !important;
                        transform: none !important;
                        animation-duration: 0.01s !important;
                        transition-duration: 0.01s !important;
                    }
                }
                
                /* ULTIMATE ANIMATION KILLER - Stop everything */
                body.seizure-safe * {
                    animation-name: none !important;
                    animation-duration: 0s !important;
                    animation-timing-function: linear !important;
                    animation-delay: 0s !important;
                    animation-iteration-count: 1 !important;
                    animation-direction: normal !important;
                    animation-fill-mode: none !important;
                    animation-play-state: paused !important;
                    transition-property: none !important;
                    transition-duration: 0s !important;
                    transition-timing-function: linear !important;
                    transition-delay: 0s !important;
                }
                
                /* PREVENT ZOOMING AND SCALING - No transform effects */
                body.seizure-safe * {
                    transform: none !important;
                    transform-origin: unset !important;
                    scale: 1 !important;
                    zoom: 1 !important;
                }
                
                
                /* Stop ALL CSS animations by name */
                body.seizure-safe * {
                    animation-name: none !important;
                    animation-timing-function: linear !important;
                    animation-fill-mode: none !important;
                }
                
                /* Stop specific animation classes - INCLUDING SCROLL ANIMATIONS */
                body.seizure-safe *[class*="animate"],
                body.seizure-safe *[class*="fade"],
                body.seizure-safe *[class*="slide"],
                body.seizure-safe *[class*="bounce"],
                body.seizure-safe *[class*="pulse"],
                body.seizure-safe *[class*="shake"],
                body.seizure-safe *[class*="flash"],
                body.seizure-safe *[class*="blink"],
                body.seizure-safe *[class*="glow"],
                body.seizure-safe *[class*="spin"],
                body.seizure-safe *[class*="rotate"],
                body.seizure-safe *[class*="scale"],
                body.seizure-safe *[class*="zoom"],
                body.seizure-safe *[class*="wiggle"],
                body.seizure-safe *[class*="jiggle"],
                body.seizure-safe *[class*="twist"],
                body.seizure-safe *[class*="flip"],
                body.seizure-safe *[class*="swing"],
                body.seizure-safe *[class*="wobble"],
                body.seizure-safe *[class*="tilt"],
                body.seizure-safe *[class*="scroll"] {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                }
                
                /* Stop library animations - INCLUDING SCROLL ANIMATIONS */
                body.seizure-safe .fade-up,
                body.seizure-safe .fade-left,
                body.seizure-safe .fade-right,
                body.seizure-safe .fade-in,
                body.seizure-safe .slide-in,
                body.seizure-safe .scale-in,
                body.seizure-safe .zoom-in {
                    animation: none !important;
                    transition: none !important;
                    animation-play-state: paused !important;
                    animation-fill-mode: forwards !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                }
                
                /* Stop text animations - INCLUDING SCROLL ANIMATIONS */
                body.seizure-safe [data-splitting],
                body.seizure-safe .split, 
                body.seizure-safe .char, 
                body.seizure-safe .word {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                }
                
                /* Stop SVG animations - INCLUDING SCROLL ANIMATIONS */
                body.seizure-safe svg,
                body.seizure-safe svg path,
                body.seizure-safe svg line,
                body.seizure-safe svg circle,
                body.seizure-safe svg rect,
                body.seizure-safe svg polygon {
                    animation: none !important;
                    transition: none !important;
                    animation-play-state: paused !important;
                    animation-fill-mode: forwards !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                }
                
                /* STOP SCROLL-TRIGGERED ANIMATIONS - AOS, ScrollTrigger, WOW, Webflow interactions, etc. - Generic approach */
                body.seizure-safe [data-scroll],
                body.seizure-safe [data-aos],
                body.seizure-safe [data-animate],
                body.seizure-safe [data-scroll-speed],
                body.seizure-safe [data-scroll-direction],
                body.seizure-safe .aos-init,
                body.seizure-safe .aos-animate,
                body.seizure-safe .wow,
                body.seizure-safe .animated,
                body.seizure-safe [class*="scroll-trigger"],
                body.seizure-safe [class*="scroll-animate"],
                body.seizure-safe [class*="scroll-reveal"],
                body.seizure-safe [class*="w-"],
                body.seizure-safe [data-wf-page],
                body.seizure-safe [data-w-id],
                body.seizure-safe [class*="w-"]:not([class*="slider"]):not([class*="swiper"]):not([class*="slick"]):not([class*="carousel"]) {
                    animation: none !important;
                    transition: none !important;
                    animation-play-state: paused !important;
                    animation-fill-mode: forwards !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    transform: none !important;
                    will-change: auto !important;
                }
                
                /* GENERIC: Freeze any elements with inline transform/opacity styles (common in scroll animations like Webflow) */
                /* BUT exclude sliders to allow manual navigation */
                body.seizure-safe *[style*="transform"]:not(.swiper-slide):not(.slick-slide):not(.carousel-item):not([class*="swiper"]):not([class*="slick"]):not([class*="carousel"]):not([class*="slider"]):not([data-slider]):not([data-carousel]):not([data-seizure-safe-allow-transform]),
                body.seizure-safe *[style*="opacity"]:not(.swiper-slide):not(.slick-slide):not(.carousel-item):not([class*="swiper"]):not([class*="slick"]):not([class*="carousel"]):not([class*="slider"]):not([data-slider]):not([data-carousel]):not([data-seizure-safe-allow-transform]) {
                    transform: none !important;
                    opacity: 1 !important;
                    transition: none !important;
                }
                
                /* Stop Lottie animations specifically - Make invisible to prevent seizures */
                body.seizure-safe [data-lottie],
                body.seizure-safe .lottie,
                body.seizure-safe canvas[data-lottie],
                body.seizure-safe canvas.lottie {
                    animation: none !important;
                    transition: none !important;
                    animation-play-state: paused !important;
                    animation-fill-mode: forwards !important;
                    opacity: 0 !important;
                    visibility: hidden !important;
                    /* REMOVED: display: none !important; - Don't hide, just stop animations */
                }
                
                    animation-play-state: paused !important;
                    animation-fill-mode: forwards !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                }
                
                /* STOP SCROLL ANIMATIONS - Stop all scroll-triggered animations */
                body.seizure-safe *[class*="scroll"],
                body.seizure-safe *[class*="progress"],
                body.seizure-safe *[class*="bar"],
                body.seizure-safe *[class*="line"],
                body.seizure-safe *[class*="timeline"],
                body.seizure-safe *[class*="scroll-progress"],
                body.seizure-safe *[class*="scroll-indicator"] {
                    animation: none !important;
                    transition: none !important;
                    animation-play-state: paused !important;
                    animation-fill-mode: forwards !important;
                }
                
                /* Stop media animations */
                body.seizure-safe video,
                body.seizure-safe audio {
                    animation: none !important;
                    transition: none !important;
                    animation-fill-mode: forwards !important;
                }
                
                /* CRITICAL: Ensure scrolling works properly and prevent zooming */
                body.seizure-safe {
                    /* Greyscale filter is applied at html/body level, not here */
                    overflow: auto !important;
                    overflow-x: auto !important;
                    overflow-y: auto !important;
                    scroll-behavior: auto !important;
                    /* Do NOT set position: static on body as it breaks sticky/fixed navigation */
                    transform: none !important;
                    scale: 1 !important;
                    zoom: 1 !important;
                }
                
                /* CRITICAL: Preserve navigation positioning - do not override position for nav elements */
                body.seizure-safe nav,
                body.seizure-safe header,
                body.seizure-safe .navbar,
                body.seizure-safe [role="navigation"],
                body.seizure-safe [class*="nav"],
                body.seizure-safe [class*="header"],
                body.seizure-safe [class*="navbar"],
                body.seizure-safe [data-sticky],
                body.seizure-safe [data-fixed],
                body.seizure-safe [style*="position: sticky"],
                body.seizure-safe [style*="position:fixed"],
                body.seizure-safe [style*="position: fixed"] {
                    position: inherit !important;
                    transform: inherit !important;
                }
                
                body.seizure-safe html {
                    transform: none !important;
                    scale: 1 !important;
                    zoom: 1 !important;
                }
                
                body.seizure-safe html {
                    overflow: auto !important;
                    overflow-x: auto !important;
                    overflow-y: auto !important;
                    /* REMOVED: scroll-behavior: auto !important; - This was blocking website scroll animations */
                }
                
                /* REMOVED: Force all containers to allow scrolling - This was blocking website scroll animations */
                /* body.seizure-safe * {
                    scroll-behavior: auto !important;
                } */
                
                /* Preserve accessibility widget */
                body.seizure-safe .accessbit-widget,
                body.seizure-safe .accessbit-widget-panel,
                body.seizure-safe .toggle-switch {
                    filter: saturate(0.95) !important;
                }
            `;
    
            document.head.appendChild(style);
            
        }
    
    
    
        removeSeizureSafeStyles() {
            // Remove old style if it exists (backward compatibility)
            const existingStyle = document.getElementById('accessbit-seizure-safe-styles');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            // Remove new animation CSS
            const existingAnimationStyle = document.getElementById('seizure-safe-animation-css');
            if (existingAnimationStyle) {
                existingAnimationStyle.remove();
            }
            
            // Remove grey overlay
            const existingGreyOverlay = document.getElementById('accessbit-seizure-safe-grey-overlay');
            if (existingGreyOverlay) {
                existingGreyOverlay.remove();
            }
            
            // Reset cursor styles that were applied by seizure-safe mode
            document.body.style.cursor = '';
            const allElements = document.querySelectorAll('*');
            allElements.forEach(element => {
                element.style.cursor = '';
            });
            
            // Also reset cursor on Shadow DOM host
            if (this.shadowRoot && this.shadowRoot.host) {
                this.shadowRoot.host.style.cursor = '';
            }
        }
    
    
    
        // ADHD Friendly Profile Methods
    
        enableADHDFriendly() {
            // Disable other mutually exclusive features
            if (this.settings['seizure-safe']) {
                this.disableSeizureSafe();
                this.updateToggleSwitch('seizure-safe', false);
            }
            if (this.settings['vision-impaired']) {
                this.disableVisionImpaired();
                this.updateToggleSwitch('vision-impaired', false);
            }
            if (this.settings['cognitive-disability']) {
                this.disableCognitiveDisability();
                this.updateToggleSwitch('cognitive-disability', false);
            }
    
            this.settings['adhd-friendly'] = true;
    
            document.body.classList.add('adhd-friendly');
            document.documentElement.classList.add('adhd-friendly');
    
            this.createADHDSpotlight();
            this.applyADHDContrastEnhancement();
    
            this.saveSettings();
    
            
    
        }
    
    
    
        disableADHDFriendly() {
    
            this.settings['adhd-friendly'] = false;
    
            document.body.classList.remove('adhd-friendly');
            document.documentElement.classList.remove('adhd-friendly');
    
            this.removeADHDSpotlight();
            this.removeADHDContrastEnhancement();
    
            this.saveSettings();
    

    
        }
    
    
    
        createADHDSpotlight() {
    
            // Remove existing spotlight if any
    
            this.removeADHDSpotlight();
    
            
    
            // Create full-screen dark overlay with spotlight cutout
    
            const spotlight = document.createElement('div');
    
            spotlight.id = 'adhd-spotlight';
    
            spotlight.style.cssText = `
    
                position: fixed;
    
                top: 0;
    
                left: 0;
    
                width: 100vw;
    
                height: 100vh;
    
                pointer-events: none;
    
                z-index: 2147483647 !important; /* Ensure spotlight stays above the widget panel */
    
                /* Dark overlay with spotlight cutout using box-shadow technique */
                background: transparent;
    
                /* Create spotlight hole using large box-shadow */
                box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
    
                transition: all 0.1s ease;
    
            `;
    
            document.body.appendChild(spotlight);
    
            
    
            // Spotlight should be above widget panel, so we don't need to lower widget z-index
    
            
    
            // Also ensure the shadow root host has high z-index
    
            const shadowHost = document.querySelector('#accessbit-widget');
    
            if (shadowHost) {
    
                shadowHost.style.zIndex = '1000000';
    
            }
    
            
    
            // Add mouse move event listener to position the spotlight cutout
    
            this.adhdMouseMoveHandler = (e) => {
    
                const x = e.clientX;
                const y = e.clientY;
                const height = 200; // Spotlight height
    
                // Position the spotlight cutout using box-shadow technique
                spotlight.style.left = '0px';
                spotlight.style.top = (y - height/2) + 'px';
                spotlight.style.width = '100vw';
                spotlight.style.height = height + 'px';
                spotlight.style.borderRadius = '0px';
                spotlight.style.background = 'transparent';
                spotlight.style.boxShadow = `0 0 0 9999px rgba(0, 0, 0, 0.5)`;
    
            };
    
            
    
            document.addEventListener('mousemove', this.adhdMouseMoveHandler);
    
           
    
        }
    
    
    
        removeADHDSpotlight() {
    
            // Remove dark overlay
    
            const darkOverlay = document.getElementById('adhd-dark-overlay');
    
            if (darkOverlay) {
    
                darkOverlay.remove();
    
            }
    
            
    
            // Remove spotlight
    
            const spotlight = document.getElementById('adhd-spotlight');
    
            if (spotlight) {
    
                spotlight.remove();
    
            }
    
            
    
            // Remove mouse move event listener
    
            if (this.adhdMouseMoveHandler) {
    
                document.removeEventListener('mousemove', this.adhdMouseMoveHandler);
    
                this.adhdMouseMoveHandler = null;
    
            }
    
            
    
        
    
        }
    
        // Apply ADHD contrast enhancement
        applyADHDContrastEnhancement() {
            try {
                // Remove existing ADHD contrast styles if any
                const existingStyle = document.getElementById('adhd-contrast-enhancement');
                if (existingStyle) {
                    existingStyle.remove();
                }

                const style = document.createElement('style');
                style.id = 'adhd-contrast-enhancement';
                style.textContent = `
                    /* ADHD FRIENDLY: Enhanced Contrast for Better Focus */
                    
                    /* 1. GLOBAL CONTRAST ENHANCEMENT - Increase overall contrast */
                    html.adhd-friendly {
                        filter: contrast(1.15) brightness(1.08) saturate(1.1) !important;
                        transition: filter 0.3s ease-in-out !important;
                    }
                    
                    /* REMOVED: TEXT CONTRAST ENHANCEMENT - User only wants spotlight, not text color changes */
                    /* REMOVED: HEADING CONTRAST ENHANCEMENT - User only wants spotlight, not text color changes */
                    /* REMOVED: LINK CONTRAST ENHANCEMENT - User only wants spotlight, not text color changes or underlines */
                    
                    /* 5. BUTTON CONTRAST ENHANCEMENT - More visible buttons */
                    body.adhd-friendly button,
                    body.adhd-friendly input[type="button"],
                    body.adhd-friendly input[type="submit"],
                    body.adhd-friendly input[type="reset"],
                    body.adhd-friendly .btn {
                        background-color: #0066cc !important;
                        color: #ffffff !important;
                        border: 2px solid #004499 !important;
                        font-weight: 600 !important;
                        text-shadow: none !important;
                        transition: all 0.3s ease-in-out !important;
                    }
                    
                    body.adhd-friendly button:hover,
                    body.adhd-friendly input[type="button"]:hover,
                    body.adhd-friendly input[type="submit"]:hover,
                    body.adhd-friendly input[type="reset"]:hover,
                    body.adhd-friendly .btn:hover {
                        background-color: #004499 !important;
                        border-color: #003366 !important;
                    }
                    
                    /* 6. FORM ELEMENT CONTRAST ENHANCEMENT - Better form visibility */
                    body.adhd-friendly input,
                    body.adhd-friendly textarea,
                    body.adhd-friendly select {
                        border: 2px solid #666666 !important;
                        background-color: #ffffff !important;
                        color: #1a1a1a !important;
                        font-weight: 500 !important;
                        transition: all 0.3s ease-in-out !important;
                    }
                    
                    body.adhd-friendly input:focus,
                    body.adhd-friendly textarea:focus,
                    body.adhd-friendly select:focus {
                        border-color: #0066cc !important;
                        box-shadow: 0 0 5px rgba(0, 102, 204, 0.3) !important;
                    }
                    
                    /* 7. FOCUS INDICATORS - Enhanced focus visibility */
                    body.adhd-friendly *:focus {
                        outline: 3px solid #0066cc !important;
                        outline-offset: 2px !important;
                        transition: outline 0.2s ease-in-out !important;
                    }
                    
                    /* 8. IMAGE CONTRAST ENHANCEMENT - Slightly enhance images */
                    body.adhd-friendly img {
                        filter: contrast(1.1) brightness(1.05) !important;
                        transition: filter 0.3s ease-in-out !important;
                    }
                    
                    /* REMOVED: NAVIGATION CONTRAST ENHANCEMENT - User only wants spotlight, not nav text color changes or underlines */
                `;
                
                document.head.appendChild(style);
          
                
            } catch (error) {
                
            }
        }
        
        // Remove ADHD contrast enhancement
        removeADHDContrastEnhancement() {
            try {
                const existingStyle = document.getElementById('adhd-contrast-enhancement');
                if (existingStyle) {
                    existingStyle.remove();
               
                }
            } catch (error) {
                
            }
        }
    
    
    
        // Cognitive Disability Profile Methods
    
        enableCognitiveDisability() {
            // Disable other mutually exclusive features
            if (this.settings['seizure-safe']) {
                this.disableSeizureSafe();
                this.updateToggleSwitch('seizure-safe', false);
            }
            if (this.settings['vision-impaired']) {
                this.disableVisionImpaired();
                this.updateToggleSwitch('vision-impaired', false);
            }
            if (this.settings['adhd-friendly']) {
                this.disableADHDFriendly();
                this.updateToggleSwitch('adhd-friendly', false);
            }
            
            this.settings['cognitive-disability'] = true;
            document.body.classList.add('cognitive-disability');
            
            // Add CSS to minimize layout impact
            this.addCognitiveCSS();
            this.addCognitiveBoxes();
            
            // Save settings
            this.saveSettings();
            
        }
        
        addCognitiveCSS() {
            // Remove existing cognitive CSS if any
            const existingStyle = document.getElementById('cognitive-css');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            const style = document.createElement('style');
            style.id = 'cognitive-css';
            style.textContent = `
                /* Cognitive Disability: Minimize layout impact */
                .cognitive-disability {
                    /* Prevent layout breaking from cognitive boxes */
                    box-sizing: border-box !important;
                }
                
                .cognitive-disability * {
                    box-sizing: border-box !important;
                }
                
                /* Ensure cognitive boxes don't cause overflow */
                .cognitive-disability body {
                    overflow-x: auto !important;
                    overflow-y: auto !important;
                }
                
                /* Prevent extra whitespace */
                .cognitive-disability html {
                    height: auto !important;
                }
                
                .cognitive-disability body {
                    height: auto !important;
                    margin: 0 !important;
                    padding: 0 !important;
                }
            `;
            document.head.appendChild(style);
        }
    
    
    
        disableCognitiveDisability() {
            this.settings['cognitive-disability'] = false;
            document.body.classList.remove('cognitive-disability');
            
            // Remove cognitive CSS
            const existingStyle = document.getElementById('cognitive-css');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            this.removeCognitiveBoxes();
            
            // Save settings
            this.saveSettings();
            
            

            // Force a lightweight refresh to fully restore original layout/styles
            try {
                setTimeout(() => {
                    try { window.location.reload(); } catch (_) {}
                }, 50);
            } catch (_) {}
        }
    
    
    
        addCognitiveBoxes() {
    
            // Add boxes around headings, buttons and links (excluding accessibility panel)
    
            const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
            const buttons = document.querySelectorAll('button, .btn, input[type="button"], input[type="submit"]');
    
            // Comprehensive selectors to catch links and dropdown menu items generically
            const links = document.querySelectorAll(
                [
                    'a',
                    'nav a', '.nav a', '.navbar a', '.nav-menu a',
                    '.menu a', '.dropdown a', '.dropdown-menu a',
                    '.breadcrumb a', '.pagination a',
                    '.menu-item a', '.submenu a',
                    // Elements that act like menu items or links without being <a>
                    '[role="link"]', '[role="menuitem"]', '[role="menuitemcheckbox"]', '[role="menuitemradio"]',
                    'button[role="menuitem"]', 'button[aria-haspopup]', 'button[aria-expanded]',
                    '[aria-haspopup="menu"]', '[aria-haspopup="true"]', '[aria-expanded]',
                    '.dropdown-item', '.menu-item', '.submenu-item', '.nav-link', '.nav-item > a', '.nav-item > button'
                ].join(', ')
            );
    
            
    
            // Process headings (non-intrusive: apply outline to element itself)
            headings.forEach(heading => {
                if (heading.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
                    return;
                }
                if (!heading.dataset.cognitiveBoxed) {
                    heading.style.outline = '2px solid #6366f1';
                    heading.style.outlineOffset = '2px';
                    heading.style.borderRadius = '6px';
                    heading.style.boxShadow = '0 2px 8px rgba(99, 102, 241, 0.3)';
                    heading.dataset.cognitiveBoxed = 'true';
                }
            });
    
            
    
            // Process buttons (apply outline only)
            buttons.forEach(button => {
                if (button.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
                    return;
                }
                if (!button.dataset.cognitiveBoxed) {
                    button.style.outline = '2px solid #f97316';
                    button.style.outlineOffset = '2px';
                    // Do not change border radius to preserve original button shape
                    button.style.boxShadow = '0 2px 8px rgba(249, 115, 22, 0.3)';
                    button.dataset.cognitiveBoxed = 'true';
                }
            });
    
            
    
            // Process links (apply outline only)
            links.forEach(link => {
                if (link.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon')) {
                    return;
                }
                if (!link.dataset.cognitiveBoxed) {
                    link.style.outline = '2px solid #f97316';
                    link.style.outlineOffset = '2px';
                    // Do not change border radius to preserve original link/button shape
                    link.style.boxShadow = '0 2px 6px rgba(249, 115, 22, 0.3)';
                    link.dataset.cognitiveBoxed = 'true';
                }
            });
    
            
    
            
            
            // Add MutationObserver to handle dynamically added menu items
            if (!this.cognitiveObserver) {
                this.cognitiveObserver = new MutationObserver((mutations) => {
                    let shouldReapply = false;
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    // Check if new links, buttons, or headings were added
                                    if (node.matches && (node.matches('a, button, h1, h2, h3, h4, h5, h6') || 
                                        node.querySelector && node.querySelector('a, button, h1, h2, h3, h4, h5, h6'))) {
                                        shouldReapply = true;
                                    }
                                }
                            });
                        }
                    });
                    
                    if (shouldReapply) {
                        // Reapply cognitive boxes to new elements
                        setTimeout(() => {
                            this.addCognitiveBoxes();
                        }, 100);
                    }
                });
                
                // Start observing
                this.cognitiveObserver.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
    
        }
    
    
    
        removeCognitiveBoxes() {
    
            // Clean up MutationObserver
            if (this.cognitiveObserver) {
                this.cognitiveObserver.disconnect();
                this.cognitiveObserver = null;
            }
    
            // Remove outlines from headings
            const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
            headings.forEach(heading => {
                if (heading.dataset.cognitiveBoxed) {
                    heading.style.outline = '';
                    heading.style.outlineOffset = '';
                    heading.style.borderRadius = '';
                    heading.style.boxShadow = '';
                    delete heading.dataset.cognitiveBoxed;
                }
            });
    
            
    
            // Remove outlines from buttons
            const buttons = document.querySelectorAll('button, .btn, input[type="button"], input[type="submit"]');
            buttons.forEach(button => {
                if (button.dataset.cognitiveBoxed) {
                    button.style.outline = '';
                    button.style.outlineOffset = '';
                    button.style.borderRadius = '';
                    button.style.boxShadow = '';
                    delete button.dataset.cognitiveBoxed;
                }
            });
    
            
    
            // Remove outlines from links
            const links = document.querySelectorAll('a, nav a, .nav a, .navbar a, .menu a, .dropdown a, .breadcrumb a, .pagination a, [role="menuitem"] a, [role="button"] a');
            links.forEach(link => {
                if (link.dataset.cognitiveBoxed) {
                    link.style.outline = '';
                    link.style.outlineOffset = '';
                    link.style.borderRadius = '';
                    link.style.boxShadow = '';
                    delete link.dataset.cognitiveBoxed;
                }
            });
    
            
    
          
    
        }
    
    
    
        // Text Alignment Methods
    
        alignTextLeft() {
    
         
    
            this.applyTextAlignment('left');
    
        }
    
    
    
        alignTextCenter() {
    
           
    
            this.applyTextAlignment('center');
    
        }
    
    
    
        alignTextRight() {
    
          
    
            this.applyTextAlignment('right');
    
        }
    
    
    
        applyTextAlignment(alignment) {
     
    
            // Apply to document body first
    
            document.body.style.setProperty('text-align', alignment);
    
            
    
            // Apply to all text elements - be very broad
    
            const allElements = document.querySelectorAll('*');
    
            let count = 0;
    
            
    
            allElements.forEach(element => {
    
                // Skip accessibility controls
    
                if (element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon, .text-alignment-panel, #text-alignment-panel, .alignment-toggle-btn')) {
    
                    return;
    
                }
    
                
    
                // Apply to all elements that can contain text
    
                const tagName = element.tagName.toLowerCase();
    
                if (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'span', 'section', 'article', 'main', 'header', 'footer', 'nav', 'li', 'td', 'th', 'blockquote', 'cite', 'address', 'label', 'a'].includes(tagName)) {
    
                    element.style.setProperty('text-align', alignment);
    
                    count++;
    
                }
    
            });
    
            
    
            // Also apply to common content classes
    
            const contentSelectors = [
    
                '.container', '.hero', '.hero-content', '.hero-text', 
    
                '.about', '.about-content', '.about-text',
    
                '.services', '.services-grid', '.service-card',
    
                '.contact', '.contact-content', '.contact-info',
    
                '.footer', '.footer-content', '.footer-section',
    
                '.test-section', '.test-block'
    
            ];
    
            
    
            contentSelectors.forEach(selector => {
    
                const elements = document.querySelectorAll(selector);
    
                elements.forEach(element => {
    
                    if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon, .text-alignment-panel, #text-alignment-panel, .alignment-toggle-btn')) {
    
                        element.style.setProperty('text-align', alignment);
    
                        count++;
    
                    }
    
                });
    
            });
    
        
    
        }
    
    
    
        resetTextAlignment() {
        
    
            // Reset document body
    
            document.body.style.removeProperty('text-align');
    
            
    
            // Reset all elements - be very broad
    
            const allElements = document.querySelectorAll('*');
    
            let count = 0;
    
            
    
            allElements.forEach(element => {
    
                // Skip accessibility controls
    
                if (element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon, .text-alignment-panel, #text-alignment-panel, .alignment-toggle-btn')) {
    
                    return;
    
                }
    
                
    
                // Reset all elements that can contain text
    
                const tagName = element.tagName.toLowerCase();
    
                if (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'span', 'section', 'article', 'main', 'header', 'footer', 'nav', 'li', 'td', 'th', 'blockquote', 'cite', 'address', 'label', 'a'].includes(tagName)) {
    
                    element.style.removeProperty('text-align');
    
                    count++;
    
                }
    
            });
    
            
    
            // Also reset common content classes
    
            const contentSelectors = [
    
                '.container', '.hero', '.hero-content', '.hero-text', 
    
                '.about', '.about-content', '.about-text',
    
                '.services', '.services-grid', '.service-card',
    
                '.contact', '.contact-content', '.contact-info',
    
                '.footer', '.footer-content', '.footer-section',
    
                '.test-section', '.test-block'
    
            ];
    
            
    
            contentSelectors.forEach(selector => {
    
                const elements = document.querySelectorAll(selector);
    
                elements.forEach(element => {
    
                    if (!element.closest('.accessbit-widget-panel, #accessbit-widget-icon, .accessbit-widget-icon, .text-alignment-panel, #text-alignment-panel, .alignment-toggle-btn')) {
    
                        element.style.removeProperty('text-align');
    
                        count++;
    
                    }
    
                });
    
            });

    
        }
    
    
    
        createTextAlignmentControls() {
    
            // Create text alignment controls
    
            const alignmentContainer = document.createElement('div');
    
            alignmentContainer.className = 'alignment-controls';
    
            // Clear container
            while (alignmentContainer.firstChild) {
                alignmentContainer.removeChild(alignmentContainer.firstChild);
            }
            
            const controlGroup = document.createElement('div');
            controlGroup.className = 'control-group';
            
            const h4 = document.createElement('h4');
            h4.textContent = 'Text Alignment';
            controlGroup.appendChild(h4);
            
            const alignmentButtons = document.createElement('div');
            alignmentButtons.className = 'alignment-buttons';
            
            const buttons = [
                { id: 'align-left', title: 'Align Left', icon: '', style: 'text-align: left;' },
                { id: 'align-center', title: 'Align Center', icon: '', style: 'text-align: center;' },
                { id: 'align-right', title: 'Align Right', icon: '', style: 'text-align: right;' },
                { id: 'reset-alignment', title: 'Reset Alignment', icon: '', style: '' }
            ];
            
            buttons.forEach(btnConfig => {
                const button = document.createElement('button');
                button.id = btnConfig.id;
                button.className = 'alignment-btn';
                button.setAttribute('title', btnConfig.title);
                
                const span = document.createElement('span');
                if (btnConfig.style) {
                    span.style.cssText = btnConfig.style;
                }
                span.textContent = btnConfig.icon;
                button.appendChild(span);
                
                alignmentButtons.appendChild(button);
            });
            
            controlGroup.appendChild(alignmentButtons);
            alignmentContainer.appendChild(controlGroup);
    
    
    
            // Add event listeners
    
            const alignLeftBtn = alignmentContainer.querySelector('#align-left');
    
            const alignCenterBtn = alignmentContainer.querySelector('#align-center');
    
            const alignRightBtn = alignmentContainer.querySelector('#align-right');
    
            const resetAlignmentBtn = alignmentContainer.querySelector('#reset-alignment');
    
    
    
            alignLeftBtn.addEventListener('click', () => this.alignTextLeft());
    
            alignCenterBtn.addEventListener('click', () => this.alignTextCenter());
    
            alignRightBtn.addEventListener('click', () => this.alignTextRight());
    
            resetAlignmentBtn.addEventListener('click', () => this.resetTextAlignment());
    
    
    
            return alignmentContainer;
    
        }
    

        fixPanelScrolling() {
            
            
            const panel = this.shadowRoot.querySelector('.accessbit-widget-panel');
            if (panel) {
                // Force native scrolling behavior
                panel.style.overflowY = 'auto';
                panel.style.overflowX = 'hidden';
                panel.style.scrollBehavior = 'smooth';
                panel.style.webkitOverflowScrolling = 'touch';
                panel.style.overscrollBehavior = 'contain';
                
                // Override any GSAP/Lenis interference
                const panelElements = panel.querySelectorAll('*');
                panelElements.forEach(element => {
                    element.style.scrollBehavior = 'auto';
                });
                
                // Additional fixes for specific libraries
                // DON'T set position here - let updateInterfacePosition() handle it
                // panel.style.position = 'fixed'; // REMOVED - interferes with dynamic positioning
                panel.style.zIndex = '2147483646';
                
                // Force scroll events to work
                panel.addEventListener('wheel', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                
                panel.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                
                panel.addEventListener('touchmove', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                
               
            }
            
            // REMOVED: disableSmoothScrollingLibraries() call
            // This was stopping scroll animations on the website when panel opened
            // Only disable smooth scrolling if seizure-safe or stop-animation is active
            if (document.body.classList.contains('seizure-safe') || 
                document.body.classList.contains('stop-animation')) {
                this.disableSmoothScrollingLibraries();
            }
        }
        
        // Disable smooth scrolling libraries that interfere with panel scrolling
        // IMPORTANT: Only disable smooth scrolling, NOT scroll animations
        disableSmoothScrollingLibraries() {
            // Only disable smooth scrolling behavior, not scroll animations
            // This should NOT affect scroll-triggered animations on the website
            
            // Don't pause Lenis or ScrollTrigger - they handle scroll animations
            // Only disable smooth scroll behavior for the panel itself
            // The panel's scroll behavior is already set in fixPanelScrolling()
            
            // REMOVED: Lenis pause - this was stopping scroll animations
            // REMOVED: ScrollTrigger disable - this was stopping scroll animations
            // REMOVED: body/html scroll-behavior change - this was affecting the website
            // REMOVED: scroll-behavior: auto - This was blocking Lenis smooth scrolling
            // Lenis and GSAP ScrollTrigger handle smooth scrolling and should not be blocked
        }
        
        // Re-enable smooth scrolling libraries when panel is closed
        enableSmoothScrollingLibraries() {
            
            
            // Re-enable Lenis if it was paused
            if (window.lenis) {
                try {
                    // Resume instead of recreating
                    if (window.lenis.resume) {
                        window.lenis.resume();
                      
                    }
                } catch (e) {
                   
                }
            }
        }
        
        // Vision impaired functions removed
    
        // Vision impaired functions removed
        
        // Vision impaired functions removed
    
    
    
        // Text Alignment Methods
    
        enableAlignCenter() {
    
  
    
            // Disable other alignment options first
            this.disableAlignLeft();
            this.disableAlignRight();
    
            // Apply center alignment to body first
    
            document.body.style.textAlign = 'center';
    
            
    
            // Then apply to specific content elements, excluding accessibility widget
    
            const contentElements = document.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b, h1, h2, h3, h4, h5, h6, a, button, input, textarea, select, article, section, aside, nav, header, footer');
    
            
    
            contentElements.forEach(element => {
    
                // Skip accessibility widget elements completely
    
                if (element.closest('#accessbit-widget-container') || 
    
                    element.closest('.accessbit-widget-panel') ||
    
                    element.closest('#accessbit-widget-icon') ||
    
                    element.closest('.accessbit-widget-icon') ||
    
                    element.closest('.text-alignment-panel') ||
    
                    element.closest('#text-alignment-panel') ||
    
                    element.id === 'accessbit-widget-container' ||
    
                    element.id === 'accessbit-widget-panel' ||
    
                    element.id === 'accessbit-widget-icon' ||
    
                    element.id === 'text-alignment-panel') {
    
                    return; // Skip this element
    
                }
    
                
    
                element.style.textAlign = 'center';
    
            });
    
        }
    
    
    
        disableAlignCenter() {
    
    
            
    
            // Reset body alignment first
    
            document.body.style.textAlign = '';
    
            
    
            // Then reset specific content elements, excluding accessibility widget
    
            const contentElements = document.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b, h1, h2, h3, h4, h5, h6, a, button, input, textarea, select, article, section, aside, nav, header, footer');
    
            
    
            contentElements.forEach(element => {
    
                // Skip accessibility widget elements completely
    
                if (element.closest('#accessbit-widget-container') || 
    
                    element.closest('.accessbit-widget-panel') ||
    
                    element.closest('#accessbit-widget-icon') ||
    
                    element.closest('.accessbit-widget-icon') ||
    
                    element.closest('.text-alignment-panel') ||
    
                    element.closest('#text-alignment-panel') ||
    
                    element.id === 'accessbit-widget-container' ||
    
                    element.id === 'accessbit-widget-panel' ||
    
                    element.id === 'accessbit-widget-icon' ||
    
                    element.id === 'text-alignment-panel') {
    
                    return; // Skip this element
    
                }
    
                
    
                element.style.textAlign = '';
    
            })
    
        }
    
    
    
        enableAlignLeft() {
    
         
            this.disableAlignCenter();
            this.disableAlignRight();
    
          
            document.body.style.textAlign = 'left';
            
    
            
            const contentElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span:not([class*="icon"]):not([class*="button"]), div:not([class*="icon"]):not([class*="button"]):not([class*="nav"]):not([class*="menu"]), li, td, th, label, small, em, strong, i, b, a, button, input, textarea, select, article, section, aside, nav, header, footer');
            
            let processedCount = 0;
            let skippedCount = 0;
    
            contentElements.forEach(element => {
    
                // Skip accessibility widget elements completely
    
                if (element.closest('#accessbit-widget-container') || 
    
                    element.closest('.accessbit-widget-panel') ||
    
                    element.closest('#accessbit-widget-icon') ||
    
                    element.closest('.accessbit-widget-icon') ||
    
                    element.closest('.text-alignment-panel') ||
    
                    element.closest('#text-alignment-panel') ||
    
                    element.id === 'accessbit-widget-container' ||
    
                    element.id === 'accessbit-widget-panel' ||
    
                    element.id === 'accessbit-widget-icon' ||
    
                    element.id === 'text-alignment-panel') {
    
                    return; // Skip this element
    
                }
    
                
    
             
                element.style.textAlign = 'left';
                processedCount++;
    
            });
            
           
    
         
        }
    
    
    
        disableAlignLeft() {
    
      
            
    
            // Only target main content areas, completely avoid accessibility widget
    
            const mainContent = document.querySelector('main') || document.querySelector('#main') || document.querySelector('.main') || document.querySelector('#content') || document.querySelector('.content');
    
            
    
            if (mainContent) {
    
                // Remove left alignment only from main content area
    
                const contentElements = mainContent.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b, h1, h2, h3, h4, h5, h6, a, button, input, textarea, select, article, section, aside, nav, header, footer');
    
                
    
                contentElements.forEach(element => {
    
                    element.style.textAlign = '';
    
                });
    
            }
    
        
    
        }
    
    
    
        enableAlignRight() {
    
  
    
            // Disable other alignment options first
            this.disableAlignLeft();
            this.disableAlignCenter();
    
            // Apply right alignment only to specific text and icon elements, not the entire body
            const textElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span, a, li, label, small, em, strong, b, td, th, i, svg, [class*="icon"], [data-icon]');
    
            textElements.forEach(element => {
    
                // Skip if element is inside accessibility panel or widget
                if (!element.closest('#accessbit-widget-container') && 
                    !element.closest('.accessbit-widget-panel') && 
                    !element.closest('#accessbit-widget-icon') && 
                    !element.closest('.text-alignment-panel') &&
                    !element.closest('#accessbit-widget') &&
                    !element.closest('[data-ck-widget]') &&
                    element.id !== 'accessbit-widget-icon' && 
                    element.id !== 'accessbit-widget-panel' &&
                    element.id !== 'text-alignment-panel' &&
                    element.id !== 'accessbit-widget') {
    
                    element.style.textAlign = 'right';
    
                }
    
            });
    
      
    
        }
    
    
    
        disableAlignRight() {
    
          
    
            // Remove right alignment from specific text and icon elements only
            const textElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span, a, li, label, small, em, strong, b, td, th, i, svg, [class*="icon"], [data-icon]');
    
            textElements.forEach(element => {
    
                // Skip if element is inside accessibility panel or widget
                if (!element.closest('#accessbit-widget-container') && 
                    !element.closest('.accessbit-widget-panel') && 
                    !element.closest('#accessbit-widget-icon') && 
                    !element.closest('.text-alignment-panel') &&
                    !element.closest('#accessbit-widget') &&
                    !element.closest('[data-ck-widget]') &&
                    element.id !== 'accessbit-widget-icon' && 
                    element.id !== 'accessbit-widget-panel' &&
                    element.id !== 'text-alignment-panel' &&
                    element.id !== 'accessbit-widget') {
    
                    element.style.textAlign = '';
    
                }
    
            });
    
            
    
          
    
        }
    
    
    
        resetTextAlignment() {
    
            
    
            
    
            // Only target main content areas, completely avoid accessibility widget
    
            const mainContent = document.querySelector('main') || document.querySelector('#main') || document.querySelector('.main') || document.querySelector('#content') || document.querySelector('.content');
    
            
    
            if (mainContent) {
    
                // Reset text alignment only from main content area
    
                const contentElements = mainContent.querySelectorAll('p, span, div, li, td, th, label, small, em, strong, i, b, h1, h2, h3, h4, h5, h6, a, button, input, textarea, select, article, section, aside, nav, header, footer');
    
                
    
                contentElements.forEach(element => {
    
                    element.style.textAlign = '';
    
                });
    
            }
    
        }
    
    
    
    
    
    
    
        updateWidgetAppearance() {
    
            // Sync Shadow DOM host with global accessibility features
    
            if (this.shadowRoot && this.shadowRoot.host) {
    
                const container = this.shadowRoot.host;
    
                
    
                // Remove all feature classes first
    
                container.classList.remove(
    
                    'seizure-safe', 'vision-impaired', 'adhd-friendly', 'cognitive-disability',
    
                    'high-contrast', 'monochrome', 'dark-contrast', 'light-contrast',
    
                    'high-saturation', 'low-saturation'
    
                );
    
                
    
                // Add classes based on current settings
    
                Object.entries(this.settings).forEach(([feature, enabled]) => {
    
                    if (enabled) {
    
                        container.classList.add(feature);
    
                    }
    
                });
    
                
    
            }
    
        }
    
    
    
        // Screen Reader Support Methods
    
        announceToScreenReader(message) {
    
            if (this.shadowRoot) {
    
                const srAnnouncements = this.shadowRoot.getElementById('sr-announcements');
    
                if (srAnnouncements) {
    
                    srAnnouncements.textContent = message;

                    
    
                    // Clear the announcement after a short delay
    
                    setTimeout(() => {
    
                        srAnnouncements.textContent = '';
    
                    }, 1000);
    
                }
    
            }
    
        }
    
    
    
        addToggleAccessibility(toggle) {
    
            const featureId = toggle.id;
    
            const profileItem = toggle.closest('.profile-item');
    
            
    
            if (profileItem) {
    
                const titleElement = profileItem.querySelector('h4');
    
                const descElement = profileItem.querySelector('p');
    
                
    
                if (titleElement && descElement) {
    
                    const title = titleElement.textContent;
    
                    const description = descElement.textContent;
    
                    
    
                    // Add ID to description if it doesn't have one
    
                    if (!descElement.id) {
    
                        descElement.id = `${featureId}-desc`;
    
                    }
    
                    
    
                    // Set ARIA attributes
    
                    toggle.setAttribute('aria-label', `${title} - ${description}`);
    
                    toggle.setAttribute('aria-describedby', descElement.id);
    
                    toggle.setAttribute('role', 'switch');
    
                    
    
                }
    
            }
    
        }
    
    
    
        // Update toggle switch in panel to sync with keyboard shortcuts
    
        updateToggleSwitch(featureId, enabled) {
    
            if (this.shadowRoot) {
    
                const toggle = this.shadowRoot.getElementById(featureId);
    
                if (toggle) {
    
                    toggle.checked = enabled;
    
                    
    
                } else {
    
                   
    
                }
    
            }
    
        }
    
    
    
        // Update all toggle switches to reflect current settings
    
        updateAllToggleSwitches() {
    
            if (this.shadowRoot) {
    
                const allToggles = this.shadowRoot.querySelectorAll('.toggle-switch input');
    
                allToggles.forEach(toggle => {
    
                    const featureId = toggle.id;
    
                    if (featureId && this.settings.hasOwnProperty(featureId)) {
    
                        toggle.checked = this.settings[featureId];
    
                   
    
                    }
    
                });
    
            }
    
        }
    
    
    
        // Enhanced Keyboard Navigation Methods
    
        ensureFocusInPanel() {
    
            if (this.shadowRoot && this.isPanelOpen) {
    
                const panel = this.shadowRoot.getElementById('accessbit-widget-panel');
    
                if (panel && panel.classList.contains('active')) {
    
                    const focusableElements = panel.querySelectorAll(
    
                        'button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
    
                    );
    
                    
    
                    if (focusableElements.length > 0) {
    
                        const activeElement = this.shadowRoot.activeElement;
    
                        if (!activeElement || !panel.contains(activeElement)) {
    
                            focusableElements[0].focus();
    
                        }
    
                    }
    
                }
    
            }
    
        }
    
    
    
        // Enhanced Panel Toggle with Screen Reader Support
    
        togglePanel() {
            console.log('[PANEL TOGGLE] togglePanel() called');
            // PERFORMANCE OPTIMIZATION: Use cached elements, but force refresh to ensure we have current elements
            const elements = this.getCachedElements(true); // Force refresh to get current elements
            const panel = elements.panel || this.shadowRoot?.getElementById('accessbit-widget-panel');
            const icon = elements.icon || this.shadowRoot?.getElementById('accessbit-widget-icon');
    
            console.log('[PANEL TOGGLE] Elements found:', {
                hasPanel: !!panel,
                hasIcon: !!icon,
                panel: panel,
                icon: icon
            });
    
            if (!panel || !icon) {
                console.warn('[PANEL TOGGLE] Panel or icon not found', { panel: !!panel, icon: !!icon });
                return;
            }
            
            // PERFORMANCE OPTIMIZATION: Use CSS transforms instead of display toggling
            const isCurrentlyOpen = panel.classList.contains('active');
            const currentTransform = panel.style.transform || '';
            const isHidden = currentTransform.includes('translateX(-100%)') || 
                           panel.style.visibility === 'hidden' ||
                           panel.style.display === 'none';
            
            // Execute panel toggle - use requestAnimationFrame if available, otherwise execute immediately
            const executePanelToggle = () => {
                if (isCurrentlyOpen || !isHidden) {
                    // Hide panel using transform (better performance than display)
                    panel.style.transform = 'translateX(-100%)';
                    panel.style.visibility = 'hidden';
                    panel.style.pointerEvents = 'none';
                    panel.classList.remove('active');
                    
                    // CRITICAL: Ensure icon stays visible when panel closes
                    if (icon) {
                        icon.style.display = '';
                        icon.style.visibility = 'visible';
                        icon.style.opacity = '1';
                    }
                    panel.setAttribute('aria-hidden', 'true');
                    icon.setAttribute('aria-expanded', 'false');
                    this.isPanelOpen = false;
                    
                    // Re-enable smooth scrolling libraries when panel is closed
                    this.enableSmoothScrollingLibraries();
                } else {
                    // Show panel
                    this.ensureWidgetCSS(); // Ensure CSS is always present
                    this.ensureBasePanelCSS(); // Ensure base CSS is applied
                    
                    // Make panel visible first (needed for accurate positioning)
                    panel.style.transform = '';
                    panel.style.visibility = 'visible';
                    panel.style.pointerEvents = 'auto';
                    panel.style.display = 'block'; // Keep for compatibility
                    panel.classList.add('active');
                    
                    // Position panel above icon AFTER making it visible
                    // Use multiple requestAnimationFrame calls to ensure dimensions are calculated
                    const positionPanel = () => {
                        this.updateInterfacePosition(); // Position panel above icon
                        // Verify position after a short delay
                        setTimeout(() => {
                            if (this.isPanelOpen) {
                                this.updateInterfacePosition(); // Re-position to ensure accuracy
                            }
                        }, 100);
                    };
                    
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            positionPanel();
                        });
                    });
                    
                    panel.setAttribute('aria-hidden', 'false');
                    icon.setAttribute('aria-expanded', 'true');
                    this.isPanelOpen = true;
                    
                    // Fix scrolling conflicts with GSAP/Lenis libraries
                    // Only fix panel scrolling - don't affect website scroll animations
                    const fixScrolling = () => {
                        // Only fix panel scrolling, not website animations
                        const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
                        if (panel) {
                            // Force native scrolling behavior for panel only
                            panel.style.overflowY = 'auto';
                            panel.style.overflowX = 'hidden';
                            panel.style.scrollBehavior = 'smooth';
                            panel.style.webkitOverflowScrolling = 'touch';
                            panel.style.overscrollBehavior = 'contain';
                            
                            // Prevent panel scroll events from bubbling to website
                            panel.addEventListener('wheel', (e) => {
                                e.stopPropagation();
                            }, { passive: false, once: false });
                            
                            panel.addEventListener('touchstart', (e) => {
                                e.stopPropagation();
                            }, { passive: false, once: false });
                            
                            panel.addEventListener('touchmove', (e) => {
                                e.stopPropagation();
                            }, { passive: false, once: false });
                        }
                        // DO NOT call disableSmoothScrollingLibraries() - it was stopping website scroll animations
                    };
                    const rafId1 = requestAnimationFrame(fixScrolling);
                    // Fallback if requestAnimationFrame is blocked (seizure-safe mode)
                    if (rafId1 === 0) {
                        setTimeout(fixScrolling, 0);
                    }
                    
                    // Focus first focusable element in panel
                    const focusPanel = () => {
                        this.ensureFocusInPanel();
                    };
                    const rafId2 = requestAnimationFrame(focusPanel);
                    // Fallback if requestAnimationFrame is blocked (seizure-safe mode)
                    if (rafId2 === 0) {
                        setTimeout(focusPanel, 0);
                    }
                    
                    this.announceToScreenReader('Accessibility panel opened. Use Tab to navigate, Enter or Space to toggle features, and Escape to close.');
                }
            };
            
            // Try requestAnimationFrame, but execute immediately if it's blocked (seizure-safe mode)
            const rafId = requestAnimationFrame(executePanelToggle);
            if (rafId === 0) {
                // requestAnimationFrame is blocked (seizure-safe mode), execute immediately
                executePanelToggle();
            }
        }
    
        // Check if domain is staging (free, no payment needed)
        isStagingDomain() {
            if (this._isStagingDomain !== null) {
                return this._isStagingDomain; // Return cached result
            }
            
            const host = window.location.hostname || '';
            this._isStagingDomain = host.endsWith('.webflow.io') || 
                                   host.endsWith('.webflow.com') || 
                                   host.includes('localhost') ||
                                   host.includes('127.0.0.1') ||
                                   host.includes('staging');
            
            return this._isStagingDomain;
        }
        
        // Check payment status - NO CACHING for custom domains (real-time check)
        // Staging domains: Always return true (free, no API call)
        // Custom domains: Always check payment status fresh (no cache, real-time)
        async checkPaymentStatusRealTime() {
            console.log('[PAYMENT] checkPaymentStatusRealTime() called');
            // Staging domains are free - no payment check needed
            const isStaging = this.isStagingDomain();
            console.log('[PAYMENT] Domain check:', {
                isStaging,
                hostname: window.location.hostname
            });
            
            if (isStaging) {
                console.log('[PAYMENT] Staging domain detected, returning true (free)');
                return true; // Fast return, no API call
            }
            
            // Custom domains: Always check payment status fresh (no cache)
            // This ensures we detect real-time payment changes (payments/cancellations)
            console.log('[PAYMENT] Custom domain detected, checking payment status...');
            const result = await this.checkPaymentStatus();
            console.log('[PAYMENT] Payment status result:', result);
            return result;
        }
        
        // Fetch customization data from the API - OPTIMIZED for speed
        async fetchCustomizationData() {
            console.log('[FETCH] fetchCustomizationData() called');
            
            // Request deduplication: If a request is already in progress, return the same promise
            if (this._fetchCustomizationPromise) {
                console.log('[FETCH] Request already in progress, reusing promise');
                return this._fetchCustomizationPromise;
            }
            
            // Check cache first (5 minute cache as per worker headers)
            // Cache is invalidated if publishedAt changes (new customization published)
            const cacheKey = `customization_cache_${this.siteId || 'unknown'}`;
            const cached = sessionStorage.getItem(cacheKey);
            let cachedPublishedAt = null;
            let cachedDataObj = null;
            
            if (cached) {
                try {
                    cachedDataObj = JSON.parse(cached);
                    const cacheTime = cachedDataObj.timestamp || 0;
                    const cacheAge = Date.now() - cacheTime;
                    const cacheTTL = 5 * 60 * 1000; // 5 minutes
                    cachedPublishedAt = cachedDataObj.data?.publishedAt || cachedDataObj.publishedAt;
                    
                    if (cacheAge < cacheTTL) {
                        // Cache is fresh, but we'll still fetch to check if publishedAt changed
                        // This ensures new customizations are immediately detected
                        console.log('[FETCH] Cache found, will verify publishedAt on fetch:', { 
                            cacheAge, 
                            cacheTTL,
                            cachedPublishedAt 
                        });
                    } else {
                        sessionStorage.removeItem(cacheKey);
                        cachedPublishedAt = null;
                        cachedDataObj = null;
                    }
                } catch (e) {
                    sessionStorage.removeItem(cacheKey);
                    cachedPublishedAt = null;
                    cachedDataObj = null;
                }
            }
            
            // Create the fetch promise and store it for deduplication
            this._fetchCustomizationPromise = (async () => {
                try {
                    // OPTIMIZATION: Run payment check and siteId fetch in PARALLEL
                    // This reduces total wait time significantly
                    console.log('[FETCH] Starting parallel payment check and siteId fetch...');
                    const [paymentValid, siteId] = await Promise.all([
                        this.checkPaymentStatusRealTime(),
                        this.getSiteId()
                    ]);
                    
                    console.log('[FETCH] Payment and siteId results:', {
                        paymentValid,
                        siteId,
                        paymentType: typeof paymentValid
                    });
                    
                    // Only disable widget if payment is definitively invalid (false)
                    // Don't disable on check failures (null) - preserve current state
                    if (paymentValid === false) {
                        console.warn('[FETCH] Payment invalid, disabling widget');
                        this.disableWidget();
                        return null;
                    }
                    // If paymentValid is null (check failed), don't disable widget
                    // Continue loading customization even if payment check failed
                    
                    // Fast fail if no siteId
                    if (!siteId) {
                        console.warn('[FETCH] No siteId found, returning null');
                        return null;
                    }
                    
                    // Cache siteId for future use
                    this.siteId = siteId;
                    console.log('[FETCH] SiteId cached:', siteId);
                    
                    if (!this.kvApiUrl) {
                        console.warn('[FETCH] No kvApiUrl configured, returning null');
                        return null;
                    }
                    
                    // OPTIMIZATION: Remove cache buster to allow browser caching
                    // The worker already sets Cache-Control headers for 5 minutes
                    const baseCfg = (this && this.kvApiUrl ? this.kvApiUrl : 'https://accessbit-test-worker.web-8fb.workers.dev').replace(/\/+$/,'');
                    const apiUrl = `${baseCfg}/api/accessibility/config?siteId=${siteId}`;
                
                console.log('[FETCH] Making API request:', {
                    apiUrl,
                    baseCfg,
                    kvApiUrl: this.kvApiUrl
                });
                
                // Use isolatedFetch for API isolation (handles retries, timeouts, rate limiting automatically)
                const response = await this.isolatedFetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    },
                    keepalive: false
                }, 10000, 3); // 10s timeout, 3 retries
                
                if (response && response.ok) {
                    console.log('[FETCH] API response received:', {
                        ok: response.ok,
                        status: response.status,
                        statusText: response.statusText
                    });
                    
                    // Parse response data
                    let data = null;
                    try {
                        data = await response.json();
                    } catch (parseError) {
                        console.error('[CUSTOMIZATION FETCH] Failed to parse JSON response:', parseError);
                        return null;
                    }
                    
                    // Cache the successful response
                    // Check if publishedAt changed - if so, use new data (new customization published)
                    if (data && siteId) {
                        try {
                            const newPublishedAt = data.publishedAt;
                            
                            // If publishedAt changed, this means new customization was published
                            // Always use the new data and update cache
                            if (cachedPublishedAt && newPublishedAt && cachedPublishedAt !== newPublishedAt) {
                                console.log('[FETCH] publishedAt changed - new customization detected:', {
                                    old: cachedPublishedAt,
                                    new: newPublishedAt
                                });
                            } else if (cachedPublishedAt === newPublishedAt) {
                                console.log('[FETCH] publishedAt unchanged, using fresh data from API:', {
                                    publishedAt: newPublishedAt
                                });
                            }
                            
                            // Always update cache with latest data
                            sessionStorage.setItem(`customization_cache_${siteId}`, JSON.stringify({
                                data: data,
                                timestamp: Date.now(),
                                publishedAt: data.publishedAt
                            }));
                            console.log('[FETCH] Updated cache with latest customization data:', { publishedAt: data.publishedAt });
                        } catch (e) {
                            // Ignore storage errors (quota exceeded, etc.)
                        }
                    }

                    return data;
                } else {
                    // Response was null or not ok - isolatedFetch already handled retries
                    if (response) {
                        const errorText = await response.text().catch(() => 'Unable to read error response');
                        console.error('[CUSTOMIZATION FETCH] API error:', {
                            status: response.status,
                            statusText: response.statusText,
                            url: apiUrl,
                            errorBody: errorText
                        });
                    }
                    return null;
                }
            } catch (error) {
                    // Log error for debugging
                    console.error('[CUSTOMIZATION FETCH] Fetch failed:', {
                        message: error.message,
                        stack: error.stack,
                        name: error.name
                    });
                    return null;
                } finally {
                    // Clear the promise so future calls can make new requests
                    this._fetchCustomizationPromise = null;
                }
            })();
            
            return this._fetchCustomizationPromise;
        }
    
    
        setupPaymentStatusRefresh() {
            // Only set up refresh for custom domains (staging is always free)
            if (this.isStagingDomain()) {
                return; // No refresh needed for staging
            }
            
            // Custom domains: Refresh payment status every 2 minutes (120000ms)
            // This catches real-time payment changes (payments/cancellations)
            setInterval(async () => {
                try {
                    // Always check fresh payment status (no cache)
                    const isValid = await this.checkPaymentStatusRealTime();
                    
                    // Only hide widget if payment is definitively invalid
                    // Don't hide on check failures (network errors, etc.) - preserve current state
                    if (isValid === false && this.paymentFailed === false) {
                        // Payment status changed from valid to invalid - disable widget
                        this.disableWidget();
                    } else if (isValid === true && this.paymentFailed === true) {
                        // Payment status changed from invalid to valid - re-enable widget
                        this.paymentFailed = false;
                        // Re-initialize widget if it was disabled
                        const widgetContainer = document.getElementById('accessbit-widget-container');
                        if (widgetContainer) {
                            widgetContainer.style.display = '';
                            widgetContainer.style.visibility = '';
                            widgetContainer.style.opacity = '';
                        }
                        // Show icon if it exists
                        const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
                        if (icon) {
                            this.showIcon();
                        }
                    }
                    // If isValid is null/undefined (check failed), don't change widget state
                    // This prevents hiding widget on temporary network errors
                } catch (error) {
                    // Silently handle errors - don't change widget state on check failures
                    // This prevents widget from disappearing on temporary network issues
                }
            }, 120000); // Every 2 minutes for custom domains
        }
    
       async getSiteId() {
    console.log('[GET_SITE_ID] getSiteId() called');
    
    // 1. Return cached siteId if available
    if (this.siteId) {
        return this.siteId;
    }

    try {
        // 2. Try currentScript first, then fallback to the verified search term
        const scriptEl = document.currentScript || 
                         Array.from(document.getElementsByTagName('script')).find(s => s.src.includes('AccessBit')) ||
                         document.querySelector('script[src*="new.js"]')||
                         document.querySelector('script[src*="widget.js"]');

        if (scriptEl && scriptEl.src) {
            // Use the URL constructor to handle parsing &amp; and other encoding issues
            const u = new URL(scriptEl.src);
            const sid = u.searchParams.get('siteId');

            if (sid) {
                this.siteId = sid; // Cache it
                console.log('[GET_SITE_ID] Found and cached siteId:', sid);
                return sid;
            }
        }
    } catch (error) {
        console.error('[GET_SITE_ID] Error parsing script URL:', error);
    }

    console.warn('[GET_SITE_ID] siteId not found');
    return null;
}
    
    applyCustomizations(customizationData) {
        
        if (!customizationData) {

            return;
        }
        
        // Store customization data for later use (e.g., statement link)
        this.customizationData = customizationData;
     
        
        try {
            // Apply trigger button customizations
            if (customizationData.triggerButtonColor) {
           
                this.updateTriggerButtonColor(customizationData.triggerButtonColor);
            }
            
            if (customizationData.triggerButtonShape) {
              
                this.updateTriggerButtonShape(customizationData.triggerButtonShape);
            
            }
            
            if (customizationData.triggerButtonSize) {
             
                this.updateTriggerButtonSize(customizationData.triggerButtonSize);
            }
            
            if (customizationData.triggerHorizontalPosition) {

                this.updateTriggerPosition('horizontal', customizationData.triggerHorizontalPosition);
            }
            
            if (customizationData.triggerVerticalPosition) {

                this.updateTriggerPosition('vertical', customizationData.triggerVerticalPosition);
            }
            
            if (customizationData.triggerHorizontalOffset) {
               
                this.updateTriggerOffset('horizontal', customizationData.triggerHorizontalOffset);
            }
            
            if (customizationData.triggerVerticalOffset) {

                this.updateTriggerOffset('vertical', customizationData.triggerVerticalOffset);
            }
            
            // Don't call updateTriggerVisibility here - icon visibility is handled explicitly
            // in init() after customizations are applied to avoid conflicts
            
            // Apply language - preserve user's language choice
            const savedLanguage = localStorage.getItem('accessbit-widget-language');
            
            // Only apply language from customization if:
            // 1. There's a saved language AND it's different from customization (user changed it in app)
            // 2. OR there's no saved language AND customization has a non-default language
            if (customizationData.interfaceLanguage && 
                customizationData.interfaceLanguage !== 'English' && 
                customizationData.interfaceLanguage !== savedLanguage) {
        
                this.applyLanguage(customizationData.interfaceLanguage);
                this.updateInterfacePosition();
            } else if (!savedLanguage && customizationData.interfaceLanguage && customizationData.interfaceLanguage !== 'English') {

                this.applyLanguage(customizationData.interfaceLanguage);
                this.updateInterfacePosition();
            } else if (!savedLanguage && (!customizationData.interfaceLanguage || customizationData.interfaceLanguage === 'English')) {
                
                this.applyLanguage('English');
                this.updateInterfacePosition();
            } else {
              
                // Keep the current language, just update interface position
                this.updateInterfacePosition();
            }
            
            // Apply icon customizations
            // Support both selectedIcon and triggerIcon field names (for backward compatibility)
            const iconValue = customizationData.selectedIcon || customizationData.triggerIcon;
            if (iconValue) {
                console.log('[CUSTOMIZATION] Applying icon from customization data:', {
                    selectedIcon: customizationData.selectedIcon,
                    triggerIcon: customizationData.triggerIcon,
                    iconValue: iconValue,
                    allCustomizationKeys: Object.keys(customizationData)
                });
                this.updateSelectedIcon(iconValue);
            } else {
                console.warn('[CUSTOMIZATION] No icon found in customization data. Available keys:', Object.keys(customizationData));
            }
            
            // Support both selectedIconName and triggerIconName field names
            const iconName = customizationData.selectedIconName || customizationData.triggerIconName;
            if (iconName) {
                this.updateSelectedIconName(iconName);
            }
            
            // Apply mobile customizations
            if (customizationData.showOnMobile) {
                
                this.updateMobileVisibility(customizationData.showOnMobile === 'Show');
            }
            
            // Handle combined positioning for mobile trigger
            if (customizationData.mobileTriggerHorizontalPosition && customizationData.mobileTriggerVerticalPosition) {
               
                this.updateMobileTriggerCombinedPosition(customizationData.mobileTriggerHorizontalPosition, customizationData.mobileTriggerVerticalPosition);
            } else {
                // Handle individual positioning
                if (customizationData.mobileTriggerHorizontalPosition) {
                  
                    this.updateMobileTriggerPosition('horizontal', customizationData.mobileTriggerHorizontalPosition);
                }
                
                if (customizationData.mobileTriggerVerticalPosition) {

                    this.updateMobileTriggerPosition('vertical', customizationData.mobileTriggerVerticalPosition);
                }
            }
            
            if (customizationData.mobileTriggerSize) {
              
                this.updateMobileTriggerSize(customizationData.mobileTriggerSize);
            }
            
            if (customizationData.mobileTriggerShape) {
               
                this.updateMobileTriggerShape(customizationData.mobileTriggerShape);
                
                // Final verification for mobile shape
                if (window.innerWidth <= 768) {
                    setTimeout(() => {
                        const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
                        if (icon) {
                            const computedBorderRadius = window.getComputedStyle(icon).borderRadius;
                            
                        }
                    }, 200);
                }
            }
            
            // Store mobile offsets to be applied after positioning
            if (customizationData.mobileTriggerHorizontalOffset) {

                this.mobileHorizontalOffset = customizationData.mobileTriggerHorizontalOffset;
            }
            
            if (customizationData.mobileTriggerVerticalOffset) {
                
                this.mobileVerticalOffset = customizationData.mobileTriggerVerticalOffset;
            }
            
         
            
            // Apply mobile offsets after all positioning has been applied
            if (this.mobileHorizontalOffset !== undefined) {
                
                this.updateMobileTriggerOffset('horizontal', this.mobileHorizontalOffset);
            }
            
            if (this.mobileVerticalOffset !== undefined) {
               
                this.updateMobileTriggerOffset('vertical', this.mobileVerticalOffset);
            }
            
        } catch (error) {
           
        }
    }
    
        // Show the icon after customizations are loaded
        showIcon() {
            console.log('[ICON DEBUG] showIcon() called', {
                _iconExplicitlyShown: this._iconExplicitlyShown,
                paymentFailed: this.paymentFailed,
                customizationData: this.customizationData ? 'exists' : 'null'
            });
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (!icon) {
                console.log('[ICON DEBUG] showIcon() - Icon element not found');
                return;
            }
            
            // If icon was explicitly shown during initialization, don't hide it
            // This prevents ResizeObserver and other events from hiding the icon
            // after it was correctly shown with the right visibility logic
            if (this._iconExplicitlyShown) {
                // Only update visibility if settings actually changed (e.g., window resize changed mobile state)
                const isMobile = window.innerWidth <= 768;
                const hideTrigger = this.customizationData?.hideTriggerButton === 'Yes';
                const mobileVisibility = this.customizationData?.showOnMobile;
                
                // Only hide if visibility rules actually require it
                if (!isMobile && hideTrigger) {
                    // Desktop and hideTrigger is Yes - hide it
                    console.log('[ICON HIDE] showIcon() - _iconExplicitlyShown=true, Desktop, hideTriggerButton=Yes');
                    icon.style.display = 'none';
                    icon.style.visibility = 'hidden';
                    icon.style.opacity = '0';
                    return;
                } else if (isMobile && mobileVisibility === 'Hide') {
                    // Mobile and showOnMobile is Hide - hide it
                    console.log('[ICON HIDE] showIcon() - _iconExplicitlyShown=true, Mobile, showOnMobile=Hide');
                    icon.style.display = 'none';
                    icon.style.visibility = 'hidden';
                    icon.style.opacity = '0';
                    return;
                } else {
                    // Show it - visibility rules allow it
                    icon.style.display = '';
                    icon.style.visibility = 'visible';
                    icon.style.opacity = '1';
                    return;
                }
            }
            
            // Check if payment failed - if so, don't show icon
            if (this.paymentFailed) {
                console.log('[ICON HIDE] showIcon() - Payment failed (this.paymentFailed=true)');
                icon.style.display = 'none';
                icon.style.visibility = 'hidden';
                icon.style.opacity = '0';
                return;
            }
            
            // Additional check: if widget container is hidden due to payment issues, don't show icon
            const widgetContainer = document.getElementById('accessbit-widget-container');
            if (widgetContainer && (widgetContainer.style.display === 'none' || 
                widgetContainer.style.visibility === 'hidden' || 
                widgetContainer.style.opacity === '0')) {
                console.log('[ICON HIDE] showIcon() - Widget container is hidden (payment issues)');
                icon.style.display = 'none';
                icon.style.visibility = 'hidden';
                icon.style.opacity = '0';
                return;
            }
            
            // Check device type
            const isMobile = window.innerWidth <= 768;
            const hideTrigger = this.customizationData?.hideTriggerButton === 'Yes';
            const mobileVisibility = this.customizationData?.showOnMobile; // 'Show' | 'Hide' | undefined
    
           
    
            // Desktop/Tablet logic: hide if hideTriggerButton is Yes
            if (!isMobile && hideTrigger) {
                console.log('[ICON HIDE] showIcon() - Desktop, hideTriggerButton=Yes');
                icon.style.display = 'none';
                icon.style.visibility = 'hidden';
                icon.style.opacity = '0';
                return;
            }
    
            // Mobile logic: hide if showOnMobile is Hide (ignore hideTriggerButton for mobile)
            if (isMobile && mobileVisibility === 'Hide') {
                console.log('[ICON HIDE] showIcon() - Mobile, showOnMobile=Hide');
                icon.style.display = 'none';
                icon.style.visibility = 'hidden';
                icon.style.opacity = '0';
                return;
            }
            
            // Mobile logic: show if showOnMobile is Show (ignore hideTriggerButton for mobile)
            if (isMobile && mobileVisibility === 'Show') {
                
                icon.style.display = 'flex';
                icon.style.visibility = 'visible';
                icon.style.opacity = '1';
                icon.style.transition = 'opacity 0.3s ease';
                return;
            }
    
            // Desktop/Tablet default: show only if hideTriggerButton is NOT 'Yes'
            if (!isMobile && !hideTrigger) {
                console.log('[ICON SHOW] showIcon() - Desktop default, hideTriggerButton is not Yes');
                icon.style.display = 'flex';
                icon.style.visibility = 'visible';
                icon.style.opacity = '1';
                icon.style.transition = 'opacity 0.3s ease';
                return;
            }
            
            // If we reach here, icon should be hidden (desktop with hideTriggerButton=Yes, or mobile with showOnMobile=Hide or undefined)
            console.log('[ICON HIDE] showIcon() - Default hide case', {
                isMobile,
                hideTrigger,
                mobileVisibility
            });
            icon.style.display = 'none';
            icon.style.visibility = 'hidden';
            icon.style.opacity = '0';
           
                icon.style.display = 'flex';
                icon.style.visibility = 'visible';
                icon.style.opacity = '1';
                icon.style.transition = 'opacity 0.3s ease';
            
            // Apply mobile positioning if on mobile and we have mobile position data
            if (isMobile && this.customizationData?.mobileTriggerHorizontalPosition && this.customizationData?.mobileTriggerVerticalPosition) {
                
                this.updateMobileTriggerCombinedPosition(
                    this.customizationData.mobileTriggerHorizontalPosition, 
                    this.customizationData.mobileTriggerVerticalPosition
                );
            }
        }
        
        // Handle window resize to update icon visibility based on device type
        handleWindowResize() {
            console.log('[ICON DEBUG] handleWindowResize() called', {
                _iconExplicitlyShown: this._iconExplicitlyShown,
                hasCustomizationData: !!this.customizationData
            });
            // Don't call showIcon() if icon was explicitly shown during initialization
            // This prevents ResizeObserver from hiding the icon immediately after it's shown
            if (this._iconExplicitlyShown) {
                console.log('[ICON DEBUG] handleWindowResize() - Skipping because _iconExplicitlyShown=true');
                return; // Icon visibility is already correctly set, don't change it
            }
            
            // Only update icon visibility if customization data is available
            if (!this.customizationData) {
                console.log('[ICON DEBUG] handleWindowResize() - Skipping because no customizationData');
                return; // Don't call showIcon() if customization data isn't loaded yet
            }
            this.showIcon();
        }
        
        // PERFORMANCE OPTIMIZATION: Get cached DOM elements with refresh capability
        getCachedElements(forceRefresh = false) {
            const now = Date.now();
            // Refresh cache every 5 seconds or if forced
            if (forceRefresh || now - this._cachedElements.lastCacheTime > 5000) {
                this._cachedElements.icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
                this._cachedElements.panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
                this._cachedElements.closeBtn = this.shadowRoot?.getElementById('close-panel');
                this._cachedElements.lastCacheTime = now;
            }
            return this._cachedElements;
        }
        
        // PERFORMANCE OPTIMIZATION: Debounce utility
        debounce(func, wait) {
            return (...args) => {
                clearTimeout(this._resizeTimer);
                this._resizeTimer = setTimeout(() => func.apply(this, args), wait);
            };
        }
        
        // PERFORMANCE OPTIMIZATION: Throttle utility using requestAnimationFrame
        throttle(func) {
            return (...args) => {
                if (!this._rafPending) {
                    this._rafPending = true;
                    requestAnimationFrame(() => {
                        func.apply(this, args);
                        this._rafPending = false;
                    });
                }
            };
        }
        
        // PERFORMANCE OPTIMIZATION: Combined, debounced resize handler
        setupOptimizedResizeHandlers() {
            // Debounced resize handler (150ms delay)
            const debouncedResize = this.debounce(() => {
                this.handleResizeOptimized();
            }, 150);
            
            // Single resize listener
            window.addEventListener('resize', debouncedResize, { passive: true });
            
            // Use ResizeObserver for better responsive mode detection
            // Only set up ResizeObserver after icon visibility has been determined
            if (this.shadowRoot && window.ResizeObserver) {
                // Delay ResizeObserver setup to ensure icon visibility is determined first
                const self = this;
                const debouncedResizeFn = debouncedResize;
                setTimeout(function() {
                    const resizeObserver = new ResizeObserver(function() {
                        console.log('[ICON DEBUG] ResizeObserver callback fired', {
                            _iconExplicitlyShown: self._iconExplicitlyShown
                        });
                        // Don't trigger resize handler if icon was explicitly shown during initialization
                        if (self._iconExplicitlyShown === true) {
                            console.log('[ICON DEBUG] ResizeObserver - Skipping because _iconExplicitlyShown=true');
                            return;
                        }
                        // Safe to call resize handler
                        debouncedResizeFn();
                    });
                    
                    const panel = self.shadowRoot.getElementById('accessbit-widget-panel');
                    const icon = self.shadowRoot.getElementById('accessbit-widget-icon');
                    if (panel) resizeObserver.observe(panel);
                    if (icon) resizeObserver.observe(icon);
                    
                    self._resizeObserver = resizeObserver;
                }, 200);
            }
            
            // Listen to media query changes for breakpoints
            if (window.matchMedia) {
                const mobileQuery = window.matchMedia('(max-width: 768px)');
                const handleMediaChange = (e) => {
                    this.handleResizeOptimized();
                };
                
                // Modern browsers
                if (mobileQuery.addEventListener) {
                    mobileQuery.addEventListener('change', handleMediaChange);
                } else {
                    // Legacy browsers
                    mobileQuery.addListener(handleMediaChange);
                }
                
                // Device pixel ratio changes
                const pixelRatioQuery = window.matchMedia('(min-resolution: 1.5dppx)');
                const handlePixelRatioChange = () => {
                    this.handleResizeOptimized();
                };
                
                if (pixelRatioQuery.addEventListener) {
                    pixelRatioQuery.addEventListener('change', handlePixelRatioChange);
                } else {
                    pixelRatioQuery.addListener(handlePixelRatioChange);
                }
            }
        }
        
        // PERFORMANCE OPTIMIZATION: Optimized resize handler
        // NOTE: Responsive sizing is now handled 100% by CSS media queries
        // This function only handles customization-specific styles (color, shape, position)
        handleResizeOptimized() {
            console.log('[ICON DEBUG] handleResizeOptimized() called');
            const elements = this.getCachedElements();
            const icon = elements.icon;
            const panel = elements.panel;
            
            if (!icon || !panel) {
                console.log('[ICON DEBUG] handleResizeOptimized() - Icon or panel not found');
                return;
            }
            
            // Use requestAnimationFrame for DOM updates
            requestAnimationFrame(() => {
                const screenWidth = window.innerWidth;
                const isMobile = screenWidth <= 768;
                
                // Update icon visibility (handles show/hide based on customization settings)
                this.handleWindowResize();
                
                // Ensure base CSS is applied (position, z-index, etc. - NOT sizing)
                this.ensureBasePanelCSS();
                
                // CSS media queries handle all responsive sizing automatically
                // We only need to toggle mobile-mode class for CSS targeting
                const needsClassUpdate = (isMobile && !panel.classList.contains('mobile-mode')) ||
                                       (!isMobile && panel.classList.contains('mobile-mode'));
                
                // If panel is open, update its position relative to icon
                if (this.isPanelOpen && panel.classList.contains('active')) {
                    this.updateInterfacePosition();
                }
                
                if (needsClassUpdate) {
                    if (isMobile) {
                        // Add mobile-mode class - CSS handles all sizing
                        panel.classList.add('mobile-mode');
                        
                        // Only reapply customization-specific styles (color, shape, position)
                        if (this.customizationData) {
                            // Reapply mobile positioning if it was set
                            if (this.customizationData.mobileTriggerHorizontalPosition && 
                                this.customizationData.mobileTriggerVerticalPosition) {
                                this.updateMobileTriggerCombinedPosition(
                                    this.customizationData.mobileTriggerHorizontalPosition, 
                                    this.customizationData.mobileTriggerVerticalPosition
                                );
                            }
                            
                            // Reapply mobile customizations (shape, color) - NOT size (CSS handles that)
                            if (this.customizationData.mobileTriggerShape) {
                                this.updateMobileTriggerShape(this.customizationData.mobileTriggerShape);
                            } else if (this.customizationData.triggerButtonShape) {
                                this.updateTriggerButtonShape(this.customizationData.triggerButtonShape);
                            }
                            
                            if (this.customizationData.triggerButtonColor) {
                                this.updateTriggerButtonColor(this.customizationData.triggerButtonColor);
                            }
                        }
                    } else {
                        // Remove mobile-mode class - CSS handles all sizing
                        panel.classList.remove('mobile-mode');
                        
                        // Reapply desktop customizations (color, shape, position, offset)
                        if (this.customizationData) {
                            this.reapplyDesktopIconCustomizations();
                            this.updateInterfacePosition();
                        }
                    }
                }
                
                // Update panel position relative to icon on resize (important for tablets and mobile)
                if (panel.classList.contains('active')) {
                    // Reposition panel to stay on same side as icon
                    requestAnimationFrame(() => {
                        this.updateInterfacePosition();
                    });
                }
            });
        }
        
        // PERFORMANCE OPTIMIZATION: Throttled MutationObserver
        setupThrottledMutationObserver() {
            if (!this.shadowRoot) return;
            
            // Throttled callback using requestAnimationFrame
            const throttledCallback = this.throttle(() => {
                const panel = this._cachedElements.panel || this.shadowRoot.getElementById('accessbit-widget-panel');
                if (panel) {
                    this.ensureBasePanelCSS();
                }
            });
            
            const observer = new MutationObserver((mutations) => {
                // Only process if panel style changed
                const hasPanelStyleChange = mutations.some(mutation => 
                    mutation.type === 'attributes' && 
                    mutation.attributeName === 'style' &&
                    mutation.target === this._cachedElements.panel
                );
                
                if (hasPanelStyleChange) {
                    throttledCallback();
                }
            });
            
            const panel = this.shadowRoot.getElementById('accessbit-widget-panel');
            if (panel) {
                observer.observe(panel, { 
                    attributes: true, 
                    attributeFilter: ['style'] 
                });
                this._mutationObserver = observer;
            }
        }
        
        // PERFORMANCE OPTIMIZATION: Periodic style check with throttling
        setupPeriodicStyleCheck() {
            // Check every 3 seconds instead of 2, and use requestAnimationFrame
            setInterval(() => {
                const panel = this._cachedElements.panel || this.shadowRoot?.getElementById('accessbit-widget-panel');
                if (!panel) return;
                
                // Use requestAnimationFrame to batch the check
                requestAnimationFrame(() => {
                    // Check if panel is visible (using transform instead of display)
                    const computedStyle = window.getComputedStyle(panel);
                    const isVisible = computedStyle.visibility !== 'hidden' && 
                                     computedStyle.opacity !== '0' &&
                                     panel.style.transform !== 'translateX(-100%)';
                    
                    if (isVisible) {
                        // Check if essential CSS properties are missing
                        const hasBackground = computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)' && 
                                             computedStyle.backgroundColor !== 'transparent';
                        const hasBoxShadow = computedStyle.boxShadow !== 'none';
                        const hasBorderRadius = computedStyle.borderRadius !== '0px';
                        
                        if (!hasBackground || !hasBoxShadow || !hasBorderRadius) {
                            this.ensureBasePanelCSS();
                        }
                    }
                });
            }, 3000);
        }
    
        applyLanguage(language) {
          
            // Save language to localStorage for persistence
            localStorage.setItem('accessbit-widget-language', language);

            
            const content = this.translations[language] || this.translations.en;
            
            // Ensure toggle text is always available
            if (!content.toggleOn) {
                content.toggleOn = "ON";
            }
            if (!content.toggleOff) {
                content.toggleOff = "OFF";
            }
           
            
            // Update panel title
            const titleElement = this.shadowRoot?.querySelector('.accessbit-widget-panel h2');
            if (titleElement) {
                titleElement.textContent = content.title;
                
            } else {

            }
            
            // Update section title
            const sectionTitle = this.shadowRoot?.querySelector('.white-content-section h3');
            if (sectionTitle) {
                sectionTitle.textContent = content.profilesTitle;

            } else {

            }
            
            // Update action buttons
            const resetBtn = this.shadowRoot?.querySelector('#reset-settings');
            if (resetBtn) {
                const resetIcon = document.createElement('i');
                resetIcon.className = 'fas fa-redo';
                resetBtn.textContent = '';
                resetBtn.appendChild(resetIcon);
                resetBtn.appendChild(document.createTextNode(' ' + (content.resetSettings || '')));

            } else {
               
            }
            
            const statementBtn = this.shadowRoot?.querySelector('#statement');
            if (statementBtn) {
                const stmtIcon = document.createElement('i');
                stmtIcon.className = 'fas fa-file-alt';
                statementBtn.textContent = '';
                statementBtn.appendChild(stmtIcon);
                statementBtn.appendChild(document.createTextNode(' ' + (content.statement || '')));

            } else {

            }
            
            const hideBtn = this.shadowRoot?.querySelector('#hide-interface');
            if (hideBtn) {
                const hideIcon = document.createElement('i');
                hideIcon.className = 'fas fa-eye-slash';
                hideBtn.textContent = '';
                hideBtn.appendChild(hideIcon);
                hideBtn.appendChild(document.createTextNode(' ' + (content.hideInterface || '')));
              
            } else {

            }
            
            // Update hide interface modal content if it exists
            this.updateHideInterfaceModal(content);
            
            // Setup hide interface modal event listeners
            this.setupHideInterfaceModal();
            
            // Update profile items using specific selectors
            this.updateProfileItem('seizure-safe', content.seizureSafe, content.seizureSafeDesc);
            this.updateProfileItem('vision-impaired', content.visionImpaired, content.visionImpairedDesc);
            this.updateProfileItem('adhd-friendly', content.adhdFriendly, content.adhdFriendlyDesc);
            this.updateProfileItem('cognitive-disability', content.cognitiveDisability, content.cognitiveDisabilityDesc);
            this.updateProfileItem('keyboard-nav', content.keyboardNav, content.keyboardNavDesc);
            this.updateProfileItem('screen-reader', content.screenReader, content.screenReaderDesc);
            this.updateProfileItem('content-scaling', content.contentScaling, content.contentScalingDesc);
            this.updateProfileItem('readable-font', content.readableFont, content.readableFontDesc);
            this.updateProfileItem('highlight-titles', content.highlightTitles, content.highlightTitlesDesc);
            this.updateProfileItem('highlight-links', content.highlightLinks, content.highlightLinksDesc);
            this.updateProfileItem('text-magnifier', content.textMagnifier, content.textMagnifierDesc);
            this.updateProfileItem('font-sizing', content.fontSizing, content.fontSizingDesc);
            this.updateProfileItem('align-center', content.alignCenter, content.alignCenterDesc);
            this.updateProfileItem('adjust-line-height', content.adjustLineHeight, content.adjustLineHeightDesc);
            this.updateProfileItem('adjust-letter-spacing', content.adjustLetterSpacing, content.adjustLetterSpacingDesc);
            this.updateProfileItem('align-left', content.alignLeft, content.alignLeftDesc);
            this.updateProfileItem('align-right', content.alignRight, content.alignRightDesc);
            this.updateProfileItem('dark-contrast', content.darkContrast, content.darkContrastDesc);
            this.updateProfileItem('light-contrast', content.lightContrast, content.lightContrastDesc);
            this.updateProfileItem('high-contrast', content.highContrast, content.highContrastDesc);
            this.updateProfileItem('high-saturation', content.highSaturation, content.highSaturationDesc);
            this.updateProfileItem('adjust-text-colors', content.adjustTextColors, content.adjustTextColorsDesc);
            this.updateProfileItem('monochrome', content.monochrome, content.monochromeDesc);
            this.updateProfileItem('adjust-title-colors', content.adjustTitleColors, content.adjustTitleColorsDesc);
            this.updateProfileItem('low-saturation', content.lowSaturation, content.lowSaturationDesc);
            this.updateProfileItem('adjust-bg-colors', content.adjustBgColors, content.adjustBgColorsDesc);
            this.updateProfileItem('mute-sound', content.muteSound, content.muteSoundDesc);
            this.updateProfileItem('hide-images', content.hideImages, content.hideImagesDesc);
            this.updateProfileItem('read-mode', content.readMode, content.readModeDesc);
            this.updateProfileItem('reading-guide', content.readingGuide, content.readingGuideDesc);
            this.updateProfileItem('useful-links', content.usefulLinks, content.usefulLinksDesc);
            this.updateProfileItem('stop-animation', content.stopAnimation, content.stopAnimationDesc);
            this.updateProfileItem('reduce-motion', content.reduceMotion, content.reduceMotionDesc);
            this.updateProfileItem('reading-mask', content.readingMask, content.readingMaskDesc);
            this.updateProfileItem('highlight-hover', content.highlightHover, content.highlightHoverDesc);
            this.updateProfileItem('highlight-focus', content.highlightFocus, content.highlightFocusDesc);
            this.updateProfileItem('big-black-cursor', content.bigBlackCursor, content.bigBlackCursorDesc);
            this.updateProfileItem('big-white-cursor', content.bigWhiteCursor, content.bigWhiteCursorDesc);
            
            // Update detailed descriptions and notes
            this.updateDetailedDescriptions(content);
            
            // Update toggle switch text
            this.updateToggleText(content);
            
          
        }
        
        updateProfileItem(profileId, title, description) {
            const profileItem = this.shadowRoot?.querySelector(`#${profileId}`)?.closest('.profile-item');
            if (profileItem) {
                const h4 = profileItem.querySelector('h4');
                const p = profileItem.querySelector('p');
                
                if (h4 && title) {
                    h4.textContent = title;

                }
                if (p && description) {
                    p.textContent = description;

                }
            }
        }
        
        updateDetailedDescriptions(content) {
            // Update keyboard navigation detailed description
            const keyboardNavDescription = this.shadowRoot?.querySelector('#keyboard-nav')?.closest('.profile-item')?.querySelector('.profile-description p');
            if (keyboardNavDescription && content.keyboardNavDetailed) {
                keyboardNavDescription.textContent = content.keyboardNavDetailed;

            }
            
            // Update keyboard navigation note
            const keyboardNavNote = this.shadowRoot?.querySelector('#keyboard-nav')?.closest('.profile-item')?.querySelector('.profile-description p:last-child');
            if (keyboardNavNote && content.keyboardNavNote) {
                keyboardNavNote.textContent = '';
                const kstrong = document.createElement('strong');
                keyboardNavNote.appendChild(kstrong);
                keyboardNavNote.appendChild(document.createTextNode(' ' + (content.keyboardNavNote.replace('Note: ', '') || '')));

            }
            
            // Update screen reader detailed description
            const screenReaderDescription = this.shadowRoot?.querySelector('#screen-reader')?.closest('.profile-item')?.querySelector('.profile-description p');
            if (screenReaderDescription && content.screenReaderDetailed) {
                screenReaderDescription.textContent = content.screenReaderDetailed;

            }
            
            // Update screen reader note
            const screenReaderNote = this.shadowRoot?.querySelector('#screen-reader')?.closest('.profile-item')?.querySelector('.profile-description p:last-child');
            if (screenReaderNote && content.screenReaderNote) {
                screenReaderNote.textContent = '';
                const sstrong = document.createElement('strong');
                screenReaderNote.appendChild(sstrong);
                screenReaderNote.appendChild(document.createTextNode(' ' + (content.screenReaderNote.replace('Note: ', '') || '')));
              
            }
            
            // Update "Activates with" text for keyboard navigation
            const keyboardNavActivates = this.shadowRoot?.querySelector('#keyboard-nav')?.closest('.profile-item')?.querySelector('small');
            if (keyboardNavActivates && content.activatesWithScreenReader) {
                keyboardNavActivates.textContent = content.activatesWithScreenReader;

            }
            
            // Update "Activates with" text for screen reader
            const screenReaderActivates = this.shadowRoot?.querySelector('#screen-reader')?.closest('.profile-item')?.querySelector('small');
            if (screenReaderActivates && content.activatesWithKeyboardNav) {
                screenReaderActivates.textContent = content.activatesWithKeyboardNav;

            }
        }
        
        updateToggleText(content) {

            // Update CSS custom properties for toggle text
            if (content.toggleOn && content.toggleOff) {
                // Create style element for shadow DOM
                const style = document.createElement('style');
                style.id = 'toggle-text-translation';
                style.textContent = `
                    .slider::after {
                        content: "${content.toggleOff}" !important;
                    }
                    input:checked + .slider::after {
                        content: "${content.toggleOn}" !important;
                    }
                `;
                
             
                // Remove existing toggle text style if it exists from shadow DOM
                const existingStyle = this.shadowRoot?.getElementById('toggle-text-translation');
                if (existingStyle) {
                  
                    existingStyle.remove();
                }
                
                // Add the new style to shadow DOM
                if (this.shadowRoot) {
                    this.shadowRoot.appendChild(style);

                    
                    // Force a re-render to ensure the changes take effect
                    const toggles = this.shadowRoot.querySelectorAll('.slider');
                    toggles.forEach(toggle => {
                        toggle.style.display = 'none';
                        toggle.offsetHeight; // Trigger reflow
                        toggle.style.display = '';
                    });
                } else {

                }
            } else {
               
            }
        }
        
        updateHideInterfaceModal(content) {
            const modalTitle = this.shadowRoot?.querySelector('#hide-modal-title');
            const modalText = this.shadowRoot?.querySelector('#hide-modal-text');
            const modalAccept = this.shadowRoot?.querySelector('#hide-modal-accept');
            const modalCancel = this.shadowRoot?.querySelector('#hide-modal-cancel');
            
            if (modalTitle && content.hideInterfaceModalTitle) {
                modalTitle.textContent = content.hideInterfaceModalTitle;
            }
            if (modalText && content.hideInterfaceModalText) {
                modalText.textContent = content.hideInterfaceModalText;
            }
            if (modalAccept && content.hideInterfaceModalAccept) {
                modalAccept.textContent = content.hideInterfaceModalAccept;
            }
            if (modalCancel && content.hideInterfaceModalCancel) {
                modalCancel.textContent = content.hideInterfaceModalCancel;
            }
        }
        
        setupHideInterfaceModal() {
            const hideBtn = this.shadowRoot?.querySelector('#hide-interface');
            const modal = this.shadowRoot?.querySelector('#hide-interface-modal');
            const modalClose = this.shadowRoot?.querySelector('#hide-modal-close');
            const modalCancel = this.shadowRoot?.querySelector('#hide-modal-cancel');
            const modalAccept = this.shadowRoot?.querySelector('#hide-modal-accept');
            
         
            
            if (hideBtn && modal) {

                hideBtn.addEventListener('click', (e) => {

                    e.preventDefault();
                    e.stopPropagation();
                    this.showHideInterfaceModal();
                });
            } else {

            }
            
            if (modalClose) {
                modalClose.addEventListener('click', () => {
                    this.hideHideInterfaceModal();
                });
            }
            
            if (modalCancel) {
                modalCancel.addEventListener('click', () => {

                    this.hideHideInterfaceModal();
                    // Ensure icon is visible after canceling
                    this.ensureIconVisible();
                });
            }
            
            if (modalAccept) {
                modalAccept.addEventListener('click', () => {
                    this.acceptHideInterface();
                });
            }
            
            // Close modal when clicking outside
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.hideHideInterfaceModal();
                    }
                });
            }
        }
        
        showHideInterfaceModal() {

            const modal = this.shadowRoot?.querySelector('#hide-interface-modal');
            const panel = this.shadowRoot?.querySelector('#accessbit-widget-panel');

            
            if (modal && panel) {
                // Set modal to cover the entire panel content including scrollable areas
                const panelScrollHeight = panel.scrollHeight;
                const panelClientHeight = panel.clientHeight;

                
                // Set the modal height to cover the full scrollable content
                modal.style.height = `${panelScrollHeight}px`;
                modal.style.minHeight = `${panelScrollHeight}px`;
                modal.style.display = 'flex';
                
                // Position the modal dialog in the center of the viewable area
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    // Calculate the center position of the viewable area
                    const centerTop = (panelClientHeight / 2) - (modalContent.offsetHeight / 2);
                    modalContent.style.position = 'absolute';
                    modalContent.style.top = `${Math.max(0, centerTop)}px`;
                    modalContent.style.left = '50%';
                    modalContent.style.transform = 'translateX(-50%)';
                    modalContent.style.margin = '0';
                }
                
                
            } else {
                
            }
        }
        
        hideHideInterfaceModal() {
            const modal = this.shadowRoot?.querySelector('#hide-interface-modal');
            if (modal) {
                modal.style.display = 'none';

            }
        }
        
        ensureIconVisible() {

            const icon = this.shadowRoot?.querySelector('#accessbit-widget-icon');
            const panel = this.shadowRoot?.querySelector('#accessbit-widget-panel');
            
            if (icon) {
                icon.style.display = 'flex';
                icon.style.visibility = 'visible';
                icon.style.opacity = '1';

            }
            
            if (panel) {
                panel.style.display = 'none'; // Keep panel hidden unless opened
               
            }
        }
        
        debugFontSizeConflicts(element) {
            
            
            if (!element) {
                
                return;
            }
            
            // Get computed styles
            const computedStyle = window.getComputedStyle(element);
            const fontSize = computedStyle.fontSize;
            const fontFamily = computedStyle.fontFamily;
            
        
            
            // Check inline styles
            const inlineFontSize = element.style.fontSize;
           
            
            // Check for any CSS rules that might be affecting font-size
            const allStyles = document.styleSheets;

            
            // Check if element has any classes that might affect font-size
            const classes = element.className;
          
            // Check parent element font-size
            const parent = element.parentElement;
            if (parent) {
                const parentFontSize = window.getComputedStyle(parent).fontSize;
               
            }
        }
        
        applyMobileButtonStacking() {

            // Find the action buttons container
            const actionButtons = this.shadowRoot?.querySelector('.action-buttons');
            const buttonRows = this.shadowRoot?.querySelectorAll('.button-row');
            
            
            
            if (actionButtons) {
                // Stack all buttons vertically on mobile
                actionButtons.style.setProperty('flex-direction', 'column', 'important');
                actionButtons.style.setProperty('gap', '8px', 'important');
                actionButtons.style.setProperty('align-items', 'stretch', 'important');

            }
            
            if (buttonRows && buttonRows.length > 0) {
                buttonRows.forEach((row, index) => {
                    // Make each button row stack vertically
                    row.style.setProperty('flex-direction', 'column', 'important');
                    row.style.setProperty('gap', '8px', 'important');
                    row.style.setProperty('width', '100%', 'important');
                
                });
            }
            
            // Also ensure individual buttons take full width
            const actionBtns = this.shadowRoot?.querySelectorAll('.action-btn');
            if (actionBtns && actionBtns.length > 0) {
                actionBtns.forEach((btn, index) => {
                    btn.style.setProperty('width', '100%', 'important');
                    btn.style.setProperty('justify-content', 'center', 'important');
                   
                });
            }
        }
        
        applyMobileSizeReductions() {
       
            
            // Reduce action button sizes
            const actionBtns = this.shadowRoot?.querySelectorAll('.action-btn');
            if (actionBtns && actionBtns.length > 0) {
                actionBtns.forEach((btn, index) => {
                    btn.style.setProperty('font-size', '11px', 'important');
                    btn.style.setProperty('padding', '6px 10px', 'important');
                    btn.style.setProperty('min-height', '30px', 'important');
                  
                });
            }
            
            // Reduce toggle switch sizes (label.toggle-switch contains input + span.slider)
            const toggles = this.shadowRoot?.querySelectorAll('label.toggle-switch');
            if (toggles && toggles.length > 0) {
                toggles.forEach((toggle, index) => {
                    toggle.style.setProperty('width', '38px', 'important');
                    toggle.style.setProperty('height', '22px', 'important');
                    
                });
            }
            
            // Reduce toggle slider knob (.slider and its pseudo knob)
            const sliders = this.shadowRoot?.querySelectorAll('label.toggle-switch > span.slider');
            if (sliders && sliders.length > 0) {
                sliders.forEach((slider, index) => {
                    // Track and bar
                    slider.style.setProperty('height', '22px', 'important');
                    slider.style.setProperty('border-radius', '22px', 'important');
                    slider.style.setProperty('padding', '0', 'important');
                    slider.style.setProperty('box-sizing', 'border-box', 'important');
                    // Inject a tiny stylesheet to shrink the knob (:before)
                    const style = document.createElement('style');
                    style.textContent = `
                        @media (max-width: 768px) {
                            .toggle-switch > input + .slider:before { width: 18px !important; height: 18px !important; top: 2px !important; left: 2px !important; }
                        }
                    `;
                    this.shadowRoot?.appendChild(style);
                 
                });
            }
            
            // Reduce profile item sizes
            const profileItems = this.shadowRoot?.querySelectorAll('.profile-item');
            if (profileItems && profileItems.length > 0) {
                profileItems.forEach((item, index) => {
                    item.style.setProperty('padding', '8px 10px', 'important');
                    item.style.setProperty('margin-bottom', '6px', 'important');
                  
                });
            }
            
            // Reduce headings and profile titles
            const headerH2 = this.shadowRoot?.querySelector('.panel-header h2');
            if (headerH2) {
                headerH2.style.setProperty('font-size', '16px', 'important');
                headerH2.style.setProperty('line-height', '20px', 'important');
             
            }
            const profileTitles = this.shadowRoot?.querySelectorAll('.profile-item h4');
            if (profileTitles && profileTitles.length > 0) {
                profileTitles.forEach((title, index) => {
                    title.style.setProperty('font-size', '12px', 'important');
                    title.style.setProperty('line-height', '1.3', 'important');
                    
                });
            }
            
            // Reduce profile descriptions
            const profileDescs = this.shadowRoot?.querySelectorAll('.profile-item p');
            if (profileDescs && profileDescs.length > 0) {
                profileDescs.forEach((desc, index) => {
                    desc.style.setProperty('font-size', '10px', 'important');
                    desc.style.setProperty('line-height', '1.2', 'important');
                   
                });
            }
            
            // Reduce section titles
            const sectionTitles = this.shadowRoot?.querySelectorAll('h3');
            if (sectionTitles && sectionTitles.length > 0) {
                sectionTitles.forEach((title, index) => {
                    title.style.setProperty('font-size', '13px', 'important');
                    title.style.setProperty('margin-bottom', '8px', 'important');
                   
                });
            }
            
            // Reduce language selector size
            const languageSelector = this.shadowRoot?.querySelector('.language-selector');
            if (languageSelector) {
                languageSelector.style.setProperty('font-size', '11px', 'important');
                languageSelector.style.setProperty('padding', '6px 8px', 'important');
              
            }
            
            // Reduce close button size and fix position - match hide interface modal approach
            const closeBtn = this.shadowRoot?.querySelector('.close-btn');
            if (closeBtn) {
                closeBtn.style.setProperty('font-size', '20px', 'important');
                closeBtn.style.setProperty('width', '28px', 'important');
                closeBtn.style.setProperty('height', '28px', 'important');
                closeBtn.style.setProperty('min-width', '28px', 'important');
                closeBtn.style.setProperty('min-height', '28px', 'important');
                closeBtn.style.setProperty('max-width', '28px', 'important');
                closeBtn.style.setProperty('max-height', '28px', 'important');
                closeBtn.style.setProperty('top', '8px', 'important');
                closeBtn.style.setProperty('left', '12px', 'important');
                closeBtn.style.setProperty('display', 'flex', 'important');
                closeBtn.style.setProperty('align-items', 'center', 'important');
                closeBtn.style.setProperty('justify-content', 'center', 'important');
                closeBtn.style.setProperty('box-sizing', 'border-box', 'important');
              
            }
            
            // Reduce increase/decrease buttons (arrow controls) more on mobile
            const arrowBtns = this.shadowRoot?.querySelectorAll('button[class*="arrow"], button[class*="increase"], button[class*="decrease"], .arrow-btn, .control-btn, .scaling-btn');
            if (arrowBtns && arrowBtns.length > 0) {
                arrowBtns.forEach((btn, index) => {
                    btn.style.setProperty('height', '20px', 'important');
                    btn.style.setProperty('min-height', '20px', 'important');
                    btn.style.setProperty('padding', '1px 6px', 'important');
                    btn.style.setProperty('font-size', '9px', 'important');
                    btn.style.setProperty('border-radius', '4px', 'important');
                    // Don't set line-height when using flexbox - it interferes with centering
                    // btn.style.setProperty('line-height', '1', 'important');
                    btn.style.setProperty('width', 'auto', 'important');
                    btn.style.setProperty('min-width', '32px', 'important');
                    // Ensure flexbox centering for button content
                    btn.style.setProperty('display', 'flex', 'important');
                    btn.style.setProperty('align-items', 'center', 'important');
                    btn.style.setProperty('justify-content', 'center', 'important');
                    btn.style.setProperty('gap', '4px', 'important');
                    // Ensure icon aligns properly
                    const icon = btn.querySelector('i.fas');
                    if (icon) {
                        icon.style.setProperty('display', 'inline-flex', 'important');
                        icon.style.setProperty('align-items', 'center', 'important');
                        icon.style.setProperty('line-height', '1', 'important');
                    }
                    
                });
            }
            
            // Add mobile-specific CSS for all control buttons
            const mobileControlStyle = document.createElement('style');
            mobileControlStyle.textContent = `
                @media (max-width: 768px) {
                    .scaling-btn, button[class*="increase"], button[class*="decrease"], .arrow-btn, .control-btn {
                        height: 20px !important;
                        min-height: 20px !important;
                        padding: 1px 6px !important;
                        font-size: 9px !important;
                        border-radius: 4px !important;
                        /* Don't set line-height when using flexbox - it interferes with centering */
                        width: auto !important;
                        min-width: 32px !important;
                        display: flex !important;
                        align-items: center !important;
                        justify-content: center !important;
                        gap: 4px !important;
                    }
                    
                    /* Ensure icons inside buttons align properly */
                    .scaling-btn i.fas,
                    button[class*="increase"] i.fas,
                    button[class*="decrease"] i.fas {
                        display: flex !important;
                        align-items: center !important;
                        justify-content: center !important;
                        line-height: 1 !important;
                    }
                    
                    .scaling-btn span,
                    button[class*="increase"] span,
                    button[class*="decrease"] span {
                        display: flex !important;
                        align-items: center !important;
                        line-height: 1 !important;
                        margin: 0 !important;
                        padding: 0 !important;
                    }
                }
            `;
            this.shadowRoot?.appendChild(mobileControlStyle);
        
            
            // Reduce color picker sizes
            const colorPickers = this.shadowRoot?.querySelectorAll('.color-picker, .color-input, .color-preview, .color-picker-button, input[type="color"]');
            if (colorPickers && colorPickers.length > 0) {
                colorPickers.forEach((picker, index) => {
                    picker.style.setProperty('width', '24px', 'important');
                    picker.style.setProperty('height', '24px', 'important');
                    picker.style.setProperty('min-width', '24px', 'important');
                    picker.style.setProperty('min-height', '24px', 'important');
                 
                });
            }
            
            // Reduce useful links dropdown size more aggressively
            const usefulLinksDropdown = this.shadowRoot?.querySelector('.useful-links-dropdown');
            if (usefulLinksDropdown) {
                usefulLinksDropdown.style.setProperty('font-size', '10px', 'important');
                usefulLinksDropdown.style.setProperty('padding', '4px 6px', 'important');
                usefulLinksDropdown.style.setProperty('min-height', '28px', 'important');
                usefulLinksDropdown.style.setProperty('margin', '6px 0', 'important');
                usefulLinksDropdown.style.setProperty('border-radius', '6px', 'important');
             
            }
            
            // Reduce useful links content select size more aggressively
            const usefulLinksSelect = this.shadowRoot?.querySelector('.useful-links-content select');
            if (usefulLinksSelect) {
                usefulLinksSelect.style.setProperty('font-size', '10px', 'important');
                usefulLinksSelect.style.setProperty('padding', '4px 6px', 'important');
                usefulLinksSelect.style.setProperty('min-height', '24px', 'important');
                usefulLinksSelect.style.setProperty('height', '24px', 'important');
                usefulLinksSelect.style.setProperty('line-height', '1.1', 'important');
                usefulLinksSelect.style.setProperty('max-width', '100%', 'important');
                usefulLinksSelect.style.setProperty('box-sizing', 'border-box', 'important');
                usefulLinksSelect.style.setProperty('border-radius', '4px', 'important');
               
            }
            
            // Add mobile-specific CSS for Useful Links dropdown
            const mobileUsefulLinksStyle = document.createElement('style');
            mobileUsefulLinksStyle.textContent = `
                @media (max-width: 768px) {
                    .useful-links-dropdown {
                        font-size: 10px !important;
                        padding: 4px 6px !important;
                        min-height: 28px !important;
                        margin: 6px 0 !important;
                        border-radius: 6px !important;
                    }
                    .useful-links-content {
                        padding: 6px !important;
                    }
                    .useful-links-content select {
                        font-size: 10px !important;
                        padding: 4px 6px !important;
                        min-height: 24px !important;
                        height: 24px !important;
                        line-height: 1.1 !important;
                        border-radius: 4px !important;
                    }
                    .useful-links-content select option {
                        font-size: 10px !important;
                        padding: 4px 6px !important;
                        line-height: 1.1 !important;
                    }
                }
            `;
            this.shadowRoot?.appendChild(mobileUsefulLinksStyle);
          
            // Prevent Useful Links title from shifting when toggle is ON (mobile)
            const usefulLinksProfile = this.shadowRoot?.querySelector('.profile-item.has-dropdown');
            if (usefulLinksProfile) {
                const profileInfo = usefulLinksProfile.querySelector('.profile-info');
                const toggle = usefulLinksProfile.querySelector('.toggle-switch');
                if (profileInfo) {
                    // Keep text in normal flow - don't add excessive padding
                    profileInfo.style.setProperty('padding-left', '0', 'important');
                    profileInfo.style.setProperty('min-width', '0', 'important');
                }
                if (toggle) {
                    // Keep toggle in normal flow - don't use absolute positioning
                    toggle.style.setProperty('position', 'relative', 'important');
                    toggle.style.setProperty('left', 'auto', 'important');
                    toggle.style.setProperty('top', 'auto', 'important');
                    toggle.style.setProperty('transform', 'none', 'important');
                    toggle.style.setProperty('margin', '0', 'important');
                }
               
            }
            
            // Increase toggle width when ON to fit text properly and fix text sliding
            const style = document.createElement('style');
            style.textContent = `
                @media (max-width: 768px) {
                    .toggle-switch > input:checked + .slider { width: 100% !important; }
                }
                .profile-item .profile-info { 
                    min-width: 0 !important; 
                    word-wrap: break-word !important;
                    word-break: break-word !important;
                    overflow-wrap: break-word !important;
                }
                .profile-item .profile-info h4, .profile-item .profile-info p { 
                    white-space: normal !important; 
                    overflow: visible !important; 
                    text-overflow: unset !important; 
                    max-width: 100% !important; 
                    word-wrap: break-word !important;
                    word-break: break-word !important;
                    overflow-wrap: break-word !important;
                    hyphens: auto !important;
                }
                /* Ensure useful links toggle works correctly */
                #useful-links:checked + .slider:before {
                    transform: translateX(26px) !important;
                }
                
                /* Hide ON/OFF text on mobile screens */
                @media (max-width: 768px) {
                    .toggle-switch > input + .slider::after {
                        content: "" !important;
                        display: none !important;
                        visibility: hidden !important;
                        opacity: 0 !important;
                    }
                    .toggle-switch > input:checked + .slider::after {
                        content: "" !important;
                        display: none !important;
                        visibility: hidden !important;
                        opacity: 0 !important;
                    }
                }
            `;
            this.shadowRoot?.appendChild(style);
           
        }
        
        removeMobileButtonStacking() {
        
            
            // Find the action buttons container
            const actionButtons = this.shadowRoot?.querySelector('.action-buttons');
            const buttonRows = this.shadowRoot?.querySelectorAll('.button-row');
            
        
            
            if (actionButtons) {
                // Restore desktop layout
                actionButtons.style.removeProperty('flex-direction');
                actionButtons.style.removeProperty('gap');
                actionButtons.style.removeProperty('align-items');
     
            }
            
            if (buttonRows && buttonRows.length > 0) {
                buttonRows.forEach((row, index) => {
                    // Restore desktop button row layout
                    row.style.removeProperty('flex-direction');
                    row.style.removeProperty('gap');
                    row.style.removeProperty('width');
                  
                });
            }
            
            // Restore individual button styles
            const actionBtns = this.shadowRoot?.querySelectorAll('.action-btn');
            if (actionBtns && actionBtns.length > 0) {
                actionBtns.forEach((btn, index) => {
                    btn.style.removeProperty('width');
                    btn.style.removeProperty('justify-content');
                    
                });
            }
        }
        
        removeMobileSizeReductions() {
            
            
            // Restore action button sizes
            const actionBtns = this.shadowRoot?.querySelectorAll('.action-btn');
            if (actionBtns && actionBtns.length > 0) {
                actionBtns.forEach((btn, index) => {
                    btn.style.removeProperty('font-size');
                    btn.style.removeProperty('padding');
                    btn.style.removeProperty('min-height');
                   
                });
            }
            
            // Restore toggle switch sizes
            const toggles = this.shadowRoot?.querySelectorAll('.toggle-switch');
            if (toggles && toggles.length > 0) {
                toggles.forEach((toggle, index) => {
                    toggle.style.removeProperty('width');
                    toggle.style.removeProperty('height');
                  
                });
            }
            
            // Restore toggle switch sliders
            const sliders = this.shadowRoot?.querySelectorAll('.toggle-slider');
            if (sliders && sliders.length > 0) {
                sliders.forEach((slider, index) => {
                    slider.style.removeProperty('width');
                    slider.style.removeProperty('height');
                    
                });
            }
            
            // Restore profile item sizes
            const profileItems = this.shadowRoot?.querySelectorAll('.profile-item');
            if (profileItems && profileItems.length > 0) {
                profileItems.forEach((item, index) => {
                    item.style.removeProperty('padding');
                    item.style.removeProperty('margin-bottom');
                    
                });
            }
            
            // Restore profile titles
            const profileTitles = this.shadowRoot?.querySelectorAll('.profile-title');
            if (profileTitles && profileTitles.length > 0) {
                profileTitles.forEach((title, index) => {
                    title.style.removeProperty('font-size');
                    title.style.removeProperty('line-height');
                    
                });
            }
            
            // Restore profile descriptions
            const profileDescs = this.shadowRoot?.querySelectorAll('.profile-description');
            if (profileDescs && profileDescs.length > 0) {
                profileDescs.forEach((desc, index) => {
                    desc.style.removeProperty('font-size');
                    desc.style.removeProperty('line-height');
                  
                });
            }
            
            // Restore section titles
            const sectionTitles = this.shadowRoot?.querySelectorAll('h3');
            if (sectionTitles && sectionTitles.length > 0) {
                sectionTitles.forEach((title, index) => {
                    title.style.removeProperty('font-size');
                    title.style.removeProperty('margin-bottom');
                  
                });
            }
            
            // Restore language selector size
            const languageSelector = this.shadowRoot?.querySelector('.language-selector');
            if (languageSelector) {
                languageSelector.style.removeProperty('font-size');
                languageSelector.style.removeProperty('padding');
               
            }
            
            // Restore close button size and position
            const closeBtn = this.shadowRoot?.querySelector('.close-btn');
            if (closeBtn) {
                closeBtn.style.removeProperty('font-size');
                closeBtn.style.removeProperty('width');
                closeBtn.style.removeProperty('height');
                closeBtn.style.removeProperty('min-width');
                closeBtn.style.removeProperty('min-height');
                closeBtn.style.removeProperty('max-width');
                closeBtn.style.removeProperty('max-height');
                closeBtn.style.removeProperty('top');
                closeBtn.style.removeProperty('left');
                closeBtn.style.removeProperty('display');
                closeBtn.style.removeProperty('align-items');
                closeBtn.style.removeProperty('justify-content');
                closeBtn.style.removeProperty('box-sizing');
            
            }
            
            // Restore increase/decrease buttons
            const arrowBtns = this.shadowRoot?.querySelectorAll('button[class*="arrow"], button[class*="increase"], button[class*="decrease"], .arrow-btn, .control-btn');
            if (arrowBtns && arrowBtns.length > 0) {
                arrowBtns.forEach((btn, index) => {
                    btn.style.removeProperty('height');
                    btn.style.removeProperty('min-height');
                    btn.style.removeProperty('padding');
                    btn.style.removeProperty('font-size');
                    
                });
            }
            
            // Restore color picker sizes
            const colorPickers = this.shadowRoot?.querySelectorAll('.color-picker, .color-input, .color-preview, .color-picker-button, input[type="color"]');
            if (colorPickers && colorPickers.length > 0) {
                colorPickers.forEach((picker, index) => {
                    picker.style.removeProperty('width');
                    picker.style.removeProperty('height');
                    picker.style.removeProperty('min-width');
                    picker.style.removeProperty('min-height');
                
                });
            }
            
            // Restore useful links dropdown size
            const usefulLinksDropdown = this.shadowRoot?.querySelector('.useful-links-dropdown');
            if (usefulLinksDropdown) {
                usefulLinksDropdown.style.removeProperty('font-size');
                usefulLinksDropdown.style.removeProperty('padding');
                usefulLinksDropdown.style.removeProperty('min-height');
                
            }
            
            // Restore useful links content select size
            const usefulLinksSelect = this.shadowRoot?.querySelector('.useful-links-content select');
            if (usefulLinksSelect) {
                usefulLinksSelect.style.removeProperty('font-size');
                usefulLinksSelect.style.removeProperty('padding');
                usefulLinksSelect.style.removeProperty('min-height');
               
            }
            
            // Remove injected toggle width styles
            const injectedStyles = this.shadowRoot?.querySelectorAll('style');
            if (injectedStyles && injectedStyles.length > 0) {
                injectedStyles.forEach(style => {
                    if (style.textContent.includes('toggle-switch') || style.textContent.includes('slider:before')) {
                        style.remove();
                      
                    }
                });
            }
          
        }
        
        acceptHideInterface() {
         
            
            // Set flag in localStorage to hide interface permanently
            localStorage.setItem('accessbit-widget-hidden', 'true');
        
            
            // Hide the panel and icon completely
            const panel = this.shadowRoot?.querySelector('#accessbit-widget-panel');
            const icon = this.shadowRoot?.querySelector('#accessbit-widget-icon');
            
        
            
            if (panel) {
                panel.style.display = 'none';
                panel.style.visibility = 'hidden';
                panel.style.opacity = '0';
             
            }
            if (icon) {
                console.log('[ICON HIDE] acceptHideInterface() - User accepted hiding interface');
                icon.style.display = 'none';
                icon.style.visibility = 'hidden';
                icon.style.opacity = '0';
        
            }
            
            // Also hide the entire shadow root container
            const widgetContainer = this.shadowRoot?.host;
            if (widgetContainer) {
                widgetContainer.style.display = 'none';
                widgetContainer.style.visibility = 'hidden';

            }
            
            // Close the modal
            this.hideHideInterfaceModal();
            
            
        }
    
        updateTriggerPosition(direction, position) {
           
            const normalizedDirection = (direction || '').toLowerCase();
            const pos = (position || '').toLowerCase();
            
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                if (normalizedDirection === 'vertical') {
                    // Force remove any existing positioning
                    icon.style.removeProperty('top');
                    icon.style.removeProperty('bottom');
                    icon.style.removeProperty('transform');
                    
                    if (pos === 'top') {
                        icon.style.setProperty('top', '20px', 'important');
                        icon.style.setProperty('bottom', 'auto', 'important');
                     
                    } else if (pos === 'middle') {
                        icon.style.setProperty('top', '50%', 'important');
                        icon.style.setProperty('bottom', 'auto', 'important');
                        icon.style.setProperty('transform', 'translateY(-50%)', 'important');
                      
                    } else if (pos === 'bottom') {
                        icon.style.setProperty('bottom', '20px', 'important');
                        icon.style.setProperty('top', 'auto', 'important');
                        
                    }
                } else if (normalizedDirection === 'horizontal') {
                    // Force remove any existing positioning
                    icon.style.removeProperty('left');
                    icon.style.removeProperty('right');
                    
                    if (pos === 'left') {
                        icon.style.setProperty('left', '20px', 'important');
                        icon.style.setProperty('right', 'auto', 'important');
                     
                    } else if (pos === 'right') {
                        icon.style.setProperty('right', '20px', 'important');
                        icon.style.setProperty('left', 'auto', 'important');
                        
                    }
                }
                
                // Force the style to take effect
                icon.offsetHeight; // Trigger reflow
                
                // Apply stored desktop offsets if they exist
                if (this.desktopHorizontalOffset !== undefined) {
                  
                    this.updateTriggerOffset('horizontal', this.desktopHorizontalOffset);
                }
                if (this.desktopVerticalOffset !== undefined) {
                   
                    this.updateTriggerOffset('vertical', this.desktopVerticalOffset);
                }
            }
        }
        // Helper methods for applying customizations with actual DOM manipulation
        updateTriggerButtonColor(color) {
         
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                icon.style.backgroundColor = color;
                icon.style.borderColor = color;
                // Ensure icon content is centered
                icon.style.display = 'flex';
                icon.style.alignItems = 'center';
                icon.style.justifyContent = 'center';
            }
        }
        
        updateTriggerButtonShape(shape) {
           
            
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            
            if (icon) {

                
                // Check if we're on mobile and have mobile shape configuration
                const isMobile = window.innerWidth <= 768;
                const hasMobileShape = this.customizationData?.mobileTriggerShape;
                
                if (isMobile && hasMobileShape) {
                  
                    return;
                }
                
            
                
                // Set data attribute for CSS targeting
                icon.setAttribute('data-shape', shape.toLowerCase());

            
                // Remove any existing border-radius properties
                icon.style.removeProperty('border-radius');
                icon.style.removeProperty('-webkit-border-radius');
                icon.style.removeProperty('-moz-border-radius');

                // Set the appropriate border-radius
                let borderRadius = '50%'; // Default circle
              
                if (shape === 'Circle') {
                    borderRadius = '50%';
                 
                } else if (shape === 'Rounded') {
                    borderRadius = '12px';

                } else if (shape === 'Square') {
                    borderRadius = '0px';
                  
                } else {

                }
                

                
                // Apply the border-radius with maximum specificity
                icon.style.setProperty('border-radius', borderRadius, 'important');
                icon.style.setProperty('-webkit-border-radius', borderRadius, 'important');
                icon.style.setProperty('-moz-border-radius', borderRadius, 'important');

                
                // Update CSS classes
                icon.classList.remove('circle', 'rounded', 'square');
                icon.classList.add(shape.toLowerCase());
               
                
                // Force the shape with direct style assignment as backup
                icon.style.borderRadius = borderRadius;
                icon.style.webkitBorderRadius = borderRadius;
                icon.style.mozBorderRadius = borderRadius;

                
                // Force a reflow to ensure styles are applied
                icon.offsetHeight;
                
         
                
                // Detailed verification
                const computedStyle = window.getComputedStyle(icon);
                const appliedBorderRadius = computedStyle.borderRadius;
                
                if (appliedBorderRadius === borderRadius) {

                } else {

                }
                
                // Final verification after a delay
                setTimeout(() => {
                    const finalComputed = window.getComputedStyle(icon).borderRadius;
               
                    if (finalComputed === borderRadius) {
                        
                    } else {
                       
                        
                        // Ultra-aggressive force fix
                        icon.style.setProperty('border-radius', borderRadius, 'important');
                        icon.style.setProperty('-webkit-border-radius', borderRadius, 'important');
                        icon.style.setProperty('-moz-border-radius', borderRadius, 'important');
                        icon.style.borderRadius = borderRadius;
                        icon.style.webkitBorderRadius = borderRadius;
                        icon.style.mozBorderRadius = borderRadius;
                        
                        // Force reflow
                        icon.offsetHeight;
                        
                        const finalFinalComputed = window.getComputedStyle(icon).borderRadius;
                        
                        
                        // Last resort: Create a new style element with maximum specificity
                        if (finalFinalComputed !== borderRadius) {
                            
                            const style = document.createElement('style');
                            style.textContent = `
                                .accessbit-widget-icon[data-shape="rounded"] {
                                    border-radius: ${borderRadius} !important;
                                    -webkit-border-radius: ${borderRadius} !important;
                                    -moz-border-radius: ${borderRadius} !important;
                                }
                                .accessbit-widget-icon.rounded {
                                    border-radius: ${borderRadius} !important;
                                    -webkit-border-radius: ${borderRadius} !important;
                                    -moz-border-radius: ${borderRadius} !important;
                                }
                            `;
                            document.head.appendChild(style);
                           
                        }
                    }
                }, 100);
                
               
                
                // Force apply after a short delay to override any conflicting styles
                setTimeout(() => {
                
                    if (shape === 'Rounded') {
                        icon.style.setProperty('border-radius', '12px', 'important');
                        icon.style.setProperty('-webkit-border-radius', '12px', 'important');
                        icon.style.setProperty('-moz-border-radius', '12px', 'important');
                        icon.style.setProperty('border-top-left-radius', '12px', 'important');
                        icon.style.setProperty('border-top-right-radius', '12px', 'important');
                        icon.style.setProperty('border-bottom-left-radius', '12px', 'important');
                        icon.style.setProperty('border-bottom-right-radius', '12px', 'important');
                     
                    }
                    
                    const finalComputedStyle = window.getComputedStyle(icon);
                    const finalBorderRadius = finalComputedStyle.borderRadius;
                    
                }, 100);
                
                // Additional force application after external CSS loads
                setTimeout(() => {
                   
                    if (shape === 'Rounded') {
                        icon.style.setProperty('border-radius', '12px', 'important');
                        icon.style.setProperty('-webkit-border-radius', '12px', 'important');
                        icon.style.setProperty('-moz-border-radius', '12px', 'important');
                        icon.style.setProperty('border-top-left-radius', '12px', 'important');
                        icon.style.setProperty('border-top-right-radius', '12px', 'important');
                        icon.style.setProperty('border-bottom-left-radius', '12px', 'important');
                        icon.style.setProperty('border-bottom-right-radius', '12px', 'important');
                      
                    }
                    
                    const finalComputedStyle2 = window.getComputedStyle(icon);
                    const finalBorderRadius2 = finalComputedStyle2.borderRadius;
                  
                }, 500);
                
                // Final aggressive force application
                setTimeout(() => {
                    
                    if (shape === 'Rounded') {
                        // Remove any conflicting styles first
                        icon.style.removeProperty('border-radius');
                        icon.style.removeProperty('-webkit-border-radius');
                        icon.style.removeProperty('-moz-border-radius');
                        
                        // Apply rounded shape with maximum force
                        icon.style.setProperty('border-radius', '12px', 'important');
                        icon.style.setProperty('-webkit-border-radius', '12px', 'important');
                        icon.style.setProperty('-moz-border-radius', '12px', 'important');
                        icon.style.setProperty('border-top-left-radius', '12px', 'important');
                        icon.style.setProperty('border-top-right-radius', '12px', 'important');
                        icon.style.setProperty('border-bottom-left-radius', '12px', 'important');
                        icon.style.setProperty('border-bottom-right-radius', '12px', 'important');
                        
                        // Force reflow
                        icon.offsetHeight;
                        
                       
                    }
                    
                    const finalComputedStyle3 = window.getComputedStyle(icon);
                    const finalBorderRadius3 = finalComputedStyle3.borderRadius;
                }, 1000);
            } else {
               
            }
        }
        
        // Ensure base panel CSS is always applied
        // NOTE: Does NOT set width, height, font-size, or padding - CSS media queries handle those
        ensureBasePanelCSS() {
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            if (panel) {
                // Apply only essential non-responsive CSS properties that should never be removed
                // DO NOT set width, height, font-size, padding - CSS media queries handle those
                panel.style.setProperty('position', 'fixed', 'important');
                panel.style.setProperty('z-index', '2147483646', 'important');
                panel.style.setProperty('background', '#ffffff', 'important');
                panel.style.setProperty('box-shadow', '0 10px 15px -3px rgba(0, 0, 0, 0.1)', 'important');
                panel.style.setProperty('border-radius', '8px', 'important');
                panel.style.setProperty('font-family', "'DM Sans', sans-serif", 'important');
                panel.style.setProperty('pointer-events', 'auto', 'important');
                panel.style.setProperty('overflow-y', 'auto', 'important');
                panel.style.setProperty('overflow-x', 'hidden', 'important');
                panel.style.setProperty('-webkit-overflow-scrolling', 'touch', 'important');
                panel.style.setProperty('scroll-behavior', 'smooth', 'important');
                panel.style.setProperty('overscroll-behavior', 'contain', 'important');
                
                // DON'T set height, top, or bottom here - let updateInterfacePosition() handle dynamic positioning
                // panel.style.setProperty('height', '100vh', 'important'); // REMOVED - interferes with dynamic positioning
                // panel.style.setProperty('top', '0', 'important'); // REMOVED - interferes with dynamic positioning
                // panel.style.setProperty('bottom', '0', 'important'); // REMOVED - interferes with dynamic positioning
                
                // Add text wrapping to ensure all text is visible
                panel.style.setProperty('word-wrap', 'break-word', 'important');
                panel.style.setProperty('word-break', 'break-word', 'important');
                panel.style.setProperty('overflow-wrap', 'break-word', 'important');
                panel.style.setProperty('hyphens', 'auto', 'important');
                
                // DO NOT set width, max-width, font-size, padding here
                // CSS media queries in getWidgetCSS() handle all responsive sizing
          
            }
        }
        
        // Force apply mobile responsive styles
        applyMobileResponsiveStyles() {
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            
          
            
            if (panel && icon) {
                // First ensure base CSS is applied
                this.ensureBasePanelCSS();
                
                // Add mobile-mode class - CSS media queries handle all responsive sizing automatically
                panel.classList.add('mobile-mode');
                
                // Apply mobile button stacking and size reductions (layout changes, not sizing)
                this.applyMobileButtonStacking();
                this.applyMobileSizeReductions();
                
                // Only apply customization-specific styles (color, shape) - NOT sizing
                // CSS media queries handle width, height, font-size, padding automatically
                if (this.customizationData) {
                    // Preserve customization color
                    if (this.customizationData.triggerButtonColor) {
                        icon.style.setProperty('background-color', this.customizationData.triggerButtonColor, 'important');
                    }
                    
                    // Preserve customization shape (mobile shape takes precedence if exists)
                    if (this.customizationData.mobileTriggerShape) {
                        this.updateMobileTriggerShape(this.customizationData.mobileTriggerShape);
                    } else if (this.customizationData.triggerButtonShape) {
                        this.updateTriggerButtonShape(this.customizationData.triggerButtonShape);
                    }
                }
            }
        }
        
        // Remove mobile responsive styles for desktop
        removeMobileResponsiveStyles() {
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            
          
            
            if (panel && icon) {
                // First ensure base CSS is applied
                this.ensureBasePanelCSS();
                
                // Remove mobile-mode class (CSS media queries will handle sizing automatically)
                panel.classList.remove('mobile-mode');
                
                // Remove only JavaScript-applied mobile-specific styles (not CSS-controlled sizing)
                // CSS media queries handle responsive sizing, so we don't need to remove width/height/font-size
                panel.style.removeProperty('left');
                panel.style.removeProperty('right');
                panel.style.removeProperty('top');
                panel.style.removeProperty('transform');
                panel.style.removeProperty('max-height');
                
                // Remove mobile button stacking
                this.removeMobileButtonStacking();
                
                // Remove mobile size reductions
                this.removeMobileSizeReductions();
                
                // Don't remove icon width/height - CSS media queries handle this
                // Only remove if they were explicitly set by JavaScript (check for inline style)
                if (icon.style.width && icon.style.width.includes('px')) {
                    // Only remove if it was set to a mobile size (40px, 45px)
                    const currentWidth = parseInt(icon.style.width);
                    if (currentWidth <= 45) {
                        icon.style.removeProperty('width');
                        icon.style.removeProperty('height');
                    }
                }
                
                const iconI = icon.querySelector('i');
                if (iconI && iconI.style.fontSize) {
                    const currentFontSize = parseInt(iconI.style.fontSize);
                    if (currentFontSize <= 18) {
                        iconI.style.removeProperty('font-size');
                    }
                }
                
                // CRITICAL: Reapply desktop customizations after removing mobile styles
                // This ensures icon maintains its color, shape, size, position, and offset
                this.reapplyDesktopIconCustomizations();
            }
        }
        
        // Reapply desktop icon customizations to restore styles after mobile removal
        reapplyDesktopIconCustomizations() {
            if (!this.customizationData) {
                return;
            }
            
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (!icon) {
                return;
            }
            
            // Only reapply desktop customizations (not mobile)
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                return; // Don't reapply desktop styles on mobile
            }
            
            // Reapply color
            if (this.customizationData.triggerButtonColor) {
                this.updateTriggerButtonColor(this.customizationData.triggerButtonColor);
            }
            
            // Reapply shape
            if (this.customizationData.triggerButtonShape) {
                this.updateTriggerButtonShape(this.customizationData.triggerButtonShape);
            }
            
            // Reapply size
            if (this.customizationData.triggerButtonSize) {
                this.updateTriggerButtonSize(this.customizationData.triggerButtonSize);
            }
            
            // Reapply position
            if (this.customizationData.triggerHorizontalPosition) {
                this.updateTriggerPosition('horizontal', this.customizationData.triggerHorizontalPosition);
            }
            
            if (this.customizationData.triggerVerticalPosition) {
                this.updateTriggerPosition('vertical', this.customizationData.triggerVerticalPosition);
            }
            
            // Reapply offsets
            if (this.customizationData.triggerHorizontalOffset) {
                this.updateTriggerOffset('horizontal', this.customizationData.triggerHorizontalOffset);
            }
            
            if (this.customizationData.triggerVerticalOffset) {
                this.updateTriggerOffset('vertical', this.customizationData.triggerVerticalOffset);
            }
            
            // Reapply icon image if set
            const iconValue = this.customizationData.selectedIcon || this.customizationData.triggerIcon;
            if (iconValue) {
                this.updateSelectedIcon(iconValue);
            }
        }
        
        
        updateTriggerOffset(direction, offset) {
          
            
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                const isMobile = window.innerWidth <= 768;

                
                // Only apply desktop offsets on desktop/tablet
                if (!isMobile) {
                    
                    const cs = window.getComputedStyle(icon);
                    const currentLeftRaw = icon.style.left || cs.left;
                    const currentRightRaw = icon.style.right || cs.right;
                    const currentTopRaw = icon.style.top || cs.top;
                    const currentBottomRaw = icon.style.bottom || cs.bottom;
                    const currentTransformRaw = icon.style.transform || cs.transform || '';
    

    
                    const normalizedOffset = (typeof offset === 'number' || /^-?\d+$/.test(String(offset))) ? `${offset}px` : String(offset);
                    
                if (direction === 'horizontal') {
                        // Check which side the icon is positioned on
                       
                        
                        if (currentLeftRaw && currentLeftRaw !== 'auto' && currentLeftRaw !== '0px' && currentLeftRaw !== '0') {
                            // Icon is positioned from left
                            const currentLeft = currentLeftRaw;
                            const newLeft = currentLeft.includes('calc') ? 
                                currentLeft.replace(')', ` + ${normalizedOffset})`) : 
                                `calc(${currentLeft} + ${normalizedOffset})`;
                            icon.style.setProperty('left', newLeft, 'important');
                           
                        } else if (currentRightRaw && currentRightRaw !== 'auto' && currentRightRaw !== '0px' && currentRightRaw !== '0') {
                            // Icon is positioned from right
                            const currentRight = currentRightRaw;
                            const newRight = currentRight.includes('calc') ? 
                                currentRight.replace(')', ` + ${normalizedOffset})`) : 
                                `calc(${currentRight} + ${normalizedOffset})`;
                            icon.style.setProperty('right', newRight, 'important');
                     
                        } else {

                            // Default to left positioning if no clear positioning is found
                            const defaultLeft = '20px';
                            const newLeft = `calc(${defaultLeft} + ${normalizedOffset})`;
                            icon.style.setProperty('left', newLeft, 'important');
                            icon.style.setProperty('right', 'auto', 'important');
                      
                    }
                } else if (direction === 'vertical') {
                       
                        
                        if (currentTopRaw && currentTopRaw !== 'auto' && currentTopRaw !== '0px' && currentTopRaw !== '0') {
                            // Icon is positioned from top
                            const currentTop = currentTopRaw;
                            if (currentTop === '50%') {
                                // For middle position, adjust the transform
                                const currentTransform = currentTransformRaw || 'translateY(-50%)';
                                const newTransform = currentTransform.includes('calc') ? 
                                    currentTransform.replace(')', ` + ${normalizedOffset})`) : 
                                    `translateY(calc(-50% + ${normalizedOffset}))`;
                                icon.style.setProperty('transform', newTransform, 'important');
                               
                        } else {
                                const newTop = currentTop.includes('calc') ? 
                                    currentTop.replace(')', ` + ${normalizedOffset})`) : 
                                    `calc(${currentTop} + ${normalizedOffset})`;
                                icon.style.setProperty('top', newTop, 'important');
                         
                            }
                        } else if (currentBottomRaw && currentBottomRaw !== 'auto' && currentBottomRaw !== '0px' && currentBottomRaw !== '0') {
                            // Icon is positioned from bottom
                            const currentBottom = currentBottomRaw;
                            const newBottom = currentBottom.includes('calc') ? 
                                currentBottom.replace(')', ` + ${normalizedOffset})`) : 
                                `calc(${currentBottom} + ${normalizedOffset})`;
                            icon.style.setProperty('bottom', newBottom, 'important');
                   
                        } else {
                    
                            // Default to top positioning if no clear positioning is found
                            const defaultTop = '20px';
                            const newTop = `calc(${defaultTop} + ${normalizedOffset})`;
                            icon.style.setProperty('top', newTop, 'important');
                            icon.style.setProperty('bottom', 'auto', 'important');
                           
                        }
                    }
                    
                   
                } else {
                    // Store the offset values for when desktop positioning is applied
                    this.desktopHorizontalOffset = direction === 'horizontal' ? offset : (this.desktopHorizontalOffset || 0);
                    this.desktopVerticalOffset = direction === 'vertical' ? offset : (this.desktopVerticalOffset || 0);
                }
            }
        }
        
        updateTriggerButtonSize(size) {
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                // Use data attribute and CSS classes instead of inline styles
                // This allows CSS media queries to work properly
                icon.setAttribute('data-size', size.toLowerCase());
                
                // Remove old size classes
                icon.classList.remove('size-small', 'size-medium', 'size-large');
                
                // Add new size class
                if (size === 'Small') {
                    icon.classList.add('size-small');
                } else if (size === 'Medium') {
                    icon.classList.add('size-medium');
                } else if (size === 'Large') {
                    icon.classList.add('size-large');
                }
                
                // Only set inline styles as fallback if CSS classes don't work
                // But use CSS custom properties so media queries can override
                const isMobile = window.innerWidth <= 768;
                if (!isMobile) {
                    // Desktop: apply custom size (CSS media queries will scale on mobile)
                    if (size === 'Small') {
                        icon.style.setProperty('--custom-icon-size', '40px');
                        icon.style.setProperty('--custom-icon-font-size', '16px');
                    } else if (size === 'Medium') {
                        icon.style.setProperty('--custom-icon-size', '50px');
                        icon.style.setProperty('--custom-icon-font-size', '20px');
                    } else if (size === 'Large') {
                        icon.style.setProperty('--custom-icon-size', '60px');
                        icon.style.setProperty('--custom-icon-font-size', '24px');
                    }
                }
            }
        }
        
        updateTriggerVisibility(hidden) {
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (!icon) return;
            
            if (hidden) {
                // Hide icon if hidden is true
                console.log('[ICON HIDE] updateTriggerVisibility() - hidden=true');
                icon.style.display = 'none';
                icon.style.visibility = 'hidden';
                icon.style.opacity = '0';
            } else {
                // Show icon if hidden is false
                console.log('[ICON SHOW] updateTriggerVisibility() - hidden=false');
                icon.style.display = '';
                icon.style.visibility = 'visible';
                icon.style.opacity = '1';
            }
        }
        
        updateInterfaceColor(color) {
     
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            if (panel) {
                panel.style.backgroundColor = color;
            }
        }
        
        // Ensure CSS is always present in Shadow DOM
        // This method ensures CSS is loaded together with widget HTML at all times
        ensureWidgetCSS() {
            if (!this.shadowRoot) {
                return; // Shadow root doesn't exist yet
            }
            
            // Check if CSS style element exists
            let style = this.shadowRoot.querySelector('style[data-widget-css="true"]');
            
            if (!style) {
                // CSS is missing - inject it immediately
                style = document.createElement('style');
                style.setAttribute('data-widget-css', 'true');
                style.setAttribute('id', 'accessbit-widget-styles');
                style.textContent = this.getWidgetCSS();
                // Insert CSS FIRST in shadowRoot to ensure it loads before any HTML
                this.shadowRoot.insertBefore(style, this.shadowRoot.firstChild);
            } else {
                // CSS exists - verify content is present
                if (!style.textContent || style.textContent.trim().length === 0) {
                    style.textContent = this.getWidgetCSS();
                }
            }
        }
        
        updateInterfacePosition() {
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            
            if (!icon || !panel) {
                return; // Don't proceed if elements don't exist
            }
            
            // CRITICAL: Only update position if icon is visible
            // If icon is hidden, getBoundingClientRect() returns zeros and breaks positioning
            const iconComputedStyle = window.getComputedStyle(icon);
            const iconIsVisible = iconComputedStyle.display !== 'none' && 
                                 iconComputedStyle.visibility !== 'hidden' &&
                                 iconComputedStyle.opacity !== '0';
            
            if (!iconIsVisible) {
                return; // Don't update position if icon is hidden
            }
            
            const iconRect = icon.getBoundingClientRect();
            
            // If icon has zero dimensions, it's not properly rendered yet
            if (iconRect.width === 0 || iconRect.height === 0) {
                return; // Don't update position if icon isn't rendered
            }
            
            // Get actual panel dimensions from computed styles (respects CSS media queries)
            const panelComputedStyle = window.getComputedStyle(panel);
            // Make panel visible to get accurate dimensions (it should be visible when positioning)
            const wasHidden = panel.style.visibility === 'hidden' || panel.style.display === 'none' || 
                             !panel.classList.contains('active');
            if (wasHidden) {
                panel.style.visibility = 'visible';
                panel.style.display = 'block';
                panel.classList.add('active');
            }
            
            // Force a reflow to ensure dimensions are accurate
            void panel.offsetHeight;
            
            const panelRect = panel.getBoundingClientRect();
            const panelWidth = panelRect.width || parseFloat(panelComputedStyle.width) || 500;
            // Get actual panel height for positioning calculation
            // Use actual rendered height if available, otherwise estimate
            let panelHeightForPositioning = panelRect.height;
            if (panelHeightForPositioning === 0 || panelHeightForPositioning < 100) {
                // Panel height not available yet - use CSS height or reasonable estimate
                panelHeightForPositioning = parseFloat(panelComputedStyle.height) || 
                                          parseFloat(panelComputedStyle.maxHeight) || 
                                          (window.innerWidth <= 768 ? 400 : 600); // Different defaults for mobile vs desktop
            }
            
            // Keep panel visible - don't hide it again since we're positioning it
            
            // ALL SCREENS: Panel appears ABOVE the icon, fits viewport, no overflow
            const spacing = 10; // Small spacing from icon
            const panelMaxHeight = window.innerHeight * 0.85; // Max 85% of viewport height
            
            // Determine which side of the screen the icon is on (for horizontal positioning)
            const screenCenterX = window.innerWidth / 2;
            const iconCenterX = iconRect.left + (iconRect.width / 2);
            const iconIsOnLeft = iconCenterX < screenCenterX;
            
            // Check if we're on mobile/tablet for width adjustment (extended to 1024px for larger tablets)
            const isMobileOrTablet = window.innerWidth <= 1024;
            
            let finalLeft, finalRight, finalTop, finalBottom;
            
            // Calculate vertical position: panel should appear DIRECTLY ABOVE the icon on ALL screens
            // Position panel so its bottom edge is spacingAbove pixels above the icon's top edge
            const spacingAbove = 15; // Space between icon top and panel bottom
            
            // Calculate where panel top should be: icon top - spacing - panel height
            const desiredTop = iconRect.top - spacingAbove - panelHeightForPositioning;
            
            // If there's not enough space above the icon, position from top of viewport
            // But ensure panel bottom doesn't overlap the icon
            if (desiredTop < 10) {
                // Not enough space above - position from top (10px), but ensure panel doesn't overlap icon
                // Calculate max height that would fit above icon
                const maxHeightAboveIcon = iconRect.top - spacingAbove - 10;
                if (maxHeightAboveIcon > 100) {
                    // There's some space, position panel from top but limit its height
                    finalTop = '10px';
                    finalBottom = 'auto';
                    // We'll limit the panel height later in the code
                } else {
                    // Very little space - position panel starting from top, it will be limited by max-height
                    finalTop = '10px';
                    finalBottom = 'auto';
                }
            } else {
                // Enough space - position directly above icon
                finalTop = `${desiredTop}px`;
                finalBottom = 'auto';
            }
            
            // Horizontal positioning: Panel positioned on same side as icon, above it
            // Determine which side icon is on
            if (iconIsOnLeft) {
                // Icon on left - panel on left side, aligned with icon center
                const panelLeftPosition = iconCenterX - (panelWidth / 2);
                const minLeft = 10;
                const maxLeft = window.innerWidth - panelWidth - 10;
                finalLeft = `${Math.max(minLeft, Math.min(panelLeftPosition, maxLeft))}px`;
                finalRight = 'auto';
            } else {
                // Icon on right - panel on right side, aligned with icon center
                const panelLeftFromRight = iconCenterX - (panelWidth / 2);
                const minLeft = 10;
                const maxLeft = window.innerWidth - panelWidth - 10;
                finalLeft = `${Math.max(minLeft, Math.min(panelLeftFromRight, maxLeft))}px`;
                finalRight = 'auto';
            }
            
            // Adjust for mobile/tablet - use appropriate width but still position relative to icon
            if (isMobileOrTablet) {
                // Mobile (480px): Use smaller width
                // Tablet (481-1024px): Use larger width
                const isMobile = window.innerWidth <= 480;
                const responsiveWidth = isMobile ? 
                    Math.min(window.innerWidth * 0.85, 350) : // Mobile: 85vw, max 350px
                    Math.min(window.innerWidth * 0.90, 450);  // Tablet: 90vw, max 450px
                
                const adjustedLeft = iconCenterX - (responsiveWidth / 2);
                const minLeft = 10;
                const maxLeft = window.innerWidth - responsiveWidth - 10;
                finalLeft = `${Math.max(minLeft, Math.min(adjustedLeft, maxLeft))}px`;
                finalRight = 'auto';
            } else {
                // Desktop: Position on same side as icon, but still above it
                // Center panel horizontally relative to icon position
                const panelCenterX = iconCenterX;
                const panelLeftPosition = panelCenterX - (panelWidth / 2);
                
                // Ensure panel doesn't go outside viewport
                const minLeft = 20;
                const maxLeft = window.innerWidth - panelWidth - 20;
                finalLeft = `${Math.max(minLeft, Math.min(panelLeftPosition, maxLeft))}px`;
                finalRight = 'auto';
            }
            
            // Desktop: Allow panel to expand to fit content, only limit if it would overflow
            // Mobile/Tablet: Limit to 85% of viewport height
            if (isMobileOrTablet) {
                // Mobile/Tablet: Limit height to prevent overflow
                const availableHeight = window.innerHeight - parseFloat(finalTop || '0') - 10;
                const calculatedHeight = Math.min(panelMaxHeight, availableHeight, window.innerHeight * 0.9);
                panel.style.setProperty('height', `${calculatedHeight}px`, 'important');
                panel.style.setProperty('max-height', `${calculatedHeight}px`, 'important');
            } else {
                // Desktop: Allow panel to expand to fit all content
                // Only set max-height to prevent viewport overflow, but allow content to determine height
                const availableHeight = window.innerHeight - parseFloat(finalTop || '0') - 10;
                const maxAllowedHeight = Math.min(window.innerHeight * 0.9, availableHeight);
                panel.style.removeProperty('height'); // Remove fixed height, let content determine it
                panel.style.setProperty('max-height', `${maxAllowedHeight}px`, 'important');
            }
            
            panel.style.setProperty('box-sizing', 'border-box', 'important');
            panel.style.setProperty('overflow-x', 'hidden', 'important');
            panel.style.setProperty('overflow-y', 'auto', 'important');
            
            // Set width based on screen size - ensure it fits viewport on ALL screens
            if (isMobileOrTablet) {
                // Mobile (480px): Smaller width
                // Tablet (481-1024px): Larger width
                const isMobile = window.innerWidth <= 480;
                const mobileWidth = isMobile ? 
                    Math.min(window.innerWidth * 0.85, 350) : // Mobile: 85vw, max 350px
                    Math.min(window.innerWidth * 0.90, 450);  // Tablet: 90vw, max 450px
                const leftMargin = parseFloat(finalLeft || '0');
                const rightMargin = 10;
                const maxAvailableWidth = window.innerWidth - leftMargin - rightMargin;
                const finalMobileWidth = Math.min(mobileWidth, maxAvailableWidth);
                
                panel.style.setProperty('width', `${finalMobileWidth}px`, 'important');
                panel.style.setProperty('max-width', `${finalMobileWidth}px`, 'important');
            } else {
                // Desktop: Use CSS-defined width (from media queries), but ensure it fits viewport
                const leftMargin = parseFloat(finalLeft || '0');
                const rightMargin = 20;
                const maxAvailableWidth = window.innerWidth - leftMargin - rightMargin;
                const cssDefinedWidth = parseFloat(panelComputedStyle.width) || panelWidth;
                
                // Use the smaller of: CSS-defined width or available viewport width
                const finalWidth = Math.min(cssDefinedWidth, maxAvailableWidth, window.innerWidth - 40);
                
                panel.style.setProperty('width', `${finalWidth}px`, 'important');
                panel.style.setProperty('max-width', `${finalWidth}px`, 'important');
                
                // If panel would overflow, adjust left position to keep it in viewport
                if (leftMargin + finalWidth > window.innerWidth - rightMargin) {
                    const adjustedLeft = Math.max(20, window.innerWidth - finalWidth - rightMargin);
                    finalLeft = `${adjustedLeft}px`;
                }
            }
            
            // Only update positioning, don't remove transform if panel is hidden
            // Preserve panel's visibility state
            const isPanelHidden = panel.style.transform === 'translateX(-100%)' || 
                                 panel.style.visibility === 'hidden' ||
                                 !panel.classList.contains('active');
            
            // Set position - use fixed positioning relative to viewport
            // Use !important to ensure positioning overrides CSS and fits viewport
            // CRITICAL: Remove any existing positioning that might interfere
            panel.style.removeProperty('margin');
            panel.style.removeProperty('margin-left');
            panel.style.removeProperty('margin-right');
            panel.style.removeProperty('margin-top');
            panel.style.removeProperty('margin-bottom');
            
            panel.style.setProperty('position', 'fixed', 'important');
            panel.style.setProperty('left', finalLeft, 'important');
            if (finalRight !== undefined && finalRight !== 'auto') {
                panel.style.setProperty('right', finalRight, 'important');
            } else {
                panel.style.removeProperty('right');
            }
            panel.style.setProperty('top', finalTop, 'important');
            if (finalBottom !== undefined && finalBottom !== 'auto') {
                panel.style.setProperty('bottom', finalBottom, 'important');
            } else {
                panel.style.removeProperty('bottom');
            }
            panel.style.setProperty('z-index', '2147483646', 'important');
            
            // Force a reflow to ensure positioning is applied
            void panel.offsetHeight;
            
            // Final check: Ensure panel doesn't overflow viewport on any screen size
            // Wait for next frame to get accurate dimensions after positioning
            requestAnimationFrame(() => {
                const finalPanelRect = panel.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Check horizontal overflow
                if (finalPanelRect.right > viewportWidth) {
                    // Panel is overflowing right edge - adjust left position
                    const overflow = finalPanelRect.right - viewportWidth;
                    const currentLeft = parseFloat(finalLeft) || 0;
                    const newLeft = Math.max(10, currentLeft - overflow - 10);
                    panel.style.setProperty('left', `${newLeft}px`, 'important');
                }
                if (finalPanelRect.left < 0) {
                    // Panel is overflowing left edge - adjust
                    panel.style.setProperty('left', '10px', 'important');
                }
                
                // Check vertical overflow
                if (finalPanelRect.bottom > viewportHeight) {
                    // Panel is overflowing bottom edge - adjust height
                    const currentTop = parseFloat(finalTop || '0');
                    const maxHeight = viewportHeight - currentTop - 10;
                    panel.style.setProperty('height', `${Math.max(200, maxHeight)}px`, 'important');
                    panel.style.setProperty('max-height', `${Math.max(200, maxHeight)}px`, 'important');
                }
                if (finalPanelRect.top < 0) {
                    // Panel is overflowing top edge - adjust top position
                    panel.style.setProperty('top', '10px', 'important');
                }
            });
            
            // Only remove transform if panel is visible, otherwise preserve it
            if (!isPanelHidden) {
                panel.style.setProperty('transform', 'none');
            }
        }
    
        updateInterfaceFooter(content) {
        
            let footer = this.shadowRoot?.getElementById('accessbit-widget-footer');
            if (!footer) {
                // Create footer if it doesn't exist
                footer = document.createElement('div');
                footer.id = 'accessbit-widget-footer';
                footer.style.padding = '10px';
                footer.style.borderTop = '1px solid #eee';
                footer.style.fontSize = '12px';
                footer.style.color = '#666';
                const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
                if (panel) {
                    panel.appendChild(footer);
                }
            }
            if (footer) {
                footer.textContent = content;
            }
        }
        
        updateAccessibilityStatementLink(link) {
           
            let statementLink = this.shadowRoot?.getElementById('accessbit-statement-link');
            if (!statementLink) {
                // Create link if it doesn't exist
                statementLink = document.createElement('a');
                statementLink.id = 'accessbit-statement-link';
                statementLink.style.display = 'block';
                statementLink.style.padding = '10px';
                statementLink.style.textAlign = 'center';
                statementLink.style.color = '#007bff';
                statementLink.style.textDecoration = 'none';
                statementLink.style.fontSize = '12px';
                statementLink.target = '_blank';
                const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
                if (panel) {
                    panel.appendChild(statementLink);
                }
            }
            if (statementLink) {
                statementLink.href = link;
                statementLink.textContent = 'Accessibility Statement';
            }
        }
        
       updateSelectedIcon(icon) {
        console.log('[DEBUG] Applying Icon:', {
            iconValue: icon,
            iconType: typeof icon,
            iconTrimmed: icon ? String(icon).trim() : null
        });
    const iconElement = this.shadowRoot?.getElementById('accessbit-widget-icon');
    
    if (iconElement) {
        const iconMap = {
            'accessibility': 'fas fa-universal-access',
            'wheelchair': 'fas fa-wheelchair',
            'eye': 'fas fa-eye',
            'ear': 'fas fa-deaf',
            'brain': 'fas fa-brain',
            'hand': 'fas fa-hand-paper',
            'heart': 'fas fa-heart',
            'star': 'fas fa-star',
            'gear': 'fas fa-cog',
            'settings': 'fas fa-sliders-h'
        };
        
        // Normalize icon value (trim whitespace, lowercase for comparison)
        const normalizedIcon = icon ? String(icon).trim().toLowerCase() : '';
        const iconClass = iconMap[normalizedIcon] || iconMap[icon] || 'fas fa-universal-access';
        
        console.log('[DEBUG] Icon mapping result:', {
            originalIcon: icon,
            normalizedIcon: normalizedIcon,
            mappedClass: iconClass,
            iconMapKeys: Object.keys(iconMap),
            foundInMap: normalizedIcon in iconMap || icon in iconMap
        });
        
        
        const existingIcon = iconElement.querySelector('i');
        if (existingIcon) {
            existingIcon.remove();
        }
   
        const sanitizedIconClass = this.validateClassName(iconClass);
        const iconInner = document.createElement('i');
        iconInner.className = sanitizedIconClass;
        iconElement.appendChild(iconInner); // Now it appends to a clean container
        
        // Ensure proper styling
        iconElement.style.display = 'flex';
        iconElement.style.alignItems = 'center';
        iconElement.style.justifyContent = 'center';
        iconElement.style.color = '#ffffff';
        iconElement.style.fontSize = 'inherit';
    }
}
        
        updateSelectedIconName(name) {
          
            const iconElement = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (iconElement) {
                iconElement.setAttribute('aria-label', name);
                iconElement.setAttribute('title', name);
            }
        }
        
        updateMobileVisibility(visible) {
            // Icon visibility is handled explicitly in init() after customizations are applied
            // No need to call showIcon() here as it may conflict with explicit icon showing
        }
        
        updateMobileTriggerPosition(direction, position) {
          
            const normalizedDirection = (direction || '').toLowerCase();
            const pos = (position || '').toLowerCase();
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    // First, clear all existing positioning
                    icon.style.removeProperty('top');
                    icon.style.removeProperty('bottom');
                    icon.style.removeProperty('left');
                    icon.style.removeProperty('right');
                    icon.style.removeProperty('transform');
                    
                    if (normalizedDirection === 'horizontal') {
                        if (pos === 'left') {
                            icon.style.setProperty('left', '10px');
                            icon.style.setProperty('right', 'auto');
                   
                        } else if (pos === 'right') {
                            icon.style.setProperty('right', '10px');
                            icon.style.setProperty('left', 'auto');
                  
                        }
                    } else if (normalizedDirection === 'vertical') {
                        if (pos === 'top') {
                            icon.style.setProperty('top', '10px');
                            icon.style.setProperty('bottom', 'auto');
                            icon.style.setProperty('transform', 'none');
                        
                        } else if (pos === 'bottom') {
                            icon.style.setProperty('bottom', '10px');
                            icon.style.setProperty('top', 'auto');
                            icon.style.setProperty('transform', 'none');
                        
                        } else if (pos === 'middle') {
                            icon.style.setProperty('top', '50%');
                            icon.style.setProperty('bottom', 'auto');
                            icon.style.setProperty('transform', 'translateY(-50%)');
                            
                        }
                    }
                }
            }
        }
        
        // New method to handle combined positioning (e.g., "right middle")
        updateMobileTriggerCombinedPosition(horizontalPos, verticalPos) {
           
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
       
            if (icon) {
                const isMobile = window.innerWidth <= 768;
               
                if (isMobile) {
                   
                    
                    // Clear all existing positioning properties more aggressively
                    icon.style.removeProperty('top');
                    icon.style.removeProperty('bottom');
                    icon.style.removeProperty('left');
                    icon.style.removeProperty('right');
                    icon.style.removeProperty('transform');
                    icon.style.removeProperty('inset');
                    icon.style.removeProperty('position');
                    icon.style.removeProperty('z-index');
                    
                  
                    
                    // Set base positioning with higher specificity
                    icon.style.setProperty('position', 'fixed', 'important');
                    icon.style.setProperty('z-index', '2147483645', 'important');
                    
                   
                    
                    if (horizontalPos === 'Left' || horizontalPos === 'left') {
                        icon.style.setProperty('left', '20px', 'important');
                        icon.style.setProperty('right', 'auto', 'important');
  
                    } else if (horizontalPos === 'Right' || horizontalPos === 'right') {
                        icon.style.setProperty('right', '20px', 'important');
                        icon.style.setProperty('left', 'auto', 'important');
                        
                    }
                    
              
                    if (verticalPos === 'Top' || verticalPos === 'top') {
                        icon.style.setProperty('top', '20px', 'important');
                        icon.style.setProperty('bottom', 'auto', 'important');
                        icon.style.setProperty('transform', 'none', 'important');
                       
                    } else if (verticalPos === 'Bottom' || verticalPos === 'bottom') {
                        icon.style.setProperty('bottom', '20px', 'important');
                        icon.style.setProperty('top', 'auto', 'important');
                        icon.style.setProperty('transform', 'none', 'important');
        
                    } else if (verticalPos === 'Middle' || verticalPos === 'middle') {
                        icon.style.setProperty('top', '50%', 'important');
                        icon.style.setProperty('bottom', 'auto', 'important');
                        icon.style.setProperty('transform', 'translateY(-50%)', 'important');
                        
                    }
    
                    // Force a reflow to ensure styles are applied
                    icon.offsetHeight;
                    
                 
                    
                    // Additional force with a small delay to ensure positioning sticks
                    setTimeout(() => {
                        // Re-apply positioning to ensure it sticks after any other CSS loads
                        if (verticalPos === 'Middle' || verticalPos === 'middle') {
                            icon.style.setProperty('top', '50%', 'important');
                            icon.style.setProperty('bottom', 'auto', 'important');
                            icon.style.setProperty('transform', 'translateY(-50%)', 'important');
                            
                        }
                        
                        // Re-apply stored offsets after re-positioning
                        if (this.mobileHorizontalOffset !== undefined) {
                            
                            this.updateMobileTriggerOffset('horizontal', this.mobileHorizontalOffset);
                        }
                        if (this.mobileVerticalOffset !== undefined) {
                            this.updateMobileTriggerOffset('vertical', this.mobileVerticalOffset);
                        }
                        
                      
                    }, 100);
                    
                    // Apply stored offsets if they exist
                    if (this.mobileHorizontalOffset !== undefined) {
                        this.updateMobileTriggerOffset('horizontal', this.mobileHorizontalOffset);
                    }
                    if (this.mobileVerticalOffset !== undefined) {
                       
                        this.updateMobileTriggerOffset('vertical', this.mobileVerticalOffset);
                    }
                    
                   
                }
            }
        }
        
        updateMobileTriggerSize(size) {
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    // Use data attribute and CSS classes for mobile sizes
                    icon.setAttribute('data-mobile-size', size.toLowerCase());
                    
                    // Remove old size classes
                    icon.classList.remove('mobile-size-small', 'mobile-size-medium', 'mobile-size-large');
                    
                    // Add new size class
                    if (size === 'Small') {
                        icon.classList.add('mobile-size-small');
                        icon.style.setProperty('--custom-mobile-icon-size', '35px');
                        icon.style.setProperty('--custom-mobile-icon-font-size', '14px');
                    } else if (size === 'Medium') {
                        icon.classList.add('mobile-size-medium');
                        icon.style.setProperty('--custom-mobile-icon-size', '45px');
                        icon.style.setProperty('--custom-mobile-icon-font-size', '18px');
                    } else if (size === 'Large') {
                        icon.classList.add('mobile-size-large');
                        icon.style.setProperty('--custom-mobile-icon-size', '55px');
                        icon.style.setProperty('--custom-mobile-icon-font-size', '22px');
                    }
                }
            }
        }
        
        updateMobileTriggerShape(shape) {
           
            
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                  
                    
                    // Clear existing shape properties
                    icon.style.removeProperty('border-radius');
                    icon.style.removeProperty('-webkit-border-radius');
                    icon.style.removeProperty('-moz-border-radius');
                    
                    icon.setAttribute('data-shape', shape.toLowerCase());
                    
                    let borderRadius = '50%';
                    if (shape === 'Circle' || shape === 'circle') {
                        borderRadius = '50%';
             
                    } else if (shape === 'Rounded' || shape === 'rounded') {
                        borderRadius = '12px';
                     
                    } else if (shape === 'Square' || shape === 'square') {
                        borderRadius = '0px';
                     
                    } else {

                    }
                    
                 
                    
                    // Apply with maximum force - multiple attempts to override any external CSS
                    icon.style.setProperty('border-radius', borderRadius, 'important');
                    icon.style.setProperty('-webkit-border-radius', borderRadius, 'important');
                    icon.style.setProperty('-moz-border-radius', borderRadius, 'important');
                    icon.style.setProperty('display', 'flex', 'important');
                    icon.style.setProperty('align-items', 'center', 'important');
                    icon.style.setProperty('justify-content', 'center', 'important');
                    
                    // Force the shape with multiple approaches
                    icon.setAttribute('data-shape', 'rounded');
                    icon.classList.remove('circle', 'square');
                    icon.classList.add('rounded');
                    
                    // Additional force with direct style assignment
                    icon.style.borderRadius = borderRadius;
                    icon.style.webkitBorderRadius = borderRadius;
                    icon.style.mozBorderRadius = borderRadius;
                   
                    
                    // Force reapply after delay
                    setTimeout(() => {
                      
                        icon.style.setProperty('border-radius', borderRadius, 'important');
                        icon.style.setProperty('-webkit-border-radius', borderRadius, 'important');
                        icon.style.setProperty('-moz-border-radius', borderRadius, 'important');
                     
                        
                    // Final verification and force fix if needed
                    const finalComputed = window.getComputedStyle(icon).borderRadius;
                    if (finalComputed === borderRadius) {
                       
                    } else {
                       
                        // Force the shape with maximum aggression
                        icon.style.setProperty('border-radius', borderRadius, 'important');
                        icon.style.setProperty('-webkit-border-radius', borderRadius, 'important');
                        icon.style.setProperty('-moz-border-radius', borderRadius, 'important');
                        icon.style.borderRadius = borderRadius;
                        icon.style.webkitBorderRadius = borderRadius;
                        icon.style.mozBorderRadius = borderRadius;
                        
                        // Force reflow
                        icon.offsetHeight;
                        
                        const finalComputedAfterFix = window.getComputedStyle(icon).borderRadius;
                        if (finalComputedAfterFix === borderRadius) {
                         
                        } else {
                           
                            
                            // Last resort: Create a new style element with maximum specificity
                            const style = document.createElement('style');
                            style.textContent = `
                                .accessbit-widget-icon[data-shape="rounded"] {
                                    border-radius: ${borderRadius} !important;
                                    -webkit-border-radius: ${borderRadius} !important;
                                    -moz-border-radius: ${borderRadius} !important;
                                }
                                .accessbit-widget-icon.rounded {
                                    border-radius: ${borderRadius} !important;
                                    -webkit-border-radius: ${borderRadius} !important;
                                    -moz-border-radius: ${borderRadius} !important;
                                }
                            `;
                            document.head.appendChild(style);
                            
                        }
                    }
                    }, 100);
                    
                    // Check computed style
                    const computedStyle = window.getComputedStyle(icon).borderRadius;
                 
                    
                    if (computedStyle !== borderRadius) {
                   
                    } else {
                      
                    }
                } else {
                    
                }
            }
        }
        
        updateMobileTriggerOffset(direction, offset) {
            
            const icon = this.shadowRoot?.getElementById('accessbit-widget-icon');
            if (icon) {
                const isMobile = window.innerWidth <= 768;

                
                if (isMobile) {
                    const cs = window.getComputedStyle(icon);
                    const currentLeftRaw = icon.style.left || cs.left;
                    const currentRightRaw = icon.style.right || cs.right;
                    const currentTopRaw = icon.style.top || cs.top;
                    const currentBottomRaw = icon.style.bottom || cs.bottom;
                    const currentTransformRaw = icon.style.transform || cs.transform || '';
    
                 
    
                    const normalizedOffset = (typeof offset === 'number' || /^-?\d+$/.test(String(offset))) ? `${offset}px` : String(offset);
                    
                    if (direction === 'horizontal') {
                        // Check which side the icon is positioned on
                        if (currentLeftRaw && currentLeftRaw !== 'auto' && currentLeftRaw !== '0px') {
                            // Icon is positioned from left
                            const currentLeft = currentLeftRaw;
                            const newLeft = currentLeft.includes('calc') ? 
                                currentLeft.replace(')', ` + ${normalizedOffset})`) : 
                                `calc(${currentLeft} + ${normalizedOffset})`;
                            icon.style.setProperty('left', newLeft, 'important');
                            
                        } else if (currentRightRaw && currentRightRaw !== 'auto' && currentRightRaw !== '0px') {
                            // Icon is positioned from right
                            const currentRight = currentRightRaw;
                            const newRight = currentRight.includes('calc') ? 
                                currentRight.replace(')', ` + ${normalizedOffset})`) : 
                                `calc(${currentRight} + ${normalizedOffset})`;
                            icon.style.setProperty('right', newRight, 'important');
                            
                        }
                    } else if (direction === 'vertical') {
                        // Check which side the icon is positioned on
                        if (currentTopRaw && currentTopRaw !== 'auto' && currentTopRaw !== '0px') {
                            // Icon is positioned from top
                            const currentTop = currentTopRaw;
                            if (currentTop === '50%') {
                                // For middle position, adjust the transform
                                const currentTransform = currentTransformRaw || 'translateY(-50%)';
                                const newTransform = currentTransform.includes('calc') ? 
                                    currentTransform.replace(')', ` + ${normalizedOffset})`) : 
                                    `translateY(calc(-50% + ${normalizedOffset}))`;
                                icon.style.setProperty('transform', newTransform, 'important');
                               
                            } else {
                                const newTop = currentTop.includes('calc') ? 
                                    currentTop.replace(')', ` + ${normalizedOffset})`) : 
                                    `calc(${currentTop} + ${normalizedOffset})`;
                                icon.style.setProperty('top', newTop, 'important');
                             
                            }
                        } else if (currentBottomRaw && currentBottomRaw !== 'auto' && currentBottomRaw !== '0px') {
                            // Icon is positioned from bottom
                            const currentBottom = currentBottomRaw;
                            const newBottom = currentBottom.includes('calc') ? 
                                currentBottom.replace(')', ` + ${normalizedOffset})`) : 
                                `calc(${currentBottom} + ${normalizedOffset})`;
                            icon.style.setProperty('bottom', newBottom, 'important');
                           
                        }
                    }
                    
                  
                } else {
                   
                    // Store the offset values for when mobile positioning is applied
                    this.mobileHorizontalOffset = direction === 'horizontal' ? offset : (this.mobileHorizontalOffset || 0);
                    this.mobileVerticalOffset = direction === 'vertical' ? offset : (this.mobileVerticalOffset || 0);
                }
            }
        }
        
        // Helper function to update panel visibility based on position
        updatePanelVisibility(isOpen) {
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            if (panel) {
                const currentTransform = panel.style.transform;
                if (isOpen) {
                    // Show panel
                    if (currentTransform.includes('translateX(-100%)')) {
                        panel.style.transform = 'translateX(0)';
                    } else if (currentTransform.includes('translateX(100%)')) {
                        panel.style.transform = 'translateX(0)';
                    } else {
                        panel.style.transform = 'translateX(0)';
                    }
                } else {
                    // Hide panel
                    if (currentTransform.includes('translateX(-100%)') || panel.style.left === '0px') {
                        panel.style.transform = 'translateX(-100%)';
                    } else if (currentTransform.includes('translateX(100%)') || panel.style.right === '0px') {
                        panel.style.transform = 'translateX(100%)';
                    } else {
                        panel.style.transform = 'translateX(-100%)';
                    }
                }
            }
        }
    
        // Language Dropdown Functions
        setupLanguageDropdownListeners() {

            const dropdown = this.shadowRoot?.getElementById('language-dropdown');
            if (!dropdown) {

                return;
            }
    
            // Get all language options
            const languageOptions = dropdown.querySelectorAll('.language-option');

    
            languageOptions.forEach(option => {
                // Ensure keyboard operability
                option.setAttribute('role', 'option');
                option.setAttribute('tabindex', '0');
                option.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        option.click();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.hideLanguageDropdown();
                    }
                });
    
                option.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const langCode = option.getAttribute('data-lang');
                    const langName = option.querySelector('.language-name')?.textContent;
                    

                    
                    // Update the header to show selected language
                    const currentLanguageHeader = this.shadowRoot?.getElementById('current-language-header');
                    if (currentLanguageHeader && langName) {
                        currentLanguageHeader.textContent = langName.toUpperCase();
                    }
                    
                    // Apply the language
                    if (langCode) {
                        this.applyLanguage(langCode);
                    }
                    
                    // Hide dropdown
                    this.toggleLanguageDropdown();
                });
            });
    

        }
    
        getLanguageNameFromCode(code) {
            const languageMap = {
                'en': 'English',
                'de': 'German', 
                'fr': 'French',
                'he': 'Hebrew',
                'ru': 'Russian',
                'ar': 'Arabic',
                'es': 'Spanish',
                'pt': 'Portuguese',
                'it': 'Italian',
                'tw': 'Chinese'
            };
            return languageMap[code] || 'English';
        }
    
        toggleLanguageDropdown() {

            
            const dropdown = this.shadowRoot?.getElementById('language-dropdown');
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            
            if (!dropdown || !panel) {
                
                return;
            }
    
            const isVisible = dropdown.style.display !== 'none';
            
            if (isVisible) {
                // Hide dropdown
                dropdown.style.display = 'none';

            } else {
                // Position dropdown relative to panel
                this.positionLanguageDropdown();
                
                // Show dropdown
                dropdown.style.display = 'block';
              
                
                // Add click outside handler to close dropdown
                setTimeout(() => {
                    const handleClickOutside = (e) => {
                        if (!dropdown.contains(e.target) && !panel.querySelector('.language-selector-header').contains(e.target)) {
                            dropdown.style.display = 'none';
                            document.removeEventListener('click', handleClickOutside);
                        }
                    };
                    document.addEventListener('click', handleClickOutside);
                }, 100);
            }
        }
    
        positionLanguageDropdown() {
            const dropdown = this.shadowRoot?.getElementById('language-dropdown');
            const panel = this.shadowRoot?.getElementById('accessbit-widget-panel');
            
            if (!dropdown || !panel) {
              
                return;
            }
    
            // Get panel position and dimensions
            const panelRect = panel.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
         
    
            // Determine if panel is on left or right side of screen
            const isPanelOnLeft = panelRect.left < (viewportWidth / 2);
           
    
            // Position dropdown INSIDE the panel, aligned with panel's side
            let dropdownLeft = 0;
            let dropdownTop = 10; // Small offset from top of panel
    
            if (isPanelOnLeft) {
                // Panel is on LEFT - position dropdown on LEFT side of panel
                dropdownLeft = 10; // Small margin from left edge of panel
                
            } else {
                // Panel is on RIGHT - position dropdown on RIGHT side of panel
                dropdownLeft = panelRect.width - 410; // Position from right edge (dropdown width ~400px + 10px margin)
     
            }
    
            // Apply positioning with !important to override any conflicting CSS
            dropdown.style.setProperty('left', `${dropdownLeft}px`, 'important');
            dropdown.style.setProperty('top', `${dropdownTop}px`, 'important');
            dropdown.style.setProperty('position', 'absolute', 'important');
            dropdown.style.setProperty('z-index', '100002', 'important'); // Higher than panel
            
            // Ensure dropdown is positioned relative to panel, not viewport
            dropdown.style.setProperty('transform', 'none', 'important');
            

        }
    
    }
    
    
    
    // Initialize the widget when DOM is loaded
    
    let accessibilityWidget;
    
    
    
    // Wait for DOM to be ready
    
    function initWidget() {
        // CRITICAL: Don't run widget in Webflow Designer environment
        if (isDesignerModeStandalone()) {
            // Exit early - widget should not run in Designer
            return;
        }
    
        accessibilityWidget = new AccessibilityWidget();
    
    }
    
    
    
    // Try multiple ways to initialize
    
    if (document.readyState === 'loading') {
    
        document.addEventListener('DOMContentLoaded', initWidget);
    
    } else {
    
        // DOM is already loaded
    
        initWidget();
    
    }
    
    
    
    // Also try with a small delay as backup
    
    setTimeout(() => {
    
        if (!accessibilityWidget) {
    
          
    
            initWidget();
    
        }
    
    }, 1000);
    
    
    
    // Add global error handler for accessibilityWidget
    
    window.addEventListener('error', (e) => {
    
        if (e.message.includes('accessibilityWidget')) {
    
    
        }
        
    });

    // Payment Status Check - Added functionality
    (function() {
        'use strict';
        
       
        // Check payment status before loading widget
        const checkPaymentStatus = async function() {
            try {
                // Get current domain
                const currentDomain = window.location.hostname;
              
                
                // Check if this is a staging domain (always allow without payment)
                const isStagingDomain = currentDomain.includes('.webflow.io') || 
                                       currentDomain.includes('.webflow.com') || 
                                       currentDomain.includes('localhost') ||
                                       currentDomain.includes('127.0.0.1') ||
                                       currentDomain.includes('staging');
                
                if (isStagingDomain) {
                    return { hasAccess: true, isStaging: true, reason: 'Staging domain - no payment required' };
                }
                
                // Security: Validate domain format
                if (!currentDomain || typeof currentDomain !== 'string' || currentDomain.length > 253) {
                    return { hasAccess: false, isStaging: false };
                }
                // Basic domain validation - alphanumeric, dots, hyphens only
                if (!/^[a-zA-Z0-9.-]+$/.test(currentDomain)) {
                    return { hasAccess: false, isStaging: false };
                }
                
                // For custom domains, validate with signed token from script tag
                // SAFETY: Using specific script filename patterns to avoid matching user content
                // Only matches script tags with our widget filenames, not user elements
                let siteIdParam = null; let siteTokenParam = null;
                try {
                    // Try to find the script tag - check for widget-specific filenames only
                    const scriptEl = document.currentScript || 
                                   document.querySelector('script[src*="test.js"]') ||
                                   document.querySelector('script[src*="new.js"]') ||
                                   document.querySelector('script[src*="accessbit"]') ||
                                   document.querySelector('script[src*="widget.js"]');
                    if (scriptEl && scriptEl.src) {
                        const u = new URL(scriptEl.src);
                        siteIdParam = u.searchParams.get('siteId');
                        siteTokenParam = u.searchParams.get('siteToken');
                        // Security: Validate token format if present
                        if (siteTokenParam && (!/^[a-zA-Z0-9._-]+$/.test(siteTokenParam) || siteTokenParam.length > 500)) {
                            siteTokenParam = null;
                        }
                        // Security: Validate siteId format if present
                        if (siteIdParam && (typeof siteIdParam !== 'string' || siteIdParam.length > 100 || !/^[a-zA-Z0-9_-]+$/.test(siteIdParam))) {
                            siteIdParam = null;
                        }
                    }
                } catch {}
                const visitorId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2));
                const base = ((this && this.kvApiUrl) ? this.kvApiUrl : 'https://accessbit-test-worker.web-8fb.workers.dev').replace(/\/+$/,'');
                let resp = await this.isolatedFetch(`${base}/api/accessibility/validate-domain`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ domain: currentDomain, siteId: siteIdParam, siteToken: siteTokenParam, visitorId })
                });
                if (!resp || !resp.ok) {
                    try {
                        if (resp) {
                            const err = await resp.json();
                            if (resp.status === 401 && err && err.error) {
                                await new Promise(r => setTimeout(r, 500));
                                resp = await this.isolatedFetch(`${base}/api/accessibility/validate-domain`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ domain: currentDomain, siteId: siteIdParam, siteToken: siteTokenParam, visitorId })
                                });
                            }
                        }
                    } catch {}
                }
                if (!resp || !resp.ok) {
                    return { hasAccess: false };
                }
                const v = await resp.json();
                if (v && v.isValid) {
                    return { hasAccess: true };
                }
                return { hasAccess: false };
                
            } catch (error) {
                
                return { hasAccess: false, error: error.message };
            }
        };
        
        // Show payment required message
        const showPaymentMessage = function(reason) {
            // Payment message disabled - no popup will be shown
            
        };
        
        // Initialize payment check
        const initPaymentCheck = async function() {
            const paymentStatus = await checkPaymentStatus();
            
            if (paymentStatus.hasAccess) {
                
                // Widget will continue to load normally
            } else {
                
                showPaymentMessage(paymentStatus.reason || 'Payment required to activate features.');
                
                // Optionally disable widget functionality
                if (window.accessibilityWidget) {
                    window.accessibilityWidget.disable = true;
                }
            }
        };
        
        // Run payment check when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPaymentCheck);
        } else {
            initPaymentCheck();
        }
        
        // Final reader mode check - prevent any widget initialization in reader mode
        // Use standalone reader mode check function
        const checkReaderMode = () => {
            return !isReaderModeStandalone();
        };
        
        // Override all widget functions if reader mode is detected
        if (!checkReaderMode()) {
            // Disable all widget functionality
            if (window.accessibilityWidget) {
                window.accessibilityWidget.disable = true;
                window.accessibilityWidget.init = () => {};
                window.accessibilityWidget.show = () => {};
                window.accessibilityWidget.hide = () => {};
            }
            
            // Remove any injected styles
            const widgetStyles = document.querySelectorAll('style[id*="accessbit-widget"], style[id*="accessbit-"]');
            widgetStyles.forEach(style => style.remove());
            
            // Remove any injected elements
            const widgetElements = document.querySelectorAll('[id*="accessbit-widget"], [class*="accessbit-widget"], [class*="accessbit-root"]');
            widgetElements.forEach(el => el.remove());
            
            return; // Exit early
        }
        
    })();
    
